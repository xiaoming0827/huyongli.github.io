{"meta":{"title":"老胡","subtitle":"心若在，梦就在","description":null,"author":"老胡","url":"http://ittiger.cn"},"pages":[{"title":"关于我","date":"2016-07-28T05:04:20.000Z","updated":"2016-11-09T08:38:56.816Z","comments":true,"path":"about/index.html","permalink":"http://ittiger.cn/about/index.html","excerpt":"","text":"介绍我是老胡，工作在武汉的应城人。 闷而不骚的Android码农一枚，爱编程爱足球。 githubhttps://github.com/huyongli 微博老胡-Tiger 联系方式下面是我建的QQ群，欢迎进群交流"},{"title":"分类","date":"2016-11-10T01:44:17.866Z","updated":"2016-11-10T01:44:17.866Z","comments":true,"path":"categories/index.html","permalink":"http://ittiger.cn/categories/index.html","excerpt":"","text":"&lt;!–title: categoriesdate: 2016-07-28 12:32:40type: “categories” comments: true–&gt;"},{"title":"标签","date":"2016-11-10T01:44:17.866Z","updated":"2016-11-10T01:44:17.866Z","comments":true,"path":"tags/index.html","permalink":"http://ittiger.cn/tags/index.html","excerpt":"","text":"&lt;!–title: tagsdate: 2016-07-28 12:31:17type: “tags” comments: false–&gt;"},{"title":"","date":"2016-08-04T07:57:49.000Z","updated":"2016-11-10T01:44:17.866Z","comments":true,"path":"website/index.html","permalink":"http://ittiger.cn/website/index.html","excerpt":"","text":"以下是我收集的一些比较好的站点导航类 安卓书签网 &nbsp;&nbsp;&nbsp;&nbsp;专门收集各类Android资源的导航网站 wan android &nbsp;&nbsp;&nbsp;&nbsp;鸿洋出品 极客导航 &nbsp;&nbsp;&nbsp;&nbsp;Android，IOS，前端，设计均有 资讯类 掘金 &nbsp;&nbsp;&nbsp;&nbsp;每天收集优秀博文 开发者头条 &nbsp;&nbsp;&nbsp;&nbsp;与掘金类似，但是无法选择文章分类 开发技术前线 &nbsp;&nbsp;&nbsp;&nbsp;各种技术文章聚合类网站 技术头条 干货集中营 &nbsp;&nbsp;&nbsp;&nbsp;代码家出品 Android开发技术周报 &nbsp;&nbsp;&nbsp;&nbsp;脉脉不得语出品 Android博客周刊 Web资源网 并发编程网 泡在网上的日子 优质互联网技术团队 阿里技术沙龙 美团点评技术团队 腾讯技术团队 优秀博客 图说设计模式 Drakeet 鸿洋 郭霖 Lite-马天宇 廖枯秋 胡凯 trinea stormzhang 贾吉鑫 翟一凡 大头鬼 Mr.Simple 开源实验室-张涛 徐宜生 任玉刚 老罗 江清清技术专栏 孙福生博客 为数不多的维术 Android笔记 残剑博客 itxuye Java技术博客 源码库 codekk Android最新源码汇总 &nbsp;&nbsp;&nbsp;&nbsp;各种开源库源码 codota android-arsenal 开发工具 AndroidDevTools Android开发工具汇总"}],"posts":[{"title":"自定义Behavior实现快速返回效果","slug":"Custom-Behavior-to-fast-back","date":"2017-02-28T03:22:00.000Z","updated":"2017-03-03T02:09:17.498Z","comments":true,"path":"Custom-Behavior-to-fast-back.html","link":"","permalink":"http://ittiger.cn/Custom-Behavior-to-fast-back.html","excerpt":"Behavior是Android Design包中出现的一个概念，Android Design包中很多控件的动画效果都是使用Behavior实现的，所以想要更好的实现Material Design风格的应用就有必要弄清楚Behavior。这篇文章从简单开始，介绍如何自定义Behavior以实现快速返回的效果。 还是先看下最终实现的效果","text":"Behavior是Android Design包中出现的一个概念，Android Design包中很多控件的动画效果都是使用Behavior实现的，所以想要更好的实现Material Design风格的应用就有必要弄清楚Behavior。这篇文章从简单开始，介绍如何自定义Behavior以实现快速返回的效果。 还是先看下最终实现的效果 介绍先看官方介绍https://developer.android.google.cn/reference/android/support/design/widget/CoordinatorLayout.Behavior.html Interaction behavior plugin for child views of CoordinatorLayout. A Behavior implements one or more interactions that a user can take on a child view. These interactions may include drags, swipes, flings, or any other gestures. 上面的介绍说Behavior是CoordinatorLayout子视图的一个交互插件，它可以为子视图实现一个或多个交互，这些交互包括拖拽，滑动或其他的手势操作。 通过上面的介绍我们知道Behavior是作用于CoordinatorLayout子视图的，而CoordinatorLayout我们可以把它看做一个FrameLayout。 根据我的理解来说Behavior其实就是一系列手势操作行为的回调，通过这些回调来处理CoordinatorLayout子视图的手势操作。 使用用过Android Design库中AppBarLayout与NestedScrollView这两个类的同学应该知道，这两个类一起使用会产生很漂亮的滑动效果，这也是Android库中对Behavior的一个很典型的应用。而对于Behavior的使用，也可以参考这两个类的两种使用方式： 为CoordinatorLayout的直接子View设置app:layout_behavior=“behavior完全类名” 为CoordinatorLayout的某个子View设置默认Behavior，设置方式是在该View的类声明上添加注解@CoordinatorLayout.DefaultBehavior(Behavior类.class) Behavior相关方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class BackTopBehavior extends CoordinatorLayout.Behavior &#123; public MyBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); //必须实现此构造方法，因为CoordinatorLayout中初始化Behavior时是通过反射调用此构造来进行初始化的 &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) &#123; return super.layoutDependsOn(parent, child, dependency); //判断视图child进行layout布局时是否依赖于某个特定的View dependency //child是指应用此Behavior的View，dependency是触发执行此Behavior的视图并与child进行相关交互，也就是上面所说的是child的依赖 //此方法在CoordinatorLayout进行request layout时至少会调用一次 //如果返回true，CoordinatorLayout会总是在依赖视图dependency layout完成之后对child视图进行layout布局 //同时如果依赖视图dependency的layout或position发生变化，CoordinatorLayout会调用onDependentViewChanged &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) &#123; return super.onDependentViewChanged(parent, child, dependency); //此方法的调用时机参考上面的方法layoutDependsOn的说明 //当child的依赖视图dependency发生layout变化后，如果想对child布局(child's size or position)做出相应变化则返回true否则返回false，具体对child如何update则需要在onLayoutChild中进行实现 &#125; @Override public void onDependentViewRemoved(CoordinatorLayout parent, View child, View dependency) &#123; super.onDependentViewRemoved(parent, child, dependency); //当child的依赖视图dependency从其parent中remove掉后会调用此方法 &#125; @Override public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; return super.onMeasureChild(parent, child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed); //当测量CoordinatorLayout的子视图child时调用此方法 &#125; @Override public boolean onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) &#123; return super.onLayoutChild(parent, child, layoutDirection); //当对CoordinatorLayout的子视图child进行layout布局时会调用此方法 //当child的依赖视图layout结束之后，会调用此方法对child进行layout布局 //如果onDependentViewChanged中返回了true，则需要在此方法中对child视图进行update &#125; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) &#123; return super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); //滑动开始调用，返回true表示此Behavior接收此滑动，才会有后续的滑动处理 &#125; @Override public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target) &#123; super.onStopNestedScroll(coordinatorLayout, child, target); //滑动结束调用 &#125; @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); //滑动过程中调用 &#125; @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) &#123; super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed); //滑动过程中，在child自身消费掉此次滑动的distance之前调用此方法 //onNestedPreScroll is called each time the nested scroll is updated by the nested scrolling child // before the nested scrolling child has consumed the scroll distance itself &#125; @Override public boolean onNestedFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY, boolean consumed) &#123; return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed); //快速滑动时调用此方法 &#125;&#125; 上面就是Behavior中比较常用比较重要的一些方法。 自定义Behavior我要实现的是在在列表上滑时，显示快速返回按钮，列表下滑时隐藏快速返回按钮，当快速返回按钮显示时，点击该按钮，列表会自动滑动到顶部。 快速返回按钮我用的是Android Design中的FloatingActionButton,其实在FloatingActionButton中设置了默认的Behavior，但是这个默认的Behavior是与SnackBar结合使用的，因此我可以直接继承FloatingActionButton.Behavior复写其中的相关方法实现我们所要的效果，这样可以减少很多工作 123456789101112131415161718192021222324252627282930313233343536public class BackTopBehavior extends FloatingActionButton.Behavior &#123; private static final String TAG = \"BackTopBehavior\"; public BackTopBehavior(Context context, AttributeSet attrs) &#123; super(); &#125; @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) &#123; return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL;//垂直方向滑动 &#125; @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) &#123; if (dyConsumed &gt; 0 &amp;&amp; dyUnconsumed == 0) &#123; Log.d(TAG, \"上滑中。。。\"); &#125; if (dyConsumed == 0 &amp;&amp; dyUnconsumed &gt; 0) &#123; Log.d(TAG, \"到边界了还在上滑。。。\"); &#125; if (dyConsumed &lt; 0 &amp;&amp; dyUnconsumed == 0) &#123; Log.d(TAG, \"下滑中。。。\"); &#125; if (dyConsumed == 0 &amp;&amp; dyUnconsumed &lt; 0) &#123; Log.d(TAG, \"到边界了，还在下滑。。。\"); &#125; if((dyConsumed &gt; 0 &amp;&amp; dyUnconsumed == 0) || (dyConsumed == 0 &amp;&amp; dyUnconsumed &gt; 0) &amp;&amp; child.getVisibility() != View.VISIBLE) &#123; child.show();//上滑的时候显示按钮 &#125; else if((dyConsumed &lt; 0 &amp;&amp; dyUnconsumed == 0) || (dyConsumed == 0 &amp;&amp; dyUnconsumed &lt; 0) &amp;&amp; child.getVisibility() != View.GONE) &#123; child.hide();//下滑的时候因此按钮 &#125; &#125;&#125; 这样实现起来是不是感觉很简单，如果不用Behavior的话，需要自己自定义View，并对滑动事件进行处理，实现起来肯定比Behavior方式要费劲。 剩下的布局和Activity代码如下：123456789101112131415161718192021222324252627282930313233343536public class BackTopBehaviorActivity extends AppCompatActivity &#123; CommonRecyclerView mRecyclerView; LinearLayoutManager mLayoutManager; FloatingActionButton mFloatingActionButton; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_backtop_behavior); mFloatingActionButton = (FloatingActionButton) findViewById(R.id.floatingActionButton); mFloatingActionButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mLayoutManager.smoothScrollToPosition(mRecyclerView, null , 0); &#125; &#125;); initRecyclerView(); &#125; private void initRecyclerView() &#123; mRecyclerView = (CommonRecyclerView) findViewById(R.id.recyclerView); mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.addItemDecoration(new SpacesItemDecoration(5)); List&lt;String&gt; data = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 30; i ++) &#123; data.add(\"数据\" + (i + 1)); &#125; StringListAdapter mAdapter = new StringListAdapter(this, data); mRecyclerView.setAdapter(mAdapter); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" app:title=\"@string/app_name\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:titleTextColor=\"@android:color/white\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;cn.ittiger.demo.ui.CommonRecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" app:layout_collapseMode=\"pin\"/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/floatingActionButton\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/d_15\" android:src=\"@android:drawable/stat_sys_upload_done\" app:layout_behavior=\"cn.ittiger.demo.behavior.BackTopBehavior\" app:layout_scrollFlags=\"scroll|enterAlways|snap\" android:visibility=\"gone\"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Demo的完整代码戳这里","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Behavior","slug":"Behavior","permalink":"http://ittiger.cn/tags/Behavior/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"自定义实现微信通讯录效果View","slug":"Imitate-WeiXin-contact-view","date":"2016-12-30T04:01:04.000Z","updated":"2016-12-30T10:51:30.126Z","comments":true,"path":"Imitate-WeiXin-contact-view.html","link":"","permalink":"http://ittiger.cn/Imitate-WeiXin-contact-view.html","excerpt":"前言在使用App过程中，经常会有使用到联系人或城市列表的场景，其实这两种效果是一样的，都是右边有个索引列表，点击索引列表可跳转到指定字母开头的联系人或城市上去，同时向上滑动过程中头部会有个显示当前联系人首字母的界面固定不动。下面我以微信通讯录的效果作为例子，介绍我是如何实现一个这样效果自定义View的思路和过程。 实现效果下面是我实现的最终效果图(GIF录制的不太好)，想看源代码的同学戳这里https://github.com/huyongli/IndexStickyView","text":"前言在使用App过程中，经常会有使用到联系人或城市列表的场景，其实这两种效果是一样的，都是右边有个索引列表，点击索引列表可跳转到指定字母开头的联系人或城市上去，同时向上滑动过程中头部会有个显示当前联系人首字母的界面固定不动。下面我以微信通讯录的效果作为例子，介绍我是如何实现一个这样效果自定义View的思路和过程。 实现效果下面是我实现的最终效果图(GIF录制的不太好)，想看源代码的同学戳这里https://github.com/huyongli/IndexStickyView 思路分析既然要高仿实现微信通讯录的效果，那我们来先看看微信通讯录的效果 微信通讯录效果分析通过对微信通讯的效果进行分析之后，得出如下几点： 通讯录展示分为两部分： 主体：联系人列表 索引条：右边字母索引条 主体联系人列表又分为三部分： 联系人姓名和头像展示 根据联系人姓名的首字母进行分组，每组开头都会显示组名称(首字母)，并按字母顺序排序 列表开头的四个菜单，可以看成是一个特殊组数据，但是无组名称展示 索引条中的内容与联系人列表中的所有组字母一样，同时点击索引条中的字母会将列表定位到当前字母所代表的联系人组，因此索引条的每个字母会与该字母所代表联系人组的位置有个一一对应关系 点击索引条中的↑会定位到列表头部的四个菜单上，因此可以将↑与四个菜单作为一组对应关系，只是该菜单组无组名称 点击索引条的某个字母时，列表中间会有该字母的提示显示 列表向上滑动时当前组的组名称固定在列表头部显示不动，直到下一组组名称滑动到顶部时，原来固定不动的组名称视图开始往上滑出，下一组组名称顶替上去 实现思路分析 既然要展示联系人列表，所以我采用RecyclerView 滑动过程中顶部会有个视图固定不动，而RecyclerView滑动时不可能有子视图固定不动，因此我采用一个独立的视图View来作为这个固定不动的顶部视图显示组名称，在滑动过程中控制该View的显示和隐藏及其内容的变化，显然这个时候就需要父视图将RecyclerView和这个头部视图View包装起来 索引条因为是一个字母索引列表，因此我采用自定义View来绘制这些字母，在绘制过程中每个字母在索引条中要水平居中，而当列表头部有固定显示某个组名称(字母)时，索引条中对应的字母会有一个红色的圆作为该字母的背景，同时字母在圆中居中显示 点击索引条的字母时，列表中间出现的字母提示也采用一个独立的View显示，并将该View放到与RecyclerView所处的同一父视图。 索引条中的每个字母都需要与列表中对应组所在的位置索引有个一一对应的关系 因为微信通讯录中顶部的四个菜单与其他联系人具有不同的行为和展示方式，因此最终实现的View需要支持自定义显示不同的头部视图及对应的索引字母 实现细节下面我介绍下我在实现过程中的一些要点 数据处理用户数据一般应用在实现过程中，拿到的只有具体的联系人数据，而没有联系人对应的首字母，如果说我们自定义的View需要开发者将联系人对应的首字母也传进来，那这个自定义View写的也太lower了，对开发者太不友好了。因此我们最终实现的View所需要的数据就是开发者能拿到的联系人数据即可，这样的话就需要我们在实现View的过程中将开发者传递过来的联系人数据进行处理，然后得到我们在RecyclerView中展示的实际数据(联系人+字母索引)。 既然要对联系人数据进行处理得到该联系人的首字母，所以我定义了一个实体接口，所有的联系人数据实体必须实现这个接口以便告知我们需要对那个数据字段进行处理得到其索引首字母，具体接口如下：1234567public interface BaseEntity &#123; /** * 要索引的字段数据信息，例如联系人中对姓名进行索引，则此处返回姓名字段值 * @return */ String getIndexField();&#125; 展示数据列表在展示过程中有两种类型数据，一种是联系人数据，一种是联系人所在组的组名称(索引值)，所以最终在RecyclerView中进行展示时使用用户数据实体BaseEntity是无法达到这种展示效果的，因此我定义了一个RecyclerView实际展示数据的实体类，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class IndexStickyEntity&lt;T&gt; &#123; /** * 当前数据项的类型，自动转换赋值 */ private int mItemType = ItemType.ITEM_TYPE_CONTENT; /** * 当前数据的索引值，自动转换赋值(索引条中显示的文字) */ private String mIndexValue; /** * 索引视图显示的索引名称（组名称） */ private String mIndexName; /** * 原始数据，用户实际展示的数据,用于视图的绑定 * 当次值为null时，则表示此实体代表一个Index数据 * T extends BaseEntity */ private T mOriginalData; /** * 当前数据项的拼音 */ private String mPinYin; ... setter &amp; getter&#125;public class ItemType &#123; /** * 列表中普通数据项类型，例如联系人列表中的：联系人信息项 */ public static final int ITEM_TYPE_CONTENT = 1000000; /** * 列表中索引项类型，例如联系人列表中的：A,B,C...等索引数据 */ public static final int ITEM_TYPE_INDEX = 2000000; /** * 列表中增加头部索引数据(如自定义的常用联系人) */ public static final int ITEM_TYPE_INDEX_HEADER = 3000000; /** * 列表中增加底部索引数据 */ public static final int ITEM_TYPE_INDEX_FOOTER = 4000000;&#125; 用户数据 –&gt;展示数据在拿到用户的联系人数据后，进行转换处理得到真实展示数据，实现如下，代码中注释比较清晰，就不一一解释其实现逻辑了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class ConvertHelper &#123; /** * 转换过程中，如果待索引字段信息为非字母串，则将其索引值设为：# */ public static final String INDEX_SPECIAL = \"#\"; public static class ConvertResult&lt;T&gt; &#123; //转换后得到的实际展示数据列表，包括联系人数据+组名称数据(索引名称) private List&lt;IndexStickyEntity&lt;T&gt;&gt; mIndexStickyEntities = new ArrayList&lt;&gt;(); //索引条中展示的数据列表 private List&lt;String&gt; mIndexValueList = new ArrayList&lt;&gt;(); //索引条中展示数据与对应组在列表中位置索引的一一映射 private Map&lt;String, Integer&gt; mIndexValuePositionMap = new HashMap&lt;&gt;(); public List&lt;IndexStickyEntity&lt;T&gt;&gt; getIndexStickyEntities() &#123; return mIndexStickyEntities; &#125; public List&lt;String&gt; getIndexValueList() &#123; return mIndexValueList; &#125; public Map&lt;String, Integer&gt; getIndexValuePositionMap() &#123; return mIndexValuePositionMap; &#125; &#125; //拿到数据后调用此方法进行数据转换处理 public static &lt;T extends BaseEntity&gt; ConvertResult&lt;T&gt; transfer(List&lt;T&gt; list) &#123; ConvertResult&lt;T&gt; convertResult = new ConvertResult&lt;T&gt;(); //使用TreeMap自动按照Key(字母索引值)进行排序 TreeMap&lt;String, List&lt;IndexStickyEntity&lt;T&gt;&gt;&gt; treeMap = new TreeMap&lt;&gt;(ComparatorFactory.indexValueComparator()); for(int i = 0; i &lt; list.size(); i++) &#123; IndexStickyEntity&lt;T&gt; entity = originalEntityToIndexEntity(list.get(i)); if(treeMap.containsKey(entity.getIndexValue())) &#123;//Map中已存在此索引值 treeMap.get(entity.getIndexValue()).add(entity); &#125; else &#123; List&lt;IndexStickyEntity&lt;T&gt;&gt; indexStickyEntities = new ArrayList&lt;&gt;(); indexStickyEntities.add(entity); treeMap.put(entity.getIndexValue(), indexStickyEntities); &#125; &#125; for(String indexValue : treeMap.keySet()) &#123; //创建组名称展示数据实体 IndexStickyEntity&lt;T&gt; indexValueEntity = createIndexEntity(indexValue, indexValue); //将索引值添加到索引值列表中 convertResult.getIndexValueList().add(indexValue); //按顺序将索引实体添加到列表中 convertResult.getIndexStickyEntities().add(indexValueEntity); //将索引值与索引值在结果列表中的位置进行映射 convertResult.getIndexValuePositionMap().put(indexValue, convertResult.getIndexStickyEntities().size() - 1); //得到当前索引值下的索引数据实体 List&lt;IndexStickyEntity&lt;T&gt;&gt; indexStickyEntities = treeMap.get(indexValue); //对数据实体按自然进行排序 Collections.sort(indexStickyEntities, ComparatorFactory.&lt;T&gt;indexEntityComparator()); //将排序后的实体列表按顺序加入到结果列表中 convertResult.getIndexStickyEntities().addAll(indexStickyEntities); &#125; return convertResult; &#125; /** * 原始数据转换成展示的索引数据 * @param originalEntity * @param &lt;T&gt; * @return */ public static &lt;T extends BaseEntity&gt; IndexStickyEntity&lt;T&gt; originalEntityToIndexEntity(T originalEntity) &#123; IndexStickyEntity&lt;T&gt; entity = new IndexStickyEntity&lt;&gt;(); T item = originalEntity; String indexFieldName = item.getIndexField(); String pinyin = PinYinHelper.getPingYin(indexFieldName); String indexValue; if(PinYinHelper.isLetter(pinyin)) &#123;//首字符是否为字母 indexValue = pinyin.substring(0, 1).toUpperCase(); &#125; else &#123;//非字母以#代替 indexValue = INDEX_SPECIAL; &#125; entity.setPinYin(pinyin); entity.setOriginalData(item); entity.setIndexValue(indexValue); entity.setIndexName(indexValue); return entity; &#125; /** * 根据索引值创建索引实体对象 * @param indexValue * @param &lt;T&gt; * @return */ public static &lt;T extends BaseEntity&gt; IndexStickyEntity&lt;T&gt; createIndexEntity(String indexValue, String indexName) &#123; //根据索引值创建索引实体对象 IndexStickyEntity&lt;T&gt; indexValueEntity = new IndexStickyEntity&lt;&gt;(); indexValueEntity.setIndexValue(indexValue); indexValueEntity.setPinYin(indexValue); indexValueEntity.setIndexName(indexName); indexValueEntity.setItemType(ItemType.ITEM_TYPE_INDEX); return indexValueEntity; &#125;&#125; SideBar实现SideBar绘制 初始化SideBar相关绘制参数 根据索引列表计算SideBar的实际高度，并得到SideBar的最终高度 根据SideBar高度计算其每项的高度 绘制所有的索引值到视图上，并根据选中情况绘制当前选项的圆形背景 关键代码如下：123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int height = MeasureSpec.getSize(heightMeasureSpec); if (mValueList.size() &gt; 0) &#123; //计算SideBar的实际高度 mCalViewHeight = (int) (((mValueList.size() - 1) * mTextPaint.getTextSize() + mFocusTextPaint.getTextSize()) + (mValueList.size() + 1) * mTextSpace); &#125; if (mCalViewHeight &gt; height) &#123;//实际高度超过可用高度 mCalViewHeight = height; &#125; super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(mCalViewHeight, MeasureSpec.EXACTLY));&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); if(mValueList.size() == 0) &#123; return; &#125; //计算每项的高度 mItemHeight = ((float) getHeight()) / mValueList.size(); float radius = Math.min(getWidth() / 2, mItemHeight / 2);//选中状态时圆形背景半径 for(int i = 0; i &lt; mValueList.size(); i++) &#123; if(mSelectPosition == i) &#123; //计算文本垂直居中的基准线 float baseline = mItemHeight / 2 + (mFocusTextPaint.getFontMetrics().descent - mFocusTextPaint.getFontMetrics().ascent) / 2 - mFocusTextPaint.getFontMetrics().descent; canvas.drawCircle(getWidth() / 2, mItemHeight / 2 + mItemHeight * i, radius, mFocusTextBgPaint); canvas.drawText(mValueList.get(i), getWidth() / 2, baseline + mItemHeight * i, mFocusTextPaint); &#125; else &#123; float baseline = mItemHeight / 2 + (mTextPaint.getFontMetrics().descent - mTextPaint.getFontMetrics().ascent) / 2 - mTextPaint.getFontMetrics().descent; canvas.drawText(mValueList.get(i), getWidth() / 2, baseline + mItemHeight * i, mTextPaint); &#125; &#125;&#125; 点击SideBar选中SideBar绘制成功后，在使用过程中还有一个重要的场景需要实现，那就是我们点击SideBar的时候要知道我们当前点击的是SideBar中的哪个选项，具体实现思路是这样的：根据当前触摸的y坐标(其实是相对于视图坐标系)和每个选项的高度计算当前触摸点在哪个选项内，具体实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic boolean onTouch(View v, MotionEvent event) &#123; int touchPosition = getPositionForPointY(event.getY()); if(touchPosition &lt; 0 || touchPosition &gt;= mValueList.size()) &#123; return true; &#125; if(mOnSideBarTouchListener != null) &#123; //此接口监听主要用于列表跳转到对应的组 mOnSideBarTouchListener.onSideBarTouch(v, event, touchPosition); &#125; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: if(touchPosition != mSelectPosition) &#123; setSelectPosition(touchPosition);//设置选中 &#125; break; &#125; return true;&#125;/** * 根据点击的y坐标计算得到当前选中的是哪个选项 * @param pointY * @return 没选中则返回-1 */private int getPositionForPointY(float pointY) &#123; if(mValueList.size() &lt;= 0) &#123; return -1; &#125; //根据手按下的纵坐标与每个选项的高度计算当前所在项的索引 int position = (int) (pointY / mItemHeight); if(position &lt; 0) &#123; position = 0; &#125; else if(position &gt; mValueList.size() - 1) &#123; position = mValueList.size() - 1; &#125; return position;&#125; 点击SideBar某项时跳转列表到对应组1234567891011121314151617@Overridepublic void onSideBarTouch(View v, MotionEvent event, int touchPosition) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: if(touchPosition != mSideBar.getSelectPosition()) &#123; if(touchPosition == 0) &#123; mLinearLayoutManager.scrollToPosition(0); &#125; else &#123; int recyclerViewPosition = getScrollPositionBySideBarSelectPosition(touchPosition); mLinearLayoutManager.scrollToPositionWithOffset(recyclerViewPosition, 0); &#125; &#125; break; &#125;&#125; 固定头部视图处理头部显示逻辑 因为固定不动的头部视图(暂且叫做mStickyHeaderView其视图实现与组名称视图完全一样)是在RecyclerView的上面，所以当其显示时会遮盖掉RecyclerView的第一个可见项。——这个点很重要 获取RecyclerView的第一个可见项的实体数据IndexStickyEntity 如果当前数据的组名称为空，则不显示头部视图mStickyHeaderView，要注意的是前面我在转换数据的时候会给所有普通联系人实体对象都会设置组名称(如果存在) 如果当前数据的组名称不为空，则显示头部视图mStickyHeaderView并同时更新其显示内容 滚动过程中获取RecyclerView列表中的第二个可见项的实体数据IndexStickyEntity，比如叫做：secondVisibleEntity 如果secondVisibleEntity.getItemType() == ItemType.ITEM_TYPE_INDEX,即为组名称视图(索引视图)，此时说明第二组数据已经滚动上来了，需要将固定在头部的mStickyHeaderView视图随着滚动操作慢慢的滑出界面变成不可见，同时secondVisibleEntity则会慢慢滚动到mStickyHeaderView原来所在的位置，此时在界面上看着就像是第二组的组名称视图慢慢的替换了固定在顶部的mStickyHeaderView 如果secondVisibleEntity.getItemType() != ItemType.ITEM_TYPE_INDEX则需要将mStickyHeaderView恢复到初始位置。因为当secondVisibleEntity滚动到mStickyHeaderView原来所在的位置后，此时第一个可见项变成了secondVisibleEntity，而此时的第二个可见项则变成了普通的联系人视图比如叫mContactView，而此时列表还会继续往上滚动，随着滚动secondVisibleEntity会慢慢的变成不可见，而mStickyHeaderView已经滑出界面不可见了，所以当secondVisibleEntity.getItemType() != ItemType.ITEM_TYPE_INDEX则需要将mStickyHeaderView恢复到初始位置显示新的组名称。 列表滚动过程中还需要根据第一个可见项的索引值更新索引条SideBar的选中项 滚动时头部显示逻辑实现12345678910111213141516171819202122232425262728293031323334353637383940class RecyclerViewScrollListener extends RecyclerView.OnScrollListener &#123; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); int firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition(); if(firstVisiblePosition &lt; 0 || firstVisiblePosition &gt;= mAdapter.getItemCount()) &#123; return; &#125; IndexStickyEntity entity = mAdapter.getItem(firstVisiblePosition); mSideBar.setSelectPosition(mSideBar.getPosition(entity.getIndexValue())); if(TextUtils.isEmpty(entity.getIndexName()) &amp;&amp; mStickyHeaderView.itemView.getVisibility() == VISIBLE) &#123; //如果当前第一个可见项的索引值为空，则当前项可能是普通视图，非索引视图，因此此时需要将mStickyHeaderView进行隐藏 mStickyIndexValue = null; mStickyHeaderView.itemView.setVisibility(INVISIBLE); &#125; else &#123;//第一个可见项为索引视图，则需要显示头部固定的索引提示视图 showStickyHeaderView(entity.getIndexName(), firstVisiblePosition); &#125; if(firstVisiblePosition + 1 &gt;= mAdapter.getItemCount()) &#123; return; &#125; //获取第二个可见项实体对象 IndexStickyEntity secondVisibleEntity = mAdapter.getItem(firstVisiblePosition + 1); if(secondVisibleEntity.getItemType() == ItemType.ITEM_TYPE_INDEX) &#123; //第二个可见项是索引值视图 View secondVisibleItemView = mLinearLayoutManager.findViewByPosition(firstVisiblePosition + 1); if(secondVisibleItemView.getTop() &lt;= mStickyHeaderView.itemView.getHeight() &amp;&amp; mStickyIndexValue != null) &#123; //当secondVisibleItemView距顶部的距离 &lt;= mStickyHeaderView的高度时，mStickyHeaderView开始往上滑出 mStickyHeaderView.itemView.setTranslationY(secondVisibleItemView.getTop() - mStickyHeaderView.itemView.getHeight()); &#125; &#125; else &#123; //第二个可见项不是索引值视图 if(mStickyHeaderView.itemView.getTranslationY() != 0) &#123;//有偏移 mStickyHeaderView.itemView.setTranslationY(0); &#125; &#125; &#125;&#125; 以上是我在模仿微信通讯录实现过程中的实现思路和关键点代码，具体实现细节和使用方式请看码：https://github.com/huyongli/IndexStickyView 喜欢的同学欢迎Star和fork write by laohu2016年12月30日","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"IndexStickyView","slug":"IndexStickyView","permalink":"http://ittiger.cn/tags/IndexStickyView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android资源应用与适配标准","slug":"Android-resources-adapter","date":"2016-11-19T07:28:31.000Z","updated":"2017-02-28T03:04:29.522Z","comments":true,"path":"Android-resources-adapter.html","link":"","permalink":"http://ittiger.cn/Android-resources-adapter.html","excerpt":"本文内容来自Android官网对Android开发过程中资源使用、资源适配、资源选择原理的介绍和建议。","text":"本文内容来自Android官网对Android开发过程中资源使用、资源适配、资源选择原理的介绍和建议。 Android资源类型Android项目结构一个Android项目有多重资源类型，我们一般都会将各种资源放入项目 res/目录的特定子目录下。例如，以下是一个简单项目的文件层次结构： 正如我们在此示例中所看到的那样，res/目录包含所有资源（在子目录下）：一个图像资源、两个布局资源、启动器图标的 mipmap/ 目录以及一个字符串资源文件。资源目录名称非常重要，将在表 1 中进行介绍。 注：如需了解有关使用 mipmap文件夹的详细信息，请参阅管理项目概览。 Android支持的资源类型表 1. 项目 res/ 目录内支持的资源目录。 目录 资源类型 animator/ 用于定义属性动画的 XML文件。 anim/ 定义渐变动画的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 animator/ 目录。） color/ 用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源 drawable/ 位图文件（.png、.9.png、.jpg、.gif）或编译为以下可绘制对象资源子类型的 XML 文件：位图文件九宫格（9-Patch）状态列表形状动画可绘制对象其他可绘制对象请参阅可绘制对象资源 mipmap/ 适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。 layout/ 用于定义用户界面布局的 XML 文件。请参阅布局资源 menu/ 用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML文件。请参阅菜单资源。 raw/ 要以原始形式保存的任意文件。要使用原始InputStream打开这些资源，请使用资源 ID（即 R.raw.&lt;em&gt;filename&lt;/em&gt;）调用 Resources.openRawResource())但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在assets/ 目录下（而不是 res/raw/）。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。 values/ 包含字符串、整型数和颜色等简单值的 XML 文件。其他 res/ 子目录中的 XML资源文件是根据XML文件名定义单个资源，而 values/ 目录中的文件可描述多个资源。对于此目录中的文件，&lt;resources&gt; 元素的每个子元素均定义一个资源。例如，&lt;string&gt; 元素创建R.string 资源，&lt;color&gt; 元素创建 R.color资源。由于每个资源均用其自己的 XML元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml，用于资源数组（类型化数组）。colors.xml：颜色值。dimens.xml：尺寸值。strings.xml：字符串值。styles.xml：样式请参阅字符串资源、样式资源和更多资源类型。 xml/ 可以在运行时通过调用 Resources.getXML()) 读取的任意 XML 文件。各种 XML配置文件（如可搜索配置）都必须保存在此处。 注意：切勿将资源文件直接保存在res/目录内，这会导致出现编译错误。 如需了解有关某些资源类型的详细信息，请参阅资源类型文档。 保存在表 1中定义的子目录下的资源是“默认”资源。即，这些资源定义应用的默认设计和内容。但是，采用Android技术的不同设备类型可能需要不同类型的资源。例如，如果设备的屏幕尺寸大于标准屏幕，则应提供不同的布局资源，以充分利用额外的屏幕空间。 或者，如果设备的语言设置不同，则应提供不同的字符串资源，以转换用户界面中的文本。 要为不同的设备配置提供这些不同资源，除了默认资源以外，您还需要提供备用资源。 为项目提供备用资源图 1. 两种不同的设备，均使用不同的布局资源。 几乎每个应用都应提供备用资源以支持特定的设备配置。 例如，对于不同的屏幕密度和语言，您应分别包括备用可绘制对象资源和备用字符串资源。 在运行时，Android会检测当前设备配置并为应用加载合适的资源。 为一组资源指定特定于配置的备用资源： 在 res/中创建一个以&lt;resources_name&gt;-&lt;config_qualifier&gt;形式命名的新目录。 &lt;resources_name&gt; 是相应默认资源的目录名称（如表 1中所定义）。 &lt;qualifier&gt; 是指定要使用这些资源的各个配置的名称（如表 2中所定义）。您可以追加多个 &lt;qualifier&gt;。以短划线将其分隔。 注意：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。 将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。 例如，以下是一些默认资源和备用资源： hdpi限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 icon.png 或background.png 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。 Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。 Android资源限定符表 2. 配置限定符名称。 配置 限定符值 说明 MCC 和 MNC 示例： mcc310 &lt;nobr&gt;mcc310-mnc004&lt;/nobr&gt; mcc208-mnc00等等 移动国家代码 (MCC)，（可选）后跟设备 SIM卡中的移动网络代码 (MNC)。例如，mcc310 是指美国的任一运营商，mcc310-mnc004 是指美国的 Verizon公司，mcc208-mnc00 是指法国的 Orange公司。如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM卡。也可以单独使用MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。如果决定使用 MCC 和MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。 另请参阅配置字段 mcc和 mnc，这两个字段分别表示当前的移动国家代码和移动网络代码。 语言和区域 示例：en fr en-rUS fr-rFR fr-rCA等等 语言通过由两个字母组成的 ISO639-1 语言代码定义，可以选择后跟两个字母组成的ISO3166-1-alpha-2 区域码（前带小写字母“r”）。这些代码不区分大小写；r前缀用于区分区域码。不能单独指定区域。如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。有关针对其他语言本地化应用的完整指南，请参阅本地化。另请参阅 locale 配置字段，该字段表示当前的语言区域。 布局方向 ldrtl ldltr 应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr是指“布局方向从左到右”，这是默认的隐式值。它适用于布局、图片或值等任何资源。例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：注：要为应用启用从右到左的布局功能，必须将supportsRtl 设置为 &quot;true&quot;，并将 targetSdkVersion 设置为 17 或更高版本。此项为 API 级别 17 中新增配置。 smallestWidth sw&lt;N&gt;dp 示例：sw320dpsw600dpsw20dp等等 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。具体来说，设备的 smallestWidth是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用UI 的可用宽度至少为&lt;N&gt;dp。例如，如果布局要求屏幕区域的最小尺寸始终至少为600dp，则可使用此限定符创建布局资源 res/layout-sw600dp/。仅当可用屏幕的最小尺寸至少为600dp 时，系统才会使用这些资源，而不考虑600dp所代表的边是用户所认为的高度还是宽度。smallestWidth是设备的固定屏幕尺寸特性；设备的 smallestWidth不会随屏幕方向的变化而改变。设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿smallestWidth轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。因此，使用的值应该是布局所需要的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。以下是一些可用于普通屏幕尺寸的值：320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备smallestWidth 的值。 此项为 API 级别 13 中新增配置。 另请参阅 android:requiresSmallestWidthDp 属性和 smallestScreenWidthDp 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用宽度 w&lt;N&gt;dp示例：w720dpw1024dp 等等 指定资源应该使用的最小可用屏幕宽度，以 dp为单位，由 &amp;lt;N&amp;gt; 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。br/&gt;应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI元素，考虑到这些 UI元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。此项为 API 级别 13 中新增配置。 另请参阅screenWidthDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用高度 h&lt;N&gt;dp 示例：h720dp h1024dp等等 指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 &lt;N&gt; 值定义。在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。此项为 API 级别 13 中新增配置。另请参阅screenHeightDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 屏幕尺寸 smallnormal large xlarge small：尺寸类似于低密度QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为320x426 dp 单位。例如，QVGA 低密度屏幕和WVGA高密度屏幕。normal：尺寸类似于中等密度HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为320x470 dp 单位。例如，WQVGA低密度屏幕、HVGA 中等密度屏幕、WVGA高密度屏幕。large：尺寸类似于中等密度WVGA 屏幕的屏幕。大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。xlarge：明显大于传统中等密度HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。API 级别 9 中的新增配置。注：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。此项为 API 级别 4 中新增配置。如需了解详细信息，请参阅支持多种屏幕。另请参阅 screenLayout 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。 屏幕纵横比 longnotlong long：宽屏，如 WQVGA、WVGA、FWVGAnotlong：非宽屏，如 QVGA、HVGA 和 VGA此项为 API 级别 4 中新增配置。它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。另请参阅 screenLayout 配置字段，该字段指示屏幕是否为宽屏。 圆形屏幕 roundnotround round：圆形屏幕，例如圆形可穿戴式设备notround：方形屏幕，例如手机或平板电脑此项为 API 级别 23 中新增配置。 另请参阅 isScreenRound()) 配置方法，其指示屏幕是否为宽屏。 屏幕方向 portland port：设备处于纵向（垂直）land：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅 orientation 配置字段，该字段指示当前的设备方向。 UI 模式 car desk television&lt;br/&gt;appliance`watch car：设备正在车载手机座上显示desk：设备正在桌面手机座上显示television：设备正在电视上显示，为用户提供“十英尺”体验，其UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互appliance：设备用作不带显示屏的装置watch：设备配有显示屏，戴在手腕上 此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。 如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读确定并监控插接状态和类型。如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。可以使用 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 夜间模式 night notnight night：夜间notnight：白天 此项为 API 级别 8 中新增配置。如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。可以使用UiModeManager 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 屏幕像素密度 (dpi) ldpimdpihdpixhdpixxhdpixxxhdpi nodpi tvdpianydpi ldpi：低密度屏幕；约为120dpi。mdpi：中等密度（传统 HVGA）屏幕；约为160dpi。hdpi：高密度屏幕；约为 240dpi。xhdpi：超高密度屏幕；约为 320dpi。此项为 API级别 8 中新增配置xxhdpi：超超高密度屏幕；约为 480dpi。此项为 API级别 16 中新增配置xxxhdpi：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的注释）；约为640dpi。此项为 API级别 18 中新增配置nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组，主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和hdpi资源便已足够，系统将根据需要对其进行缩放。此项为 API 级别 13 中新增配置anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。这对于矢量可绘制对象很有用。此项为 API 级别 21 中新增配置 六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。 如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为1.33*mdpi。例如，mdpi屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。 注：使用密度限定符并不表示资源仅适用于该密度的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中#BestMatch”&gt;最匹配的资源。如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅支持多种屏幕。 触摸屏类型 notouchfinger notouch：设备没有触摸屏。finger：设备有一个专供用户通过手指直接与其交互的触摸屏。 另请参阅 touchscreen 配置字段，该字段指示设备上的触摸屏类型。 键盘可用性 keysexposed keyshidden keyssoft keysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。keyssoft：设备已经启用软键盘（无论是否可见）。如果提供了 keysexposed 资源，但未提供 keyssoft资源，那么只要系统已经启用软键盘，就会使用keysexposed 资源，而不考虑键盘是否可见。如果用户打开硬键盘，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅配置字段 hardKeyboardHidden和keyboardHidden，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。 主要文本输入法 nokeysqwerty 12key nokeys：设备没有用于文本输入的硬按键。qwerty：设备具有标准硬键盘（无论是否对用户可见）。12key：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 keyboard 配置字段，该字段指示可用的主要文本输入法。 导航键可用性 navexposed navhidden navexposed：导航键可供用户使用。navhidden：导航键不可用（例如，位于密封盖子后面）。 如果用户显示导航键，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅navigationHidden 配置字段，该字段指示导航键是否处于隐藏状态。 主要非触摸导航方法 nonavdpad trackball wheel nonav：除了使用触摸屏以外，设备没有其他导航设施。dpad：设备具有用于导航的方向键。trackball：设备具有用于导航的轨迹球。wheel：设备具有用于导航的方向盘（不常见）。另请参阅 navigation配置字段，该字段指示可用的导航方法类型。 平台版本（API 级别） 示例：v3v4v7等等 设备支持的 API 级别。例如，v1 对应于 API 级别1（带有 Android 1.0 或更高版本系统的设备），v4 对应于 API 级别 4（带有 Android1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅Android API 级别文档。 注：有些配置限定符是从 Android 1.0 才开始添加，因此并非所有版本的Android系统都支持所有限定符。使用新限定符会隐式添加平台版本限定符，因此较旧版本系统的设备必然会忽略它。 例如，使用 w600dp 限定符会自动包括 v13 限定符，因为可用宽度限定符是 API 级别 13 中的新增配置。为了避免出现任何问题，请始终包含一组默认资源（一组“不带限定符”的资源）。 如需了解详细信息，请参阅利用资源提供最佳设备兼容性部分 限定符命名规则以下是一些关于使用配置限定符名称的规则： 您可以为单组资源指定多个限定符，并使用短划线分隔。例如，drawable-en-rUS-land 适用于横排美国英语设备。 这些限定符必须遵循表 2 中列出的顺序。例如： 错误：drawable-hdpi-port/ 正确：drawable-port-hdpi/ 不能嵌套备用资源目录。例如，您不能拥有 res/drawable/drawable-en/。 值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。 对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为drawable-rES-rFR/ 的目录，而是需要两个包含相应文件的资源目录，如 drawable-rES/ 和 drawable-rFR/。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的创建别名资源。 将备用资源保存到以这些限定符命名的目录中之后，Android 会根据当前设备配置在应用中自动应用这些资源。 每次请求资源时，Android 都会检查备用资源目录是否包含所请求的资源文件，然后找到最匹配资源（下文进行介绍）。 如果没有与特定设备配置匹配的备用资源，则 Android 会使用相应的默认资源（一组用于不含配置限定符的特定资源类型的资源） 创建别名资源如果您想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 相反，您可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。 注：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，xml/ 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。 例如，假设您有一个应用图标 icon.png，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，您可以将用于二者的图像另存为icon_ca.png（除 icon.png 以外的任何名称），并将其放入默认res/drawable/目录中。然后，在res/drawable-en-rCA/ 和 res/drawable-fr-rCA/ 中创建icon.xml文件，使用 &lt;bitmap&gt; 元素引用 icon_ca.png资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。） 可绘制对象要创建指向现有可绘制对象的别名，请使用&lt;bitmap&gt;元素。例如：123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\" android:src=\"@drawable/icon_ca\" /&gt; 如果将此文件另存为icon.xml（例如，在备用资源目录中，另存为res/drawable-en-rCA/），则会编译到可作为 R.drawable.icon 引用的资源中，但实际上它是 R.drawable.icon_ca资源（保存在res/drawable/中）的别名。 布局要创建指向现有布局的别名，请使用包装在&lt;merge&gt;中的&lt;include&gt;元素。例如：1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge&gt; &lt;include layout=\"@layout/main_ltr\"/&gt;&lt;/merge&gt; 如果将此文件另存为 main.xml，则会编译到可作为 R.layout.main 引用的资源中，但实际上它是 R.layout.main_ltr 资源的别名。 字符串和其他简单值要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如：12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string name=\"hello\"&gt;Hello&lt;/string&gt; &lt;string name=\"hi\"&gt;@string/hello&lt;/string&gt;&lt;/resources&gt; R.string.hi资源现在是 R.string.hello的别名。 其他简单值的原理相同。 例如，颜色：12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;color name=\"red\"&gt;#f00&lt;/color&gt; &lt;color name=\"highlight\"&gt;@color/red&lt;/color&gt;&lt;/resources&gt; 利用资源提供最佳设备兼容性要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。 例如，如果应用支持多种语言，请始终包含不带语言和区域限定符的 values/ 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 values/ 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。 同样，如果您根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 layout-land/ 和 layout-port/ 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：layout/ 用于横向，layout-port/ 用于纵向。 提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 minSdkVersion 设置为 4，并使用夜间模式（night 或 notnight，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于drawable/ 或 drawable-night/ 中。 因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。 这条规则有一个例外：如果应用的 minSdkVersion 为 4 或更高版本，则在提供带屏幕密度限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。 Android 如何找到最匹配资源当您请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本：1234567drawable/drawable-en/drawable-fr-rCA/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 同时，假设设备配置如下：12345语言区域 = en-GB 屏幕方向 = port 屏幕像素密度 = hdpi 触摸屏类型 = notouch 主要文本输入法 = 12key 通过将设备配置与可用的备用资源进行比较，Android 从 drawable-en-port 中选择可绘制对象。 系统使用以下逻辑决定要使用的资源： 淘汰与设备配置冲突的资源文件。 drawable-fr-rCA/ 目录与en-GB语言区域冲突，因而被淘汰。 1234567drawable/drawable-en/drawable-fr-rCA/ ---&gt;//被淘汰drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 例外：屏幕像素密度是唯一一个未因冲突而被淘汰的限定符。 尽管设备的屏幕密度为 hdpi，但是 drawable-port-ldpi/ 未被淘汰，因为此时每个屏幕密度均视为匹配。如需了解详细信息，请参阅支持多种屏幕文档。 选择列表（表 2）中（下一个）优先级最高的限定符。（先从 MCC开始，然后下移。） 是否有资源目录包括此限定符？ 若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。） 若有，请继续执行第 4 步。 淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。 123456 drawable/ ---&gt;//被淘汰drawable-en/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/ ---&gt;//被淘汰drawable-port-notouch-12key/ ---&gt;//被淘汰 例外：如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅支持多种屏幕。 返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰： 123 drawable-en/ ---&gt;//被淘汰drawable-en-port/drawable-en-notouch-12key/ ---&gt;//被淘汰 剩下的目录是drawable-en-port。 尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。 根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 注：限定符的优先顺序（表 2 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 drawable-en 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此drawable-port-notouch-12key 被淘汰。 write by laohu2016年11月19日","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"资源适配","slug":"资源适配","permalink":"http://ittiger.cn/tags/资源适配/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android基础之9-Patch(9.PNG)与padding","slug":"Nine-Patch-Affect-Padding-Principle","date":"2016-11-18T04:30:00.000Z","updated":"2017-02-28T03:04:29.631Z","comments":true,"path":"Nine-Patch-Affect-Padding-Principle.html","link":"","permalink":"http://ittiger.cn/Nine-Patch-Affect-Padding-Principle.html","excerpt":"在上一篇文章记一次9.png的填坑之旅最后，我留了两个个问题： 为什么使用9.PNG设置背景之后会改变控件的padding属性值 在我所遇到的问题中9.PNG明明改变的是padding值为什么却产生了margin的效果 这篇文章就来解答这两个问题以及9.PNG使用过程中需要注意的地方。 各位同学如果没看过记一次9.png的填坑之旅这篇文章可以先去看看，因为我下面所讲的内容都是根据这篇文章中的问题来讲的。","text":"在上一篇文章记一次9.png的填坑之旅最后，我留了两个个问题： 为什么使用9.PNG设置背景之后会改变控件的padding属性值 在我所遇到的问题中9.PNG明明改变的是padding值为什么却产生了margin的效果 这篇文章就来解答这两个问题以及9.PNG使用过程中需要注意的地方。 各位同学如果没看过记一次9.png的填坑之旅这篇文章可以先去看看，因为我下面所讲的内容都是根据这篇文章中的问题来讲的。 问题9-Patch图还是先来看下我所使用的9.PNG的图从图中可以看出中间那一片白色区域是内容区，而内容区到底部的黑边线之间还一段透明的区域，这段区域是不会显示内容的。 结论猜想看到这个透明区域联想到我上面遇到的问题 明明改变的是padding却产生了margin的效果 大家是不是会出现一个猜想，难道上篇文章中padding改变却出现margin效果是因为这个透明的区域导致的？ 恭喜你，答对了，我前面遇到的问题中padding改变却产生margin效果就是因为这个透明区域导致的。 你可能又要接着问了，这是为什么呢？ 不要走开，下面我就来说说其中的原因。 一探setBackgroundResource我们来看看布局设置背景图片的方法setBackgroundResource(int resid)是如何实现的1234567891011 public void setBackgroundResource(int resid) &#123; if (resid != 0 &amp;&amp; resid == mBackgroundResource) &#123; return; &#125; Drawable d = null; if (resid != 0) &#123; d = mContext.getDrawable(resid); &#125; setBackground(d); mBackgroundResource = resid;&#125; 上面的代码可以看到调用了setBackground(Drawable drawable)这个方法，我们接着看123public void setBackground(Drawable background) &#123; setBackgroundDrawable(background);&#125; 我们接着看setBackgroundDrawable(Drawable drawable)这个方法的实现123456789101112131415161718192021222324252627282930313233public void setBackgroundDrawable(Drawable background) &#123; ... if (background != null) &#123; Rect padding = sThreadLocal.get(); if (padding == null) &#123; padding = new Rect(); sThreadLocal.set(padding); &#125; resetResolvedDrawables(); background.setLayoutDirection(getLayoutDirection()); if (background.getPadding(padding)) &#123; resetResolvedPadding(); switch (background.getLayoutDirection()) &#123; case LAYOUT_DIRECTION_RTL: mUserPaddingLeftInitial = padding.right; mUserPaddingRightInitial = padding.left; internalSetPadding(padding.right, padding.top, padding.left, padding.bottom); break; case LAYOUT_DIRECTION_LTR: default: mUserPaddingLeftInitial = padding.left; mUserPaddingRightInitial = padding.right; internalSetPadding(padding.left, padding.top, padding.right, padding.bottom); &#125; mLeftPaddingDefined = false; mRightPaddingDefined = false; &#125; ... &#125; else &#123; ... &#125; ...&#125; 上面的代码很明显可以看到当background.getPadding(padding)返回true的时候当前布局视图会通过internalSetPadding(padding.left, padding.top, padding.right, padding.bottom)给当前视图设置相应的padding值 NinePatchDrawable因为我们使用的是9-Patch，所以生成的Drawable对象是NinePatchDrawable实例，我们接着上面的源码流程继续查看NinePatchDrawable.getPadding(Rect padding)方法：12345678910111213public boolean getPadding(Rect padding) &#123; final Rect scaledPadding = mPadding; if (scaledPadding != null) &#123; if (needsMirroring()) &#123; padding.set(scaledPadding.right, scaledPadding.top, scaledPadding.left, scaledPadding.bottom); &#125; else &#123; padding.set(scaledPadding); &#125; return (padding.left | padding.top | padding.right | padding.bottom) != 0; &#125; return false;&#125; 上面的方法很明显可以看出，如果当前9-Patch图存在Padding值的话，它会将该值设置到参数Rect中，而在前面setBackgroundDrawable(Drawable drawable)方法实现中方法internalSetPadding(padding.left, padding.top, padding.right, padding.bottom)里所传的参数padding就是这个地方的Rect参数实例。 结论总结成一句话就是如果我们使用的9-Patch图生成的NinePatchDrawable对象存在Padding值，那么这些Padding值将会同时设置给使用该9-Patch作为背景图的View的Padding属性上 看了上面的结论，大家可能又会有一个疑问？？？ 我们使用的9-Patch图时，系统为我们生成NinePatchDrawable对象时产生的Padding是根据什么依据得来的呢？ 9-Patch官方定义OK，我们来看看Google官方对9-Patch图的定义和介绍https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch The border is used to define the stretchable and static areas of the image. You indicate a stretchable section by drawing one (or more) 1-pixel-wide black line(s) in the left and top part of the border (the other border pixels should be fully transparent or white). You can have as many stretchable sections as you want: their relative size stays the same, so the largest sections always remain the largest. You can also define an optional drawable section of the image (effectively, the padding lines) by drawing a line on the right and bottom lines. If a View object sets the NinePatch as its background and then specifies the View’s text, it will stretch itself so that all the text fits inside only the area designated by the right and bottom lines (if included). If the padding lines are not included, Android uses the left and top lines to define this drawable area. To clarify the difference between the different lines, the left and top lines define which pixels of the image are allowed to be replicated in order to stretch the image. The bottom and right lines define the relative area within the image that the contents of the View are allowed to lie within This NinePatch defines one stretchable area with the left and top lines and the drawable area with the bottom and right lines. In the top image, the dotted grey lines identify the regions of the image that will be replicated in order to stretch the image. The pink rectangle in the bottom image identifies the region in which the contents of the View are allowed. If the contents don’t fit in this region, then the image will be stretched so that they do. 上面这段几段文字是我引用的Android官方的介绍说明，里面介绍了9-Patch图的使用方式和要点。 9-Patch图Padding的由来大家注意看段落中我标红的那一句话，这句话就是说：如果你使用9-Patch图给某个View设置background之后，这个View的所有内容仅仅适配显示在内容区域里，而内容区域范围是由9-Patch图right and bottom lines决定的。而9-Patch图内容区以外的部分是不可能无故消失的，所以就作为其Padding了，因此在我们使用9-Patch图作为背景图时，系统为我们生成的NinePatchDrawable对象的Padding值就是根据这得来的。 回归问题知道上面的结论之后，我们再回过头来看我所遇到的问题，我们再看一遍我所使用的9-Patch图根据上面的结论可以发现这个图底部有一块透明的非内容区，因此我所使用的这个9-Patch图会产生一个paddingBottom值，而刚好这块区域又是透明，所以在使用的时候这块区域在视图上其实也是透明的，因此这块透明区域看到的效果其实是其父容器视图的内容，所以就造成了margin的效果。 讲到这里，我所遇到的那个问题就得到了完美的解答。 另外大家在使用9-Patch图的时候一定要注意其内容区域，如果9-Patch图制作不合适会产生一些莫名其妙的布局问题。 write by laohu2016年11月18日","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"9.png","slug":"9-png","permalink":"http://ittiger.cn/tags/9-png/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"TextView之SpannableStringBuilder使用总结","slug":"TextView-SpannableStringBuilder-usage-summary","date":"2016-11-05T12:11:52.000Z","updated":"2016-11-07T10:07:51.073Z","comments":true,"path":"TextView-SpannableStringBuilder-usage-summary.html","link":"","permalink":"http://ittiger.cn/TextView-SpannableStringBuilder-usage-summary.html","excerpt":"最近项目中碰到一个TextView的显示问题，想了各种办法之后，最后还是用SpannableStringBuilder解决的。这篇文章就记录下我的问题的解决过程，同时总结下SpannableStringBuilder在TextView中的不同用法。","text":"最近项目中碰到一个TextView的显示问题，想了各种办法之后，最后还是用SpannableStringBuilder解决的。这篇文章就记录下我的问题的解决过程，同时总结下SpannableStringBuilder在TextView中的不同用法。 背景项目中GridView有两列，每个Item视图都有一个TextView(设置了最大显示行数)，项目业务要求每列的TextView展示高度相同，但是因为显示的文本你不知道有多少行，所以在布局的时候不能设置固定高度，而是设置为wrap_content，所以为了保证两列的TextView高度一致，只需要保证他们展示内容的行数一致就行。 而上面的问题只需要在内容行数达不到最大显示行数时，为其手动补齐行数即可。 这里有个问题就是如何计算当前要展示的文本在此TextView中能展示多少行，这个地方直接通过textView.getLineCount()是不行的，我是通过StaticLayout计算当前文本能显示的行数，对于StaticLayout的使用这篇文章就不介绍了，不会的同学可以去google下，后面的文章我会专门介绍StaticLayout的使用 有了上面的解决方法之后，我在行数不足时我手动添加了换行符\\n补齐行数，但是运行之后，发现达不到效果，因为虽然手动换行，但是通过换行符\\n换行之后的高度达不到实际文本行显示的高度，因此这种方式还是没法保证两边TextView高度一致。 既然单纯的换行无法达到我们想要的效果，那我就在换行之后再添加几个文字，有了这几个文字就可以让其真正达到多行文本的效果了。但是多的这几个字会显示在界面上，所以我们只需要让这几个文字不显示出来或者让这几个文字完全透明即可。 将TextView的部分文本设置为透明色，最后查询之后发现SpannableStringBuilder可以实现这样的效果，下面我就总结下SpannableStringBuilder结合TextView的使用方法。 SpannableStringBuilder使用总结我们来看下SpannableStringBuilder的官方介绍 This is the class for text whose content and markup can both be changed 通过上面的介绍可以看出SpannableStringBuilder是一个内容和标记都可以更改的类，它其实是CharSequence的子类。 SpannableStringBuilder使用效果 文本高亮使用ForegroundColorSpan为TextView的部分文本添加指定颜色，使这部分文本高亮显示123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//高亮的开始位置builder.append(\"文本高亮\");int end = builder.length();//高亮的结束位置builder.setSpan(new ForegroundColorSpan(Color.RED), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); ForegroundColorSpan代表设置文本高亮的颜色 Spanned.SPAN_INCLUSIVE_EXCLUSIVE这个常量表示高亮开始位置但不包含结束位置的字符，还有几个类似的常量，这几个常量与Stirng.subString()方法的参数代表的意思是类似的。 上面我的解决办法中需要文本完全透明，只需要将高亮的颜色设置为100%透明即可 URL超链接效果使用URLSpan为TextView的部分文本添加超链接效果1234567891011121314SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//URL文本开始位置builder.append(\"URL连接\");int end = builder.length();//URL文本结束位置builder.setSpan(new URLSpan(\"www.baidu.com\") &#123; @Override public void onClick(View widget) &#123; //URLSpan点击响应 UIUtil.showToast(context, \"URLSpan点击\"); &#125; &#125;, start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder);//必须设置下面的方法，否则URLSpan点击事件无法响应mTextView.setMovementMethod(LinkMovementMethod.getInstance()); 使用URLSpan即可将TextView的部分文本设置为超链接显示样式，同时还可以实现点击响应，但是必须调用TextView.setMovementMethod(LinkMovementMethod.getInstance());点击响应才会有效 设置文本背景色使用BackgroundColorSpan为TextView的部分文本添加背景色123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置背景色的开始位置builder.append(\"设置背景色\");int end = builder.length();//设置背景色的结束位置builder.setSpan(new BackgroundColorSpan(Color.BLUE), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); BackgroundColorSpan可以将TextView的部分文本添加背景色，与ForegroundColorSpan的使用方式相同，只需要设置颜色即可 添加文本下划线使用UnderlineSpan为TextView的部分文本添加下划线123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置下划线的开始位置builder.append(\"下划线文本\");int end = builder.length();//设置下划线的结束位置builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 文本添加删除线使用StrikethroughSpan为TextView的部分文本添加删除线123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置删除线的开始位置builder.append(\"删除线文本\");int end = builder.length();//设置删除线的结束位置builder.setSpan(new StrikethroughSpan(), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 图片替换文本使用ImageSpan为TextView的部分文本替换为图片12345678SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//替换为图片的开始位置builder.append(\"图片替换文本\");int end = builder.length();//替换为图片的结束位置Drawable drawable = getResources().getDrawable(R.mipmap.ic_launcher);drawable.setBounds(0, 0, 50, 50);//设置图片为50px大小builder.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 设置部分粗体使用StyleSpan为TextView的部分文本设置为粗体123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置粗体的开始位置builder.append(\"粗体文本\");int end = builder.length();//设置粗体的结束位置builder.setSpan(new StyleSpan(Typeface.BOLD), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 为任意文本添加点击响应使用ClickableSpan为TextView的任意文本添加点击响应12345678910111213141516SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置删除线的开始位置builder.append(\"单击响应文本\");int end = builder.length();//设置删除线的结束位置builder.setSpan(new ClickableSpan() &#123;//将任意文本设置为可点击 @Override public void onClick(View widget) &#123; UIUtil.showToast(StyleTextViewActivity.this, \"ClickableSpan\"); &#125; @Override public void updateDrawState(TextPaint ds) &#123; //此方法的默认实现会出现下划线效果，去掉其默认实现 &#125; &#125;, start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder);mTextView.setMovementMethod(LinkMovementMethod.getInstance()); 组合使用各效果1234567SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置组合使用的开始位置builder.append(\"组合使用\");int end = builder.length();//设置组合使用的结束位置builder.setSpan(new ForegroundColorSpan(Color.WHITE), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);builder.setSpan(new BackgroundColorSpan(Color.RED), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 上面这些就是SpannableStringBuilder结合TextView的一些使用方法，其实使用起来还是很简单的。 具体使用示例代码请参考：https://github.com/huyongli/AndroidDemo write by laohu2016年11月5日21:45:48","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"SpannableStringBuilder","slug":"SpannableStringBuilder","permalink":"http://ittiger.cn/tags/SpannableStringBuilder/"},{"name":"TextView","slug":"TextView","permalink":"http://ittiger.cn/tags/TextView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"记一次9.png的填坑之旅","slug":"My-9.png-hold-the-fat-lady-tour","date":"2016-11-05T04:26:42.000Z","updated":"2016-11-07T10:07:51.041Z","comments":true,"path":"My-9.png-hold-the-fat-lady-tour.html","link":"","permalink":"http://ittiger.cn/My-9.png-hold-the-fat-lady-tour.html","excerpt":"最近在项目中进行界面调整时遇到了一个9.PNG图引起的View的padding值不正常导致UI显示不符合预期结果的问题。这篇文章就来记录我当时遇到的问题的表现形式，以及如何根据问题找到产生问题的原因，及其最后的解决办法。","text":"最近在项目中进行界面调整时遇到了一个9.PNG图引起的View的padding值不正常导致UI显示不符合预期结果的问题。这篇文章就来记录我当时遇到的问题的表现形式，以及如何根据问题找到产生问题的原因，及其最后的解决办法。 问题表现形式不多说，直接上出现问题的视图表现形式的截图： 我的实现上图中我实现的是一个ListView，同时自定义实现一个视图Png9View extends FrameLayout作为ListView的item视图，为每个item设置灰色背景色。Png9View视图中的白色部分是一个线性布局，并为线性布局顶部添加了一个蓝色的分割线，其底部添加了一个红色的分割线，中间是一个TextView。 大家可以看下item视图实现代码如下，整个Demo的代码在这里https://github.com/huyongli/AndroidDemo：12345678910111213141516171819202122public class Png9View extends FrameLayout &#123; private LinearLayout mContainer; public Png9View(Context context) &#123; this(context, null); &#125; public Png9View(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public Png9View(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; private void init(Context context) &#123; LayoutInflater.from(context).inflate(R.layout.png_9_view, this, true); mContainer = (LinearLayout) findViewById(R.id.root); setBackgroundColor(getResources().getColor(android.R.color.darker_gray)); mContainer.setBackgroundResource(R.drawable.bg); &#125;&#125; png_9_view布局代码如下：123456789101112131415161718192021222324252627&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;LinearLayout android:id=\"@+id/root\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"@android:color/holo_blue_dark\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_margin=\"10dp\" android:background=\"@color/colorAccent\" android:textColor=\"@android:color/white\" android:gravity=\"center_vertical\" android:text=\"测试视图标题\"/&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"@android:color/holo_red_dark\"/&gt; &lt;/LinearLayout&gt;&lt;/merge&gt; ListView的布局如下：1234567&lt;ListView android:id=\"@+id/listView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:dividerHeight=\"0dp\" android:divider=\"@null\"&gt;&lt;/ListView&gt; 问题？通过上面的效果截图我们很容易发现在第一个Png9View的底部红色分割线和第二个Png9View的顶部蓝色分割线中还有一小段灰色的间隔，而这个灰色间隔显然与我的期望效果不一样，那这个灰色间隔是哪里来的呢？我的代码里好像没有任何设置会出现这样的效果啊。 问题分析出现上面的问题后我第一个想到的就是打开开发者模式中显示布局边界，结果竟然发现这个灰色间隔是Png9View的一部分，而其颜色也刚好与Png9View的背景色相同，但我并没有为LinearLayout视图设置过margin啊，ListView也没有设置过divider，所以看到这个现象时感到很奇怪。想了会也没想出个所以然来，很是费解啊~~~ 后来想到在Android Studio 2.2.2中有个新工具Layout Inspector(该工具在Tools -&gt; Android -&gt; Layout Inspector)可以进行UI分析，于是用该工具对界面进行分析最后发现了问题的原因，大家看下我对上面的界面进行分析的截图： 上面的图中，我选中的是Png9View的布局文件中的id为root的LinearLayout(左边圈中的)，右边圈的是该布局的相关属性值信息，可以看到该线性布局有的paddingBottom属性值为5，而我也并没有为该LinearLayout设置过margin属性值，那这个值是怎么来的呢？ 这个时候我就只能想到该线性布局设置的背景图片bg.9.png了这个地方了。于是我就猜想难道是因为设置了这个.9图才导致了这个问题？为了验证我的猜想，于是我就直接将背景换成了一个颜色作为背景，结果发现就正常了。到这里基本上就可以肯定这个问题就是9.png图干的好事了。 给大家看下我设置的这个图片是什么样的 解决办法因为我们项目中这个.9图本身就是为了达到白色的效果，所以我直接用背景颜色代替图片作为背景图解决了我的这个问题，这样还可以减少图片资源。 疑问看了上面的分析之后，可能大家会问另外一个问题，既然这个paddingBottom值是属于LinearLayout的，那为什么会产生margin的效果呢？padding应该是当前布局的内容距离当前布局的边距，那也应该是白色啊，怎么这个padding区域显示的却是其父布局Png9View的背景色呢，怎么就产生了margin的效果呢？ 大家伙别急，原因且待下篇分解。。。 write by laohu2016年11月5日15:14:09","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"9.png","slug":"9-png","permalink":"http://ittiger.cn/tags/9-png/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"RxJava学习之基本使用","slug":"RxJava-Basic-Use","date":"2016-10-27T13:46:42.000Z","updated":"2016-11-07T10:07:51.069Z","comments":true,"path":"RxJava-Basic-Use.html","link":"","permalink":"http://ittiger.cn/RxJava-Basic-Use.html","excerpt":"RxJava现在在Android开发中越来越流行，作为一个Android开发者我也必须紧跟步伐学习学习RxJava，这篇文章就记录了RxJava中我认为比较常用的一些场景。 也给大伙推荐篇比较好的RxJava文章 给 Android 开发者的 RxJava 详解 RxJava基础大家都知道JDK中提供了观察者模式的实现，它主要两个重要元素： 被观察者 Observable 观察者 Observer 至于Java中观察者模式的使用，大家可以自行Google下。 而RxJava中也有两个重要的元素： 被观察者(事件源) Observable 观察者(事件订阅者) Subscriber 因此RxJava的设计看起来也有点类似JDK中的观察者模式，都有被观察者和观察者。JDK观察者模式中当有操作需要时是由被观察者通知观察者来进行更新操作RxJava中是由被观察者Observable发出事件给观察者Subscriber接收，然后观察者Subscriber调用noNext()进行处理，直到调用onComplete)()或onError()结束","text":"RxJava现在在Android开发中越来越流行，作为一个Android开发者我也必须紧跟步伐学习学习RxJava，这篇文章就记录了RxJava中我认为比较常用的一些场景。 也给大伙推荐篇比较好的RxJava文章 给 Android 开发者的 RxJava 详解 RxJava基础大家都知道JDK中提供了观察者模式的实现，它主要两个重要元素： 被观察者 Observable 观察者 Observer 至于Java中观察者模式的使用，大家可以自行Google下。 而RxJava中也有两个重要的元素： 被观察者(事件源) Observable 观察者(事件订阅者) Subscriber 因此RxJava的设计看起来也有点类似JDK中的观察者模式，都有被观察者和观察者。JDK观察者模式中当有操作需要时是由被观察者通知观察者来进行更新操作RxJava中是由被观察者Observable发出事件给观察者Subscriber接收，然后观察者Subscriber调用noNext()进行处理，直到调用onComplete)()或onError()结束 Gradle依赖12compile 'io.reactivex:rxjava:1.0.1'compile 'io.reactivex:rxandroid:1.0.1' 基础方式创建Observable和Subscriber123456789101112131415161718192021222324252627//使用Observable.create()方式创建一个Observable事件源Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(\"hello world\"); subscriber.onCompleted(); &#125;&#125;);//创建一个观察者SubscriberSubscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.d(\"RxJava\" \"onComplete\"); &#125; @Override public void onError(Throwable e) &#123; Log.d(\"RxJava\" \"onError\"); &#125; @Override public void onNext(String s) &#123; Log.d(\"RxJava\" s); &#125;&#125;;//观察者订阅事件源observable.subscribe(subscriber); 上面是RxJava的基础使用方式，这种方式使用起来和观察者模式还是比较像的，首先创建一个被观察者Observable，再创建一个观察者Subscriber，然后观察者订阅这个被观察者，一旦订阅之后Observable就会执行上面的call(Subscriber subscriber)方法(参数里面的Subscriber参数就是我们创建的观察者实例)，通过该方法我们手动调用Subscriber方法的onNext和onCompleted方法。这里有个要注意的就是我们必须自己手动调用onNext和onCompleted方法，否则不会自己执行。 简化创建Observable和Subscriber上面提到的Observable和Subscriber创建方式是RxJava中最基本的方式，但是上面的方式使用起来还是感觉有点繁琐，必须按部就班的来。 RxJava中也提供了简单的创建方式，比如：Observable.just()方式创建Observable，完整是示例如下：1234567891011//创建一个只发出一个事件就结束的对象Observable&lt;String&gt; observable = Observable.just(\"hello world\");//创建一个只关心onNext处理的subscriberAction1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(\"RxJava\" s); &#125;&#125;;//此方法有重载版本，可以传递处理onError,onComplete的Actionobservable.subscribe(onNextAction); 上面的方法中使用Observable.just()方法可以快速的创建一个发送hello world事件的事件源，而如果我们只关心观察者对事件的处理，而不关心事件处理结束和事件发生错误时的处理，我们则可以创建Action1对象来替代Subscriber进行事件处理。 上面observable.subscribe(onNextAction)一旦订阅事件，就会自动的执行Action1中的call方法，该方法的作用等同于Subscriber中的onNext方法的作用，至于为什么一旦订阅就会自动执行call方法，而前面的一个例子中我们却需要手动调用Subscriber中的onNext方法，这个原因大家可以去源码实现中找答案，我就不介绍了。 当然如果你除了处理事件外，也需要对事件结束和事件错误时进行其他处理，则可以使用observable.subscribe(Action1)另一个重载方法observable.subscribe(Action1,Action1,Action1)分别接收对应onNext,onCompleted,onError. Action1中的call方法只能接收一个参数，RxJava中也提供了很多其他的几种Action，从Action0到Action9分表代表其call方法能接收0个参数到9个参数，另外还有一个ActionN其能接收N个参数。 RxJava其实是支持链式写法 的，所以上面的写法可以适用如下的方式实现：1234567Observable.just(\"hello world\") .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(\"RxJava\" s); &#125; &#125;); 上面介绍了RxJava的基本使用，下面接着介绍RxJava中一些比较常用的功能函数。 事件变换map这个map是干什么用的呢？我举个例子：比如说我们有一个Observable对象，这个对象发送的事件是一串用户密码字符串，但是Subscriber进行处理的时候需要的是一个包含加密后的密码串，这个时候我们就可以使用map操作符将一个Observable对象发送的事件修改成另一个事件，下面的代码里通过map将hello world转换成其hashCode值12345678910111213141516Observable.just(\"hello world\")//map操作将一个事件变换为另外一个事件，只会影响到当前的subscriber//此处将Observable的String事件转换成Integer事件，所以事件是可用改变的.map(new Func1&lt;String, Integer&gt;() &#123; @Override public Integer call(String s) &#123; return s.hashCode(); &#125;&#125;).subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer hashCode) &#123; //这里的值就是hello world的hash值 Log.d(\"RxJava\" s); &#125;&#125;); 例子中map(Func1&lt;source, target&gt;)操作符通过Func1&lt;source, target&gt;类将source事件转换修改成target事件 通过上面的介绍可以看出map是用来变换修改Observable所发出的事件 Observable变换flatMapmap是用来变换Observable所发出的事件，而flatMap就更强大，它可以将Observable转换成一个全新的Observable，依旧上例子代码1234567891011121314Observable.just(\"laohu\") //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123; @Override public Observable&lt;User&gt; call(String s) &#123; return Observable.just(new User(s)); &#125; &#125;) .subscribe(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; Log.d(\"RxJava\" user.getName()); &#125; &#125;); 上面的例子中通过flatMap操作符将一个发送laohu事件的Observable转换成一个发送User对象的Observable，该变化是完全生成一个新的Observable Observable.from在我们开发过程中经常需要对一个数组或是一个集合数据进行处理，比如我通过班级编号可以查出这个班的所有学生，查询出来后需要打印出每个学生的名字，那么我们使用上面介绍的方式该怎么做呢？12345678910List&lt;Student&gt; students= ...Observable.just(students) .subscribe(new Action1&lt;List&lt;Student&gt;&gt;() &#123; @Override public void call(List&lt;Student&gt; students) &#123; for(User user : users) &#123; Log.d(\"RxJava\" students.getName()); &#125; &#125; &#125;); 上面的做法中，很明显我们是在Subscriber中对列表进行循环打印出每个学生的名字，这种方法是不是感觉很多余，我既然都拿到列表了我干嘛还要多次一举使用RxJava去进行循环处理。这时使用Observable.from就可以解决这个问题，该方法可以将集合或数组进行循环处理，每次发送一个事件元素给Subscriber进行处理，在Subscriber中只需要针对单个Student进行姓名打印就可以了，改进之后的写法如下：12345678List&lt;Student&gt; students= ...Observable.from(students) .subscribe(new Action1&lt;Student&gt;() &#123; @Override public void call(Student student) &#123; Log.d(\"RxJava\" student.getName()); &#125; &#125;); 改进之后的写法看着是不是很简单，from配合flatMap可以实现很多很复杂的操作，后面我们再举例 事件过滤filter12345678910111213141516171819202122232425262728293031323334353637public class User &#123; private String name; private int age; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; ...&#125;String[] array = &#123;\"张三\", \"李四\", \"王麻子\", \"赵六\"&#125;;Observable.from(array) //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123; @Override public Observable&lt;User&gt; call(String s) &#123; int age = 20; if(s.length() &gt; 2) &#123;//名字长度大于2的年龄设为10 age = 10; &#125; return Observable.just(new User(s, age)); &#125; &#125;) //将age &lt;= 10的事件过滤掉 .filter(new Func1&lt;User, Boolean&gt;() &#123; @Override public Boolean call(User user) &#123; return user.getAge() &gt; 10; &#125; &#125;) .subscribe(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; Log.d(\"RxJava\" user.getName()); &#125; &#125;); 上面的例子中，会将年龄小于等于10的用户数据过滤掉不进行处理，因此在filter的call方法中进行判断，年龄小于等于10的数据返回false即可将该数据过滤掉。 选取指定数量数据take()上面的例子中如果我只想对符合条件的前两个数据进行处理该怎么做呢，这时我们可以使用take()操作符来实现12345678910111213141516171819202122232425262728String[] array = &#123;\"张三\", \"李四\", \"王麻子\", \"赵六\"&#125;;Observable.from(array) //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123; @Override public Observable&lt;User&gt; call(String s) &#123; int age = 20; if(s.length() &gt; 2) &#123; age = 10; &#125; return Observable.just(new User(s, age)); &#125; &#125;) //将age &lt;= 10的事件过滤掉 .filter(new Func1&lt;User, Boolean&gt;() &#123; @Override public Boolean call(User user) &#123; return user.getAge() &gt; 10; &#125; &#125;) //只取符合条件的前两个结果 .take(2) .subscribe(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; Log.d(\"RxJava\" user.getName()); &#125; &#125;); doOnNext上面的例子中如果我们取到前两个符合条件的数据进行处理之前，我们要先进行缓存处理，这个时候我们就可以使用doOnNext操作符进行处理，实现如下：1234567891011121314151617181920212223242526272829303132333435String[] array = &#123;\"张三\", \"李四\", \"王麻子\", \"赵六\"&#125;;Observable.from(array) //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123; @Override public Observable&lt;User&gt; call(String s) &#123; int age = 20; if(s.length() &gt; 2) &#123; age = 10; &#125; return Observable.just(new User(s, age)); &#125; &#125;) //将age &lt;= 10的事件过滤掉 .filter(new Func1&lt;User, Boolean&gt;() &#123; @Override public Boolean call(User user) &#123; return user.getAge() &gt; 10; &#125; &#125;) //只取符合条件的前两个结果 .take(2) //在subscribe执行之前进行额外的操作，比如将数据保存到磁盘上 .doOnNext(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; save(user); &#125; &#125;) .subscribe(new Action1&lt;User&gt;() &#123; @Override public void call(User user) &#123; Log.d(\"RxJava\" user.getName()); &#125; &#125;); 线程调度比如我们有一个同步请求网络数据的服务，在Android中使用RxJava进行处理该怎么做呢？我们可以使用subscribeOn()指定被观察者(事件)的运行线程，使用observeOn()指定观察者(订阅者)的运行线程。12345678910111213141516Observable.just(\"查询条件\") .subscribeOn(Schedulers.io())//在子线程中进行查询操作 .flatMap(new Func1&lt;String, Observable&lt;Result&gt;&gt;() &#123; @Override public Observable&lt;Result&gt; call(String whereClause) &#123; Result result = queryResult(whereClause); return Observable.just(result); &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//在UI线程中处理结果 .subscribe(new Action1&lt;Result&gt;() &#123; @Override public void call(final Result result) &#123; Log.d(\"RxJava\" result.toString()); &#125; &#125;); 上面这些是我目前使用RxJava用到的一些功能函数和操作符，后面学习了其他操作符之后，我会用另外的一篇博文记录下来。 write by 老胡 2016年10月30日 本文章发表在 独立博客 ittiger.cn 和 个人CSDN博客","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"RxJava","slug":"RxJava","permalink":"http://ittiger.cn/tags/RxJava/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"透过Retrofit使用看其源码设计模式","slug":"Retrofit-Source-Design-Pattern","date":"2016-10-13T08:43:42.000Z","updated":"2016-10-14T06:49:38.456Z","comments":true,"path":"Retrofit-Source-Design-Pattern.html","link":"","permalink":"http://ittiger.cn/Retrofit-Source-Design-Pattern.html","excerpt":"前言这篇文章我将从Retrofit的基本用法出发，透过其使用步骤，一步步的探究Retrofit的实现原理及其源码的设计模式。这篇文章可能会将Retrofit中用到的设计模式和其实现原理穿插着写，所以各位同学也可以选择性的阅读。而对于Retrofit具体使用还不太清楚的同学可以去看的另一篇文章Retrofit2的使用介绍","text":"前言这篇文章我将从Retrofit的基本用法出发，透过其使用步骤，一步步的探究Retrofit的实现原理及其源码的设计模式。这篇文章可能会将Retrofit中用到的设计模式和其实现原理穿插着写，所以各位同学也可以选择性的阅读。而对于Retrofit具体使用还不太清楚的同学可以去看的另一篇文章Retrofit2的使用介绍 Retrofit基本用法我以用户登录作为示例： 声明接口首先我们先定义一个登录服务接口LoginService，如下：12345public interface LoginService &#123; @FormUrlEncoded @POST(\"login\") Call&lt;String&gt; login(@Field(\"username\") String name, @Field(\"password\") String password);&#125; 创建Retrofit对象1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://ittiger.cn\") .addConverterFactory(GsonConverterFactory.create()) .build(); 发起请求123LoginService service = retrofit.create(LoginService.class);Call&lt;User&gt; call = service.login(\"user\", \"pwd\");call.execute()或call.enqueue() Retrofit关键类在讲Retrofit实现原理之前，我先说下Retrofit里面涉及到几个关键类都是干什么用的 Retorift： 负责配置请求过程中的基本参数，如：请求地址，结果转换器，自定义OKHttpClient等，同时还会生成请求接口对象 Call： 网络请求执行者(Retrofit.Call)，比如：上面示例中最后调用login方法得到的Call对象就是此接口的实例 OkHttpCall： 此类是Retrofit.Call接口的实现，示例中最后调用login方法得到的Call对象就是此类的实例。但是其底层网络请求执行都是通过OkHttp.Call接口间接执行的，也就是说OkHttpCall是对OkHttp.Call网络请求功能的封装。 Converter &amp; Converter.Factory： 分别负责网络请求结果转换以及生成Converter转换器 CallAdapter &amp; CallAdapter.Factory： 分别负责对Retrofit.Call实例(OkHttpCall)进行适配及生成CallAdapter适配器 Platform： 确定Retrofit当前运行平台，以及确定当前平台默认的的CallAdapter.Factory和Executor ExecutorCallAdapterFactory： Android平台下的默认CallAdapter.Factory实现 ServiceMethod： 解析接口服务所有注解、生成请求对象Request、解析请求结果Response ParameterHandler： 服务接口方法(login())参数解析处理器，配合ServiceMethod进行服务接口参数注解解析 RequestBuilder： 根据参数和URL构造请求需要的OkHttp.Request对象 以上就是Retrofit源码实现中比较关键的10个类及其相关作用 使用流程 &gt;&gt; 实现 &gt;&gt; 设计模式Builder模式创建RetrofitRetrofit场景1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://ittiger.cn\") .addConverterFactory(GsonConverterFactory.create()) .build(); 上面代码的对象创建方式看着是不是似曾相识，看着很眼熟，没错，Android里面的Dialog的创建就是使用的这种方式：Builder模式 Builder模式定义将一个复杂对象的构建与它的表示分离，使得同样的构建可以创建不同的表示 Builder模式使用场景 相同的方法不同的执行顺序产生不同的结果 多个部件都可以装配到一个对象中，但是产生的结果不同 Builder模式类图 Retrofit中的Builder模式 Retrofit中的Builder模式是简化版的Builder模式，省略了抽象建造者和指挥者 不同的配置会对Retrofit产生不同的影响，如果通过addCallAdapterFactory()配置CallAdapterFactory和不配置CallAdapterFactory会对Retrofit产生完全不同的影响。 如果Retrofit中使用构造方法的方式创建对象，则需要实现多个不同参数的构造方法，而使用构造方法创建对象时如果参数太多，很多时候参数代表的意思是不太理解的，总归来说就是创建过程不直观。 Builder模式优缺点 优点： 不需要知道产品内部的组成细节，产品与创建过程解耦 分步组装产品，使得产品的创建过程更精细更清晰 容易扩展，新产品只需要新建一个建造者即可 缺点： Builder模式创建的产品差异性小，使用范围受限制 不同的产品会产生多个建造者和指挥者 Retrofit创建流程 &gt;&gt; Platform在创建Retrofit过程中有这样一行代码：123Retrofit retrofit = new Retrofit.Builder()....build(); 从代码可以看到在创建Retrofit时得先根据Retrofit.Builder内部类的默认构造方法Retrofit.Builder()创建一个Builder对象，所以我们来看看这个默认构造方法里都做了些什么事：123public Builder() &#123; this(Platform.get());&#125; OK，我们再来看看我们前面说到的Platform这个平台类的静态方法get()1234567891011121314151617181920212223242526272829//静态实例对象，类加载就确定了private static final Platform PLATFORM = findPlatform(); static Platform get() &#123; return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; Class.forName(\"android.os.Build\"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName(\"java.util.Optional\"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName(\"org.robovm.apple.foundation.NSObject\"); return new IOS(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(); &#125; ...&#125; 通过上面的代码我们可以很明确的知道，在Platform类加载的时候它就通过反射的机制确定了当前运行的平台是属于哪一个，是Android，是Java8还是IOS，并生成对应的平台类的实例，get()方法是用来获取当前的平台类的实例。 目前，我们只关注Android平台下的Platform实例，我们也来看看Android平台类中做了些什么：1234567891011121314151617static class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125; &#125; 可以看到Android类中重写了Platform类的两个方法defaultCallbackExecutor()和defaultCallAdapterFactory(Executor callbackExecutor) 前者就是用来返回当前平台下默认的Executor，这Android平台下就是MainThreadExecutor这个类的实例，可以看到这个执行器主要就是用来进行线程切换的，因为我们知道安卓平台下所有的UI操作都必须在UI线程中执行。 后者就是用来返回当前平台下默认的CallAdapter.Factory 当然你也可以不使用这两个默认值，都可以在创建Retrofit过程中自定义配置自己需要的相关实例 Retrofit创建流程 &gt;&gt; ExecutorCallAdapterFactory看完Platform之后紧接着我们再来看看Android平台下默认的CallAdapter.Factory实现ExecutorCallAdapterFactory都做了些什么，这里只贴关键代码：123456789101112131415161718192021222324252627282930public interface CallAdapter&lt;T&gt; &#123; abstract class Factory &#123; public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit); ... &#125;&#125;final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor;//对应默认的MainThreadExecutor ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; ... return new CallAdapter&lt;Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; ...&#125; 大家看源码可以发现CallAdapter.Factory工厂是通过get()方法来创建CallAdapter的，所以ExecutorCallAdapterFactory关键代码也是在get()方法的实现上，上面的代码中我们可以看到get()方法返回一个CallAdapter实例，这就是我前面介绍关键类作用时说到的CallAdapter.Factory主要负责生成CallAdapter的实现。 该类中，我们从其类的命名以及代码实现结构上来看，ExecutorCallAdapterFactory其实也使用了一种设计模式，那就是工厂方法模式，其实Retrofit中还有一个地方也使用了工厂方法模式，那就是Converter &amp; Converter.Factory它的实现方式和CallAdapter &amp; CallAdapter.Factory是一样样的。 工厂方式模式(创建CallAdapter &amp; Converter)本文我就已CallAdapter进行举例，看懂CallAdapter的创建原理之后，再看Converter的创建也就比较简单，都是一样的道理。 Retrofit场景Retrofit中使用工厂方式模式的场景我在前面讲ExecutorCallAdapterFactory实现的时候已经讲过了，这里就不重复举例了，大家可以对照着源码看下。 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪个类 工厂方法模式使用场景 不需要知道其具体的类名，只需要知道生成它的工厂 一个类通过其子类来决定创建哪个对象 工厂方法模式类图 Retrofit中的工厂方法 Retrofit中使用工厂方法模式可以讲CallAdapter的创建与具体实现充分解耦，对于创建我们只需要知道其工厂即可，不需要关注是如何实现 所以我们可以通过addCallAdapterFactory()和addConverterFactory()很方便的自定义我们自己所需要的适配器工厂和数据转换工厂 通过addCallAdapterFactory()可以很方便的让Retrofit支持RxJava特性，而通过addConverterFactory()可以自定义配置们想要的转换器，让我们可以将请求数据结果转换成我们想要的任意类型。 这些就是Retrofit使用工厂方法模式带来的好处。 工厂方法模式优缺点 优点 只关注产品工厂即可，不需要关注产品如何创建，由工厂确定如何创建 扩展性好，新增产品时，只需要新增一个具体工厂和具体产品 缺点 新增产品时，需要新增具体工厂和具体产品类，使系统变得庞大 系统中加入抽象层，增加了系统的抽象性和理解难度 适配器模式 &gt;&gt; CallAdapterRetrofit场景先来看看CallAdapter在Retrofit中的使用场景12345678910111213141516public interface CallAdapter&lt;T&gt; &#123; public Type responseType(); public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call);&#125;//ExecutorCallAdapterFactory中生成CallAdapter实例return new CallAdapter&lt;Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; 前面讲到ExecutorCallAdapterFactory会生成一个CallAdapter实例。而CallAdapter这个名字看着是不是也很眼熟，也有种似曾相识的感觉，没错，CallAdapter与我们在Android中使用ListView或RecyclerView时经常用到的各种Adapter一样也是一个适配器。 那CallAdapter是来适配什么的呢？ 还记得前面介绍关键类的时候说到的OkHttpCall吗？CallAdapter就是来适配OkHttpCall实例的，结合上面的代码来说的话在调用CallAdapter.adapt方法时OkHttpCall实例会作为参数传递给adapt方法从而交给CallAdapter去进行适配。 在我前面举的登录示例中，我们调用login()方法得到的Call实例就是CallAdapter适配OkHttpCall之后得到的一个新Call实例对象，至于为什么是这样，我后面会一一讲解，各位看官不要离开 所以Retrofit在这个地方又使用了一种设计模式：适配器模式 适配器模式定义将一个类的接口变成客户端所需要的另一个接口，从而使原本因接口不匹配而无法一起工作的两个类可以在一起工作 适配器模式使用场景 需要复用现有类，而现有类不符合系统需求 需要一个统一的输出接口，而输入端类型不可预知 适配器模式类图 Retrofit中的适配器模式12345678910//ExecutorCallAdapterFactory中生成CallAdapter实例return new CallAdapter&lt;Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; Android平台下默认的CallAdapter会将OkHttpCall 和 MainThreadExecutor两个实例对象适配成一个新的Call实例，这个新的Call实例在执行过程中就具备了切换到UI线程的功能。 那Retrofit在这个地方为什么要使用适配器模式将OkHttpCall进行适配了，直接拿过来用不就可以了吗？ 前面讲过OkHttpCall仅仅只是对OkHttp.Call执行网络请求操作的封装，没有其他功能，也就是说OkHttpCall也只有网络请求的功能，而Retrofit是支持多个平台的（安卓，Java8，IOS，甚至包括支持RxJava特性），而不同的平台可能具有不同的特性。 如果在请求过程中需要用到这些特性的话，那么单靠OkHttp.Call是无法完成的，而如果在其他地方柔和进这些特性的支持可能就会使得框架结构不那么严谨平台解耦性比较差，甚至有可能会增加更多的接口。 Retrofit通过使用适配器模式将平台特性与OkHttpCall适配成一个最终我们需要的Call实例，这样的话我们在使用过程中只需要关注最后拿到的Call对象，而不需要关注底层这个Call实例到底是什么样的，这也就为我们支持更多的特性提供了可能。比如对RxJava特性的支持，我们只需要提供一个支持RxJava特性的CallAdapter适配器即可，所以我们就可以通过addCallAdapterFactory()配置我们提供的支持RxJava特性的CallAdapter.Factory 适配器模式优缺点 优点 复用性好，引入适配器类来重用适配者类，无需修改原有代码 增加类的透明性，将适配过程封装在适配器类中，对使用者来说相对透明 灵活性扩展性好，通过配置可以随时更换适配器 缺点 使用适配器会使系统整体不好把握，调的是A接口，却被适配成了B接口的实现 静态代理模式 &gt;&gt; ExecutorCallbackCallRetrofit场景还是先来看看Retrofit中使用ExecutorCallbackCall的场景1234567//ExecutorCallAdapterFactory中生成CallAdapter实例return new CallAdapter&lt;Call&lt;?&gt;&gt;() &#123; ... @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; 在上面CallAdapter实现中，可以发现它将OkHttpCall适配成了一个新的Call实例：ExecutorCallbackCall，所以我们接着看看ExecutorCallbackCall的具体实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor;//Android平台下的Executor：MainThreadExecutor final Call&lt;T&gt; delegate;//网络实际执行者OkHttpCall实例 ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException(\"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //Android平台下此处进行了线程切换 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; //Android平台下此处进行了线程切换 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; @Override public boolean isExecuted() &#123; return delegate.isExecuted(); &#125; @Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute(); &#125; @Override public void cancel() &#123; delegate.cancel(); &#125; @Override public boolean isCanceled() &#123; return delegate.isCanceled(); &#125; @SuppressWarnings(\"CloneDoesntCallSuperClone\") // Performing deep clone. @Override public Call&lt;T&gt; clone() &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone()); &#125; @Override public Request request() &#123; return delegate.request(); &#125; &#125;&#125; 可以看到我们通过login()方法拿到Call实例(也就是ExecutorCallbackCall)之后，在执行网络请求时，在ExecutorCallbackCall的实现中其实都是将具体操作委托给OkHttpCall在执行。所以Retrofit在ExecutorCallbackCall中又使用了一种设计模式：静态代理模式 静态代理模式定义为其他对象提供一种代理以控制对这个对象的访问 静态代理模式使用场景无法访问或不想直接访问某个对象 静态代理模式类图 Retrofit中的静态代理Retrofit中使用ExecutorCallbackCall代理OkHttpCall具体请求操作，可以将Call的使用与底层实现进行解耦，不用关心底层具体请求接口的实现，所以如果将来出现了一个比OkHttp更好的网络请求库，我们完全可以将OkHttp替换掉，即便这样也不会影响外部API接口在项目中的使用。 静态代理的优缺点 优点 协调调用者与被调用者，降低系统耦合度 减小外部接口与内部接口实现的关联，降低耦合 缺点 委托对象与代理对象需要实现相同的接口，当接口类增加方法时，除了所有实现类需要增加该方法外，所有代理类也需要实现此方法，增加了维护难度 一个代理类只能代理一种类型的对象 动态代理 &gt;&gt; Retrofit.create()先看下Retrofit.create()方法的具体实现代码：1234567891011121314public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable &#123; ... ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;);&#125; 相信很多人在刚开始用Retrofit时都会有一点疑问，我们明明声明的是接口，为什么通过create()方法就能创建出一个对象实例呢？通过上面的实现源码我们找到了答案，那就是使用了JDK中提供的动态代理机制，它会在运行过程中为我们声明的服务接口动态的创建出一个代理对象，以便实现我们的请求操作。我个人认为这是Retrofit框架得以实现的一个核心之处，另外一个核心之处就是其完善的注解机制，关于其注解本文就不说，主要就是一些注解的声明和解析，比较简单，感兴趣的可以去看看。 上面的源码中我们可以看到，运行过程中得到服务接口的代理对象之后，当我们调用login()这样的接口方法时，其实真实执行的是上面源码中写的invoke()方法，所以我们调用login()方法时其实是执行了如下三步： 根据反射得到接口方法Method对象生成对应的ServiceMethod对象，该对象会对该声明方法上的所有方法注解、参数注解进行解析以得到一个请求所需要的所有信息 得到ServiceMethod对象之后，会根据该对象和方法调用时传递的参数生成OkHttpCall对象，也就是具体的网络实施者 将OkHttpCall作为CallAdapter适配器中adapt()方法的参数传递给CallAdapter进行适配，最后得到我们所需要的ExecutorCallbackCall对象，也就是调用login()方法得到的Call实例对象 动态代理使用场景静态代理特点一个代理对应一种类型，如果有多个类需要代理则需要多个代理，而且维护成本高，而动态代理就是来解决此类问题 动态代理特点运行期由JVM通过反射机制动态生成，可以代理多种类型，代码复用性高。但是只能代理Java接口，不能代理Java实现类。 Call.enqueue() &amp; Call.execute()实现前面从Retrofit的配置、创建、调用接口方法得到Call实例，基本用法都已经讲的差不多了，现在我们来看基本用法的最后一步Call.enqueue() &amp; Call.execute() 前面讲过调用接口方法比如login()时，Android平台下默认得到的是ExecutorCallbackCall实例，而ExecutorCallbackCall实例中执行网络请求的实际上又是OkHttpCall，所以我们来看OkHttpCall中的Call.enqueue() &amp; Call.execute()两个方法的实现，我以Call.enqueue()为例，另外一个大家可以自己去看看 下面是该方法实现的关键代码： OkHttpCall.enqueue()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Override public void enqueue(final Callback&lt;T&gt; callback) &#123; ... okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; //如果okhttp3.Call为空，则先创建该实例 call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; failure = creationFailure = t; &#125; &#125; &#125; ... //又讲网络执行转交给okhttp3.Call实例来执行 call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; //将okhttp3.Response结果包装成Retrofit中的结果对象Response response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; ... &#125; private void callFailure(Throwable e) &#123; ... &#125; private void callSuccess(Response&lt;T&gt; response) &#123; ... &#125; &#125;); &#125; 前面介绍关键类时说过OkHttpCall底层网络执行其实是OkHttp.Call在执行，从上面的代码我们就可以看出来(代码关键地方我加了注释)，上面代码关键第一步是先创建一个okhttp3.call实例，所以我们同样看看创建okhttp3.call实例的代码是怎么实现的123456private okhttp3.Call createRawCall() throws IOException &#123; Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); ... return call; &#125; 通过上面的createRawCall()方法实现我们可以发现，它会首先通过ServiceMethod.toRequest()方法生成一个OkHttp.Request对象(这部分代码比较简单，我就不细说了)，然后根据ServiceMethod中的成员变量CallFactory创建一个okhttp3.Call实例。但是这个CallFactory是怎么来的呢？其实我们可以猜到这个CallFactory实例就是OkHttpClient实例。但是我们还是看看ServiceMethod的创建过程 ServiceMethod创建12345678910111213141516171819202122232425262728293031323334353637383940414243//在Retrofit.create()方法实现的第一步就是通过loadServiceMethod()方法创建ServiceMethod，这是其实现ServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result; &#125;//下面是ServiceMethod相关关键代码final class ServiceMethod&lt;T&gt; &#123; final okhttp3.Call.Factory callFactory; ServiceMethod(Builder&lt;T&gt; builder) &#123; this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; ... &#125; static final class Builder &#123; public Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; ... &#125; public ServiceMethod build() &#123; //创建CallAdapter callAdapter = createCallAdapter(); //得到请求结果返回类型，接口方法声明 responseType = callAdapter.responseType(); ... //创建得到Converter结果转换器 responseConverter = createResponseConverter(); ... return new ServiceMethod&lt;&gt;(this); &#125; &#125;&#125; 通过上面的ServiceMethod创建过程的相关代码可以看出，ServiceMethod中的实例变量callFactory其实是调用Retrofit.callFactory()方法所得，大家也可以看看上面我注释的CallAdapter和Converter的创建过程，所以我们再来看看这个方法的实现123public okhttp3.Call.Factory callFactory() &#123; return callFactory;&#125; 可以看到该方法只是返回了Retrofit中的callFactory实例，同样，我们再来看看Retrofit中的callFactory实例是怎么来的1234567891011121314151617181920212223242526272829303132public final class Retrofit &#123; private final okhttp3.Call.Factory callFactory; ... Retrofit(okhttp3.Call.Factory callFactory, ...) &#123; this.callFactory = callFactory; ... &#125; public static final class Builder &#123; private okhttp3.Call.Factory callFactory; ... public Builder client(OkHttpClient client) &#123; return callFactory(checkNotNull(client, \"client == null\")); &#125; public Builder callFactory(okhttp3.Call.Factory factory) &#123; this.callFactory = checkNotNull(factory, \"factory == null\"); return this; &#125; public Retrofit build() &#123; ... okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; ... return new Retrofit(callFactory, ...); &#125; &#125;&#125; 通过上面的代码，我们可以看出Retrofit中的callFactory实例就是我们使用的OkHttpClient实例，所以这就验证了我们前面猜测的serviceMethod.callFactory就是OkHttpClient实例的猜想。 Ok，回到我们前面将的OkHttpCall.equeue()方法的实现流程上来。 请求结果解析123456789101112131415call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; //将okhttp3.Response结果包装成Retrofit中的结果对象Response response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response); &#125; ...&#125; 创建完okhttp3.call实例之后，调用该实现的equeue()方法开始执行网络请求，请求执行完成之后，会调用parseResponse方法，我们来看看这个方法实现的关键代码：1234567891011121314Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); ... //上面省略的这段代码是对请求失败时的结果处理，大家可以自行查看源码 ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; catchingBody.throwIfCaught(); throw e; &#125; &#125; 这个方法中，当请求成功时，会调用serviceMethod.toResponse()这个方法，我们来看看这个方法又做了哪些事情：123T toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body);&#125; 很明显，上面方法中就直接调用了ServiceMethod中的Converter实例进行结果转换，也就是说在这个地方Retrofit会帮我们把网络请求结果转换成我们所需要的类型，转换成功之后会调用Response.success(body, rawResponse)将转换后的结果包装成Retrofit中的Response对象。 获取配置的Converter问题又来了，上面的Converter是怎么来的呢？ 在前面给出的ServiceMethod创建过程的代码块中，我对ServiceMethod中创建Converter实例的代码进行了注释，我们再回过头来看看这段代码：1234567891011121314151617181920212223242526272829//ServiceMethod.Buibler中的方法private Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123; ... try &#123; return retrofit.responseBodyConverter(responseType, annotations); &#125; catch (RuntimeException e) &#123; // Wide exception range because factories are user code. throw methodError(e, \"Unable to create converter for %s\", responseType); &#125; &#125;//Retrofit中的方法public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123; return nextResponseBodyConverter(null, type, annotations); &#125;public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; ... int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; ... throw new IllegalArgumentException(builder.toString()); &#125; 通过上面的代码我们可以看到会从Retrofit的converterFactories转换器工厂集合中去查找当前接口方法对应的转换器工厂。其实这也告诉我们可以在创建Retrofit时配置多个Converter.Factory转换器工厂，也就是说我们一个接口服务中如果声明的多个接口方法的返回值不一样时，我们可以针对性的配置多个不一样的结果转换器工厂去进行结果解析，而不用为了保持结果类型一致对接口进行其他处理。 上面创建ServiceMethod时得到CallAdapter的过程与得到Converter的过程基本一样，我就不赘述了。 到这里，Retrofit的实现原理、实现流程以及其源码实现过程中用到的设计模式就介绍完了。 内容好长，时间好长~~~~","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://ittiger.cn/tags/Retrofit/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"在线视频播放App的实现","slug":"在线视频播放App的实现","date":"2016-09-28T03:56:22.000Z","updated":"2016-10-12T02:19:27.592Z","comments":true,"path":"在线视频播放App的实现.html","link":"","permalink":"http://ittiger.cn/在线视频播放App的实现.html","excerpt":"前一段时间在公司项目上做了一个视频播放的功能，当时时间紧，做完之后感觉有些地方处理的不好，所以就基于当时实现的思路进行了一些改进，加上自己平时喜欢看新闻客户端里面的一些短视频，所以就用网易等客户端的视频数据完成了一个独立的视频播放APP，顺便巩固下其他的技术。 主要使用的开源库Mosby(一个MVP框架)、RxJava、Retrofit2、ButterKnife、Glide、Systembartint、TigerDB、Material Design相关控件 主要功能 列表中播放视频 列表滑动时如果正在播放视频，则列表中播放的视频自动切换为小窗口浮动播放 列表播放切换到全屏播放模式 视频播放时也添加了完整的暂停、播放等控制操作，也添加了视频播放进度，视频缓冲进度等显示功能 视频全屏播放时支持左右滑动实现视频的快进和后退，支持右边上下滑动调整播放音量，左边上下滑动调整播放器的亮度等手势控制操作","text":"前一段时间在公司项目上做了一个视频播放的功能，当时时间紧，做完之后感觉有些地方处理的不好，所以就基于当时实现的思路进行了一些改进，加上自己平时喜欢看新闻客户端里面的一些短视频，所以就用网易等客户端的视频数据完成了一个独立的视频播放APP，顺便巩固下其他的技术。 主要使用的开源库Mosby(一个MVP框架)、RxJava、Retrofit2、ButterKnife、Glide、Systembartint、TigerDB、Material Design相关控件 主要功能 列表中播放视频 列表滑动时如果正在播放视频，则列表中播放的视频自动切换为小窗口浮动播放 列表播放切换到全屏播放模式 视频播放时也添加了完整的暂停、播放等控制操作，也添加了视频播放进度，视频缓冲进度等显示功能 视频全屏播放时支持左右滑动实现视频的快进和后退，支持右边上下滑动调整播放音量，左边上下滑动调整播放器的亮度等手势控制操作 播放器 播放器采用Android中自带的TextureView + MediaPlayer实现，同时视频播放过程中因为涉及到列表、小窗口、全屏续播等问题，所以整个视频播放过程中，播放器采用的是全局单例模式实现，这样就可以达到无缝切换续播的问题 切换到全屏播放时，是直接重新开启一个横向的Activity来实现全屏播放 APP实现效果图 github地址猛戳这里 感兴趣的朋友欢迎去我的github上star和fork","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Hexo搭建静态博客","slug":"create-hexo-blog","date":"2016-09-22T12:41:09.000Z","updated":"2016-09-29T02:00:44.926Z","comments":true,"path":"create-hexo-blog.html","link":"","permalink":"http://ittiger.cn/create-hexo-blog.html","excerpt":"前言前段时间因为我的WordPress博客进入后台非常慢，严重影响操作使用，再加上服务器时间的限制，所以就讲博客从WordPress迁移到了Hexo上，这篇文章记录下我创建Hexo博客的一些流程步骤。 HexoHexo是一个简单地、轻量地、基于NodeJS的一个静态博客框架，可以方便的生成静态网页托管在github或者是国内的coding.net上","text":"前言前段时间因为我的WordPress博客进入后台非常慢，严重影响操作使用，再加上服务器时间的限制，所以就讲博客从WordPress迁移到了Hexo上，这篇文章记录下我创建Hexo博客的一些流程步骤。 HexoHexo是一个简单地、轻量地、基于NodeJS的一个静态博客框架，可以方便的生成静态网页托管在github或者是国内的coding.net上 Github PagesGitHub Pages 可以被认为是用户编写的、托管在github上的静态网页。因为Github的空间免费稳定， 因此可以用于将自己的静态站点托管在github上来搭建自己的个人博客站点。另外国内的coding.net也支持Pages服务，同样可以进行托管静态网页。 Github上生成的网站的默认域名一般都是username.github.io，这里的username是指你在github上注册的用户名，当然github的网站也支持自定义绑定域名。 安装Git因为我们要将最终的静态网页文件推送到github上，所以第一步我们需要先在机器上安装Git，Git下载地址：https://git-for-windows.github.io/，安装完成之后配置好相关全局参数，如user，email等 安装NodeJS因为Hexo是基于NodeJS的，所以还需要安装NodeJS，下载地址：http://nodejs.org/ 安装Hexo在磁盘上任意目录下右键鼠标选择Git Bash，使用如下命令进行Hexo的安装npm install -g hexo 创建Hexo项目初始化Hexo项目在磁盘上新建一个文件夹作为自己Hexo项目的根目录，如：D:\\Hexo，在此目录下右键鼠标选择Git Bash，然后执行如下命令进行Hexo项目的初始化hexo init 安装Hexo项目依赖npm install 本地查看Hexo站点依赖安装完成之后，Hexo项目就算建好了，接下来我们使用如下命令检查项目是否成功创建：12hexo generate //此命令表示生成静态文件hexo server //比命令表示启动服务，启动之后在本地可以查看站点 执行上述两个命令之后，可以在命令行上看到提示，在浏览器中访问http://localhost:4000，可以成功访问则表示你的Hexo项目创建成功了。 创建Github仓库在github上创建一个与自己账户名一致的仓库：账号名.github.io，当然没有github账号的赶紧先去注册一个账号。 生成SSH密钥执行如下命令生成SSH密钥1ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空 执行完成之后，在C:\\Users\\Administrator\\.ssh下会生成两个文件id_rsa和id_rsa.pub 打开id_rsa.pub，复制全文，打开https://github.com/settings/ssh，Add SSH key，粘贴复制的文本内容 这样设置之后，将静态文件从本地推送到github上时就不要输入用户名和密码了，当然也可以不设置github的ssh，这样的话在推送文件到github上时会提示你输入用户名和密码 配置Hexo项目Hexo目录结构Hexo项目创建成功之后，我们在项目根目录下会发现这样几个我们经常用到的目录 source 这个目录是用来存放我们写的博客文件 themes 这个目录里是所有hexo安装的主题 _config.yml 这个文件是Hexo项目的主配置文件 配置Hexo使用文本编辑器打开上面介绍的_config.yml文件，按照官网https://hexo.io/docs/configuration.html上的提示配置好相关配置，具体配置细节我就不多介绍了，自己在官网上看吧 我只介绍一个配置项deploy配置，这个配置就是用来配置你的静态站点是要部署到哪个上面，一般都是用github，以我的配置为例：1234deploy: type: git repo: https://github.com/huyongli/huyongli.github.io.git branch: master 注意配置参数与值之间是需要有一个空格的，不然配置是无法生效的，type表示我们使用的是git，repo表示你github上的仓库地址，branch表示你仓库的分支，一般默认都是master 部署Hexo配置完Hexo之后，就可以将Hexo站点部署到github上了，执行如下命令进行部署：12hexo generatehexo deploy 如果在部署的过程中出现如下错误：1234ERROR Deployer not found: git执行如下命令：npm install hexo-deployer-git --save 在创建Hexo或是部署的过程中可能会多次出现类似的错误，一般都是使用npm install hexo-deployer-XXX --save类似的命令进行插件安装 上述命令执行成功后，重新部署，部署成功后，命令行上会提示Deploy done: git 成功部署后，过个几分钟就可以在浏览器上通过你的仓库地址访问你的博客了，还是以我的为例：http://huyongli.github.io 安装Hexo主题Hexo默认的主题很丑，如果想自己的博客看着舒服的话，需要安装另外的主题插件，我使用主题的是next 进入next主题主页https://github.com/iissnan/hexo-theme-next将此主题代码完整下下来，然后解压放到Hexo根目录下的themes目录下，然后将hexo项目的主题配置修改为next：theme: next 至于next主题的具体配置参考该主题的详细使用介绍吧http://theme-next.iissnan.com/ 到此，整个Hexo的安装部署就结束了","categories":[{"name":"Blog","slug":"Blog","permalink":"http://ittiger.cn/categories/Blog/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://ittiger.cn/tags/Hexo/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"http://ittiger.cn/categories/Blog/"}]},{"title":"Retrofit2文件上传下载及其进度显示","slug":"Retrofit2文件上传下载及其进度显示","date":"2016-09-21T12:30:39.000Z","updated":"2016-09-22T01:59:32.651Z","comments":true,"path":"Retrofit2文件上传下载及其进度显示.html","link":"","permalink":"http://ittiger.cn/Retrofit2文件上传下载及其进度显示.html","excerpt":"序前面一篇文章介绍了Retrofit2的基本使用，这篇文章接着介绍使用Retrofit2实现文件上传和文件下载，以及上传下载过程中如何实现进度的显示。 文件上传定义接口123@Multipart@POST(\"fileService\")Call&lt;User&gt; uploadFile(@Part MultipartBody.Part file); 构造请求体上传12345File file = new File(filePath);RequestBody body = RequestBody.create(MediaType.parse(\"application/otcet-stream\"), file);MultipartBody.Part part = MultipartBody.Part.createFormData(\"file\", file.getName(), body);Call&lt;User&gt; call = getRetrofitService().uploadOneFile(part);call.enqueue(callback);","text":"序前面一篇文章介绍了Retrofit2的基本使用，这篇文章接着介绍使用Retrofit2实现文件上传和文件下载，以及上传下载过程中如何实现进度的显示。 文件上传定义接口123@Multipart@POST(\"fileService\")Call&lt;User&gt; uploadFile(@Part MultipartBody.Part file); 构造请求体上传12345File file = new File(filePath);RequestBody body = RequestBody.create(MediaType.parse(\"application/otcet-stream\"), file);MultipartBody.Part part = MultipartBody.Part.createFormData(\"file\", file.getName(), body);Call&lt;User&gt; call = getRetrofitService().uploadOneFile(part);call.enqueue(callback); 这样就可以将这个文件上传到服务器，但就这样上传操作不够友好，最好加上文件上传进度。而Retrofit本身是不支持文件上传进度显示的，所以就需要我们自己扩展OkHttp来实现文件上传进度。 我的做法是直接扩展一个RequestBody来实现进度显示，实现完成之后只需要将上面body进行包装转换即可 上传进度显示12345678910111213141516171819202122232425262728293031RetrofitCallback&lt;User&gt; callback = new RetrofitCallback&lt;User&gt;() &#123; @Override public void onSuccess(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; runOnUIThread(activity, response.body().toString()); //进度更新结束 &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; runOnUIThread(activity, t.getMessage()); //进度更新结束 &#125; @Override public void onLoading(long total, long progress) &#123; super.onLoading(total, progress); //此处进行进度更新 &#125;&#125;;RequestBody body1 = RequestBody.create(MediaType.parse(\"application/otcet-stream\"), file);//通过该行代码将RequestBody转换成特定的FileRequestBodyFileRequestBody body = new FileRequestBody(body1, callback);MultipartBody.Part part = MultipartBody.Part.createFormData(\"file\", file.getName(), body);Call&lt;User&gt; call = getRetrofitService().uploadOneFile(part);call.enqueue(callback); 回调RetrofitCallback123456789101112131415161718public abstract class RetrofitCallback&lt;T&gt; implements Callback&lt;T&gt; &#123; @Override public void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response) &#123; if(response.isSuccessful()) &#123; onSuccess(call, response); &#125; else &#123; onFailure(call, new Throwable(response.message())); &#125; &#125; public abstract void onSuccess(Call&lt;T&gt; call, Response&lt;T&gt; response); public void onLoading(long total, long progress) &#123; &#125;&#125; FileRequestBody1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 扩展OkHttp的请求体，实现上传时的进度提示 * * @param &lt;T&gt; */public final class FileRequestBody&lt;T&gt; extends RequestBody &#123; /** * 实际请求体 */ private RequestBody requestBody; /** * 上传回调接口 */ private RetrofitCallback&lt;T&gt; callback; /** * 包装完成的BufferedSink */ private BufferedSink bufferedSink; public FileRequestBody(RequestBody requestBody, RetrofitCallback&lt;T&gt; callback) &#123; super(); this.requestBody = requestBody; this.callback = callback; &#125; @Override public long contentLength() throws IOException &#123; return requestBody.contentLength(); &#125; @Override public MediaType contentType() &#123; return requestBody.contentType(); &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; if (bufferedSink == null) &#123; //包装 bufferedSink = Okio.buffer(sink(sink)); &#125; //写入 requestBody.writeTo(bufferedSink); //必须调用flush，否则最后一部分数据可能不会被写入 bufferedSink.flush(); &#125; /** * 写入，回调进度接口 * @param sink Sink * @return Sink */ private Sink sink(Sink sink) &#123; return new ForwardingSink(sink) &#123; //当前写入字节数 long bytesWritten = 0L; //总字节长度，避免多次调用contentLength()方法 long contentLength = 0L; @Override public void write(Buffer source, long byteCount) throws IOException &#123; super.write(source, byteCount); if (contentLength == 0) &#123; //获得contentLength的值，后续不再调用 contentLength = contentLength(); &#125; //增加当前写入的字节数 bytesWritten += byteCount; //回调 callback.onLoading(contentLength, bytesWritten); &#125; &#125;; &#125;&#125; 文件下载接口定义文件下载请求与普通的Get和Post请求是一样的，只是他们的返回值不一样而已，文件下载请求的返回值一般定义成ResponseBody1234//这里只举例POST方式进行文件下载@FormUrlEncoded@POST(\"fileService\")Call&lt;ResponseBody&gt; downloadFile(@Field(\"param\") String param); 发起请求123456789101112131415161718192021222324252627282930313233RetrofitCallback&lt;ResponseBody&gt; callback = new RetrofitCallback&lt;ResponseBody&gt;() &#123; @Override public void onSuccess(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; InputStream is = response.body().byteStream(); String path = Util.getSdCardPath(); File file = new File(path, \"download.jpg\"); FileOutputStream fos = new FileOutputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); &#125; fos.flush(); fos.close(); bis.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; runOnUIThread(activity, t.getMessage()); &#125;&#125;; Call&lt;ResponseBody&gt; call = getRetrofitService(callback).downloadFile(param);call.enqueue(callback); 下载进度显示下载进度显示有两种方式实现，一种是通过OkHttp设置拦截器将ResponseBody进行转换成我们扩展后的ResponseBody（稍后介绍），另外一种则是在上面的回调Callback中将ResponseBody的流写入到文件时进行进度处理，下面分别进行介绍。 扩展ResponseBody设置OkHttp拦截器12345678910111213141516171819202122private &lt;T&gt; RetrofitService getRetrofitService(final RetrofitCallback&lt;T&gt; callback) &#123; OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder(); clientBuilder.addInterceptor(new Interceptor() &#123; @Override public okhttp3.Response intercept(Chain chain) throws IOException &#123; okhttp3.Response response = chain.proceed(chain.request()); //将ResponseBody转换成我们需要的FileResponseBody return response.newBuilder().body(new FileResponseBody&lt;T&gt;(response.body(), callback)).build(); &#125; &#125;); Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(clientBuilder.build()) .addConverterFactory(GsonConverterFactory.create()) .build(); RetrofitService service = retrofit.create(RetrofitService.class); return service ;&#125;//通过上面的设置后，我们需要在回调RetrofitCallback中实现onLoading方法来进行进度的更新操作，与上传文件的方法相同 FileResponseBody123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 扩展OkHttp的请求体，实现上传时的进度提示 * * @param &lt;T&gt; */public final class FileResponseBody&lt;T&gt; extends ResponseBody &#123; /** * 实际请求体 */ private ResponseBody mResponseBody; /** * 下载回调接口 */ private RetrofitCallback&lt;T&gt; mCallback; /** * BufferedSource */ private BufferedSource mBufferedSource; public FileResponseBody(ResponseBody responseBody, RetrofitCallback&lt;T&gt; callback) &#123; super(); this.mResponseBody = responseBody; this.mCallback = callback; &#125; @Override public BufferedSource source() &#123; if (mBufferedSource == null) &#123; mBufferedSource = Okio.buffer(source(mResponseBody.source())); &#125; return mBufferedSource; &#125; @Override public long contentLength() &#123; return mResponseBody.contentLength(); &#125; @Override public MediaType contentType() &#123; return mResponseBody.contentType(); &#125; /** * 回调进度接口 * @param source * @return Source */ private Source source(Source source) &#123; return new ForwardingSource(source) &#123; long totalBytesRead = 0L; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; long bytesRead = super.read(sink, byteCount); totalBytesRead += bytesRead != -1 ? bytesRead : 0; mCallback.onLoading(mResponseBody.contentLength(), totalBytesRead); return bytesRead; &#125; &#125;; &#125;&#125; 直接在回调中进行进度更新上面介绍了通过扩展ResponseBody同时设置OkHttp拦截器来实现进度条更新显示，另外也可以直接在请求回调onSuccess中将流转换成文件时实现进度更新，下面给出大致实现12345678910111213141516171819202122232425262728293031323334353637RetrofitCallback&lt;ResponseBody&gt; callback = new RetrofitCallback&lt;ResponseBody&gt;() &#123; @Override public void onSuccess(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; try &#123; InputStream is = response.body().byteStream(); //获取文件总长度 long totalLength = is.available(); String path = Util.getSdCardPath(); File file = new File(path, \"download.jpg\"); FileOutputStream fos = new FileOutputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) &#123; fos.write(buffer, 0, len); //此处进行更新操作 //len即可理解为已下载的字节数 //onLoading(len, totalLength); &#125; fos.flush(); fos.close(); bis.close(); is.close(); //此处就代表更新结束 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; runOnUIThread(activity, t.getMessage()); &#125;&#125;; 以上就是Retrofit中文件上传下载及其进度更新显示的实现，有疑问的可以加我微信和QQ与我联系，联系方式在这关于","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://ittiger.cn/tags/Retrofit/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Retrofit2使用介绍","slug":"Retrofit2使用介绍","date":"2016-08-29T12:50:13.000Z","updated":"2016-08-30T09:26:33.706Z","comments":true,"path":"Retrofit2使用介绍.html","link":"","permalink":"http://ittiger.cn/Retrofit2使用介绍.html","excerpt":"前言对于还不知道Refrofit是什么的同学，我只能说你们太out了，赶紧去Google下，本文是针对Retrofit2.0的使用介绍，当然大家也可以直接去官网上去看使用介绍 添加依赖要使用Retrofit首先得添加gradle依赖12compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.0&apos; 声明服务接口依赖添加完成之后，就可以开始撸代码了，首先我们要新建一个Interface，这个接口就是你要请求的接口服务类，就像这个样子 123456public interface RetrofitService &#123; @GET(\"getModelService\") Call&lt;User&gt; getModelService(); ...&#125; 上面这个接口中暂时只声明了一个方法，而在Retrofit中想这样声明的一个方法就代表了一个具体的Http请求接口。Retrofit中方法上添加@GET注解就表示当前方法代表一个Get请求，我们声明的这个请求方法不带任何参数，且返回结果是User对象。@GET注解括号中的值getModelService就代表http请求地址的具体指向，这个值与下面baseUrl中配置的URL一起组成一个完整的请求地址Retrofit就是这么任性，它可以帮我们把http的请求结果自动转换成Javabean对象，这将为我们减少不少编码工作。 构造Retrofit对象接口服务声明完成之后，我们接着需要新建一个Retrofit对象12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://localhost:8080/AndroidService/\") .addConverterFactory(GsonConverterFactory.create()) .build();RetrofitService service = retrofit.create(RetrofitService.class);","text":"前言对于还不知道Refrofit是什么的同学，我只能说你们太out了，赶紧去Google下，本文是针对Retrofit2.0的使用介绍，当然大家也可以直接去官网上去看使用介绍 添加依赖要使用Retrofit首先得添加gradle依赖12compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.0&apos; 声明服务接口依赖添加完成之后，就可以开始撸代码了，首先我们要新建一个Interface，这个接口就是你要请求的接口服务类，就像这个样子 123456public interface RetrofitService &#123; @GET(\"getModelService\") Call&lt;User&gt; getModelService(); ...&#125; 上面这个接口中暂时只声明了一个方法，而在Retrofit中想这样声明的一个方法就代表了一个具体的Http请求接口。Retrofit中方法上添加@GET注解就表示当前方法代表一个Get请求，我们声明的这个请求方法不带任何参数，且返回结果是User对象。@GET注解括号中的值getModelService就代表http请求地址的具体指向，这个值与下面baseUrl中配置的URL一起组成一个完整的请求地址Retrofit就是这么任性，它可以帮我们把http的请求结果自动转换成Javabean对象，这将为我们减少不少编码工作。 构造Retrofit对象接口服务声明完成之后，我们接着需要新建一个Retrofit对象12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://localhost:8080/AndroidService/\") .addConverterFactory(GsonConverterFactory.create()) .build();RetrofitService service = retrofit.create(RetrofitService.class); 通过上面的代码我们就创建了一个Retrofit对象，同时通过这个Retrofit对象将我们前面声明的服务接口进行了实例化，有了这个服务接口实例化对象，我们就可以调用接口里面声明的方法进行http请求了。 另外需要说明是我们在设置baseUrl的时候一般在都是以/结尾，而不是在接口方法中的url以/开头 前面说的Retrofit会将请求结果自动转换成Javabean对象，其实这个是需要配置结果转换器的，就像上面我配置的addConverterFactory(GsonConverterFactory.create())，配置了这个转换器工厂之后，就会将请求得到的JSON数据自动转换成Javabean对象。同样如果请求得到的数据是xml类型的话，转换成Javabean对象则需要配置成其他类型的转换器 Retrofit其实已经为我们提供了多种转换器供我们选择： Gson: com.squareup.retrofit2:converter-gsonJackson: com.squareup.retrofit2:converter-jacksonMoshi: com.squareup.retrofit2:converter-moshiProtobuf: com.squareup.retrofit2:converter-protobufWire: com.squareup.retrofit2:converter-wireSimple XML: com.squareup.retrofit2:converter-simplexmlScalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars 同步请求前面准备工作都完成了，ok，可以开始发起请求了12345Call&lt;User&gt; call = service.getModelServiceSync();Response&lt;User&gt; response = call.execute();if(response.isSuccessful()) &#123; User user = response.body();&#125; 这就是Retrofit的基本使用流程：添加依赖–&gt;声明接口–&gt;创建Retrofit和接口对象–&gt;选择执行同步异步请求 异步请求同步请求执行call.execute()即可，异步请求则是这样：12345678910111213call.enqueue(new Callback&lt;User&gt;() &#123; @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) &#123; if(response.isSuccessful()) &#123; User user = response.body(); &#125; &#125; @Override public void onFailure(Call&lt;User&gt; call, Throwable t) &#123; &#125;&#125;); 带参Get请求如果要实现带参数的Get请求，则需要将我们上面的方法声明改成如下形式12@GET(\"getModelService\")Call&lt;User&gt; getModelService(@Query(\"param1\") boolean param1, @Query(\"param2\") boolean param2); Retrofit中我们只需要将要传输到服务端的参数添加@Query注解即可，而@Query注解括号中的值param1和param2则是对应的参数名 Retrofit也为我们提供了另外一种形式，使用@QueryMap注解来声明一个集合作为请求参数12@GET(\"getModelService\")Call&lt;User&gt; getModelService(@QueryMap Map&lt;String, String&gt; parmas); 动态URL如果我们有两个这样的请求地址12http://localhost:8080/AndroidService/user/zhangsanhttp://localhost:8080/AndroidService/user/lisi 这两个请求地址很明显，除了最后的一段不一样其他的都一样。因此如果按照上面的做法的话，我们要请求这两个服务就需要声明两个接口方法，如果这两个请求地址没有其他参数的话声明两个接口方法不是感觉很累赘，所以Retrofit为我们提供了动态构造URL的方式来声明类似请求地址的接口方法。12@GET(\"user/&#123;path&#125;\")Call&lt;User&gt; getModelService(@Path(path) String path, @Query(\"param1\") boolean param1, @Query(\"param2\") boolean param2); 上面的方法中，@GET注解中{path}就代表URL可以动态变化的那一部分，@Path注解则表示该方法参数的值就是{path}中的动态值 Post请求123@FormUrlEncoded@POST(\"postService\")Call&lt;String&gt; postModelService(@Field(\"msg\") String msg, @Field(\"string\") boolean isString); Retrofit中的Post请求则需要将前面的@GET注解换成@POST注解，而Post请求的文本参数则用注解@Field来声明，同时还必须给方法添加注解@FormUrlEncoded来告知Retrofit参数为表单参数，如果只为参数增加@Field注解，而不给方法添加@FormUrlEncoded注解运行时会抛异常。 如果Post请求有很多参数同样也可以使用集合的方式进行声明123@FormUrlEncoded@POST(\"&#123;path&#125;\")Call&lt;User&gt; postModelService(@Path(\"path\") String path, @FieldMap Map&lt;String, String&gt; map); Retrofit中提供了注解@FieldMap用来声明一个Map类型的集合作为Post请求的表单参数 Post请求的服务接口声明完成之后，讲得到的Call对象调用execute或者enqueue即可发起同步或异步的Post请求 以上就是Retrofit2的基本使用，下一篇文章我讲接着介绍Retrofit2中的文件上传和文件下载，以及如何实现文件上传和下载过程中的进度条","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Retrofit","slug":"Retrofit","permalink":"http://ittiger.cn/tags/Retrofit/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"让RecyclerView更通用","slug":"让RecyclerView更通用","date":"2016-07-27T13:48:15.000Z","updated":"2016-08-04T07:50:08.198Z","comments":true,"path":"让RecyclerView更通用.html","link":"","permalink":"http://ittiger.cn/让RecyclerView更通用.html","excerpt":"何为通用用过RecyclerView的都知道它没有为我们提供像ListView中类似addHeaderView，addFooterView，setOnItemClickListener，setOnItemLongClickListener的接口，另外还有底部自动加载更多，这些都是列表使用中很常见的功能，所以如果我们使用RecyclerView来实现列表的话就需要自己实现这些功能。本文主要介绍这些通用功能的实现方式，使得RecyclerView使用起来和ListView一样方便。","text":"何为通用用过RecyclerView的都知道它没有为我们提供像ListView中类似addHeaderView，addFooterView，setOnItemClickListener，setOnItemLongClickListener的接口，另外还有底部自动加载更多，这些都是列表使用中很常见的功能，所以如果我们使用RecyclerView来实现列表的话就需要自己实现这些功能。本文主要介绍这些通用功能的实现方式，使得RecyclerView使用起来和ListView一样方便。 点击事件setOnItemClickListener，setOnItemLongClickListenerRecyclerView中虽然没有提供上面这两个接口，但是给我们提供了另外一个接口：OnItemTouchListener看这个接口的文档描述我们知道此接口可以对RecyclerView中的手势进行监听处理，因此我们可以采用OnItemTouchListener+GestureDetector来实现RecyclerView的OnItemClick和OnItemLongClick。实现方式也比较简单，还是上代码吧…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private OnItemClickListener mOnItemClickListener;private OnItemLongClickListener mItemLongClickListener; mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() &#123; @Override public void onLongPress(MotionEvent e) &#123; super.onLongPress(e); if(mItemLongClickListener != null) &#123; View childView = findChildViewUnder(e.getX(), e.getY()); if(childView != null) &#123; int position = getChildLayoutPosition(childView); mItemLongClickListener.onItemLongClick(position, childView); &#125; &#125; &#125; @Override public boolean onSingleTapUp(MotionEvent e) &#123; if(mOnItemClickListener != null) &#123; View childView = findChildViewUnder(e.getX(),e.getY()); if(childView != null)&#123; int position = getChildLayoutPosition(childView); mOnItemClickListener.onItemClick(position, childView); return true; &#125; &#125; return super.onSingleTapUp(e); &#125;&#125;); addOnItemTouchListener(new SimpleOnItemTouchListener() &#123; @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) &#123; if (mGestureDetector.onTouchEvent(e)) &#123;//交由手势处理 return true; &#125; return false; &#125;&#125;);/** * Item项点击事件 */public interface OnItemClickListener &#123; void onItemClick(int position, View itemView);&#125; /** * Item项长按点击事件 */public interface OnItemLongClickListener &#123; void onItemLongClick(int position, View itemView);&#125; addHeaderView，addFooterView实现原理前面写过一篇文章RecyclerView下拉刷新上拉加载 介绍过RecyclerView的上拉加载的实现方式，里面的上拉加载进度条其实也是RecyclerView的一个FooterView，其实现方式就是为LoadMoreView设置了一个特殊的ItemViewType来进行区分展示，因此我这里的HeaderView和FooterView也是通过为它们设置不同的ItemViewType来进行区分展示。 我们知道ListView中的addHeaderView和addFooterView都是可以添加多个View的，也就是说RecyclerView中也会出现添加多个完全不同的HeaderView或FooterView，所以我们必须为添加的每个HeaderView和FooterView都设置一个ItemViewType从而达到添加多个不同的HeaderView或FooterView的目的(如果所有的HeaderView或FooterView都设置同一个ItemViewType的话只能显示一种View的HeaderView或FooterView)。 实现步骤知道了实现原理，我们再来理一下实现步骤： 因为每个HeaderView或FooterView都需要对应一个ItemViewType，所以我们需要分别为它们建立一个映射关系，我采用SparseArray实现映射 我们需要在添加HeaderView或FooterView的时候生成对应的ItemViewType值，也就是我们需要定义一个ItemViewType的生成规则，我采用了基准值+视图个数的方式生成ItemViewType 自定义一个Adapter继承自RecyclerView.Adapter，重写里面的几个方法：onCreateViewHolder，onBindViewHolder，getItemViewType，getItemCount getItemCount方法中返回的数据总数显然是：HeaderView总数+FooterView总数+List列表展示的数据总数 重写onBindViewHolder，getItemViewType这两个方法时，显然需要根据position判断当前位置是否为HeaderView或是FooterView，而根据展示顺序来看当0&lt;=position&lt;HeaderView总数 时是HeaderView，而当position&gt;=(HeaderView总数+List总数)时则是FooterView，其余位置则是List数据对应的View 而重写onCreateViewHolder方法时，则可用直接根据其方法参数viewType在SparseArray映射中查找是否存在该类型的HeaderView或是FooterView，有则返回，没有则返回List数据展示的View关键代码分析完实现的步骤开始撸代码，下面是我实现的关键代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//HeaderView的ItemViewType的生成基准值，生成规则为基准值+当前HeaderView的个数private static final int TYPE_HEADER = 100000;//FooterView的ItemViewType的生成基准值，生成规则为基准值+当前的FooterView的个数private static final int TYPE_FOOTER = 200000; //存储HeaderView，key值作为对应HeaderView的ItemViewTypeprivate SparseArray&lt;View&gt; mHeaderViews = new SparseArray&lt;&gt;(0);//存储FooterView，key值作为对应HeaderView的ItemViewTypeprivate SparseArray&lt;View&gt; mFooterViews = new SparseArray&lt;&gt;(0); @Overridepublic final ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if(isHeaderViewEnable() &amp;&amp; mHeaderViews.get(viewType) != null) &#123; return new ViewHolder(mHeaderViews.get(viewType)); &#125; else if(isFooterViewEnable() &amp;&amp; mFooterViews.get(viewType) != null) &#123; return new ViewHolder(mFooterViews.get(viewType)); &#125; return onCreateItemViewHolder(parent, viewType);&#125; @Overridepublic final void onBindViewHolder(ViewHolder holder, int position) &#123; if(isFooterView(position) || isHeaderView(position)) &#123; return; &#125; T item = getItem(position - getHeaderViewCount()); onBindItemViewHolder(holder, position, item);&#125; @Overridepublic final int getItemViewType(int position) &#123; if(isHeaderView(position)) &#123;//FooterView return mHeaderViews.keyAt(position); &#125; if(isFooterView(position))&#123;//HeaderView return mFooterViews.keyAt(position - getHeaderViewCount() - getItemDataCount()); &#125; return getItemViewTypeForData(position);&#125; /*** 展示的总数据数(包括HeaderView和FooterView)** @return*/@Overridepublic final int getItemCount() &#123; //从写此方法，数据总数需要包括HeaderView总数和FooterView总数 return getItemDataCount() + getHeaderViewCount() + getFooterViewCount();&#125; /*** 要展示的有效数据数(不包括HeaderView和FooterView)** @return*/public int getItemDataCount() &#123; return mList == null ? 0 : mList.size();&#125; /*** 获取HeaderView的总数** @return*/public int getHeaderViewCount() &#123; return isHeaderViewEnable() ? mHeaderViews.size() : 0;&#125; /*** 获取FooterView的总数** @return*/public int getFooterViewCount() &#123; return isFooterViewEnable() ? mFooterViews.size() : 0;&#125;/*** 判断position位置是否为FooterView** @param position* @return*/public boolean isFooterView(int position) &#123; return isFooterViewEnable() &amp;&amp; isFooterViewPosition(position);&#125; /*** 判断position位置是否为HeaderView** @param position* @return*/public boolean isHeaderView(int position) &#123; return isHeaderViewEnable() &amp;&amp; isHeaderViewPosition(position);&#125; /*** 判断position位置是否为FooterView的索引** @param position* @return*/public boolean isFooterViewPosition(int position) &#123; return position &gt;= getItemDataCount() + getHeaderViewCount();&#125; /*** 判断position位置是否为HeaderView的索引** @param position* @return*/public boolean isHeaderViewPosition(int position) &#123; return position &lt; getHeaderViewCount();&#125; /** * 添加一个HeaderView * * @param headerView */public void addHeaderView(View headerView) &#123; if(headerView == null) &#123; throw new NullPointerException(\"headerView is null\"); &#125; mHeaderViews.put(TYPE_HEADER + getHeaderViewCount(), headerView); notifyItemInserted(getHeaderViewCount() - 1);&#125; /** * 添加一个FooterView * * @param footerView */public void addFooterView(View footerView) &#123; if(footerView == null) &#123; throw new NullPointerException(\"footerView is null\"); &#125; mFooterViews.put(TYPE_FOOTER + getFooterViewCount(), footerView); notifyItemInserted(getHeaderViewCount() + getItemDataCount() + getFooterViewCount() - 1);&#125; RecyclerView使用注意 这里需要注明一点RecyclerView使用中的坑，如果RecyclerView为LinearLayoutManager时在onCreatViewHolder中生成的View都必须关联上其parent，也就是关联到RecyclerView本身。我前面的一片文章记录了我遇到的这个问题RecyclerView子View宽度不充满父容器，所以在addHeaderView和addFooterView时也需要注意这个问题 如果你的RecyclerView的LayoutManager是GridLayoutManager或StaggeredGridLayoutManager时，如果就这样添加HeaderView或FooterView，会发现HeaderView或FooterView不会独立的占据一行。这是因为设置了SpanSize的缘故，所以我们需要针对这两种LayoutManager进行处理，处理方式如下： 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void onAttachedToRecyclerView(RecyclerView recyclerView) &#123; super.onAttachedToRecyclerView(recyclerView); final RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if(layoutManager instanceof GridLayoutManager) &#123; ((GridLayoutManager) layoutManager).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() &#123; @Override public int getSpanSize(int position) &#123; return getNewSpanSize(((GridLayoutManager) layoutManager).getSpanCount(), position); &#125; &#125;); &#125;&#125; @Overridepublic void onViewAttachedToWindow(ViewHolder holder) &#123; super.onViewAttachedToWindow(holder); int position = holder.getLayoutPosition(); if(isHeaderView(position) || isFooterView(position)) &#123; final ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null &amp;&amp; layoutParams instanceof StaggeredGridLayoutManager.LayoutParams) &#123; StaggeredGridLayoutManager.LayoutParams lp = (StaggeredGridLayoutManager.LayoutParams) layoutParams; lp.setFullSpan(true); &#125; &#125;&#125; private int getNewSpanSize(int spanCount, int position) &#123; if(isHeaderView(position) || isFooterView(position)) &#123; return spanCount; &#125; return 1;&#125; 自动加载更多自动加载更多也是列表显示中比较常见的一个功能，我们可以为RecyclerView设置ScrollListener监听来进行实现，具体实现的关键代码如下；123456789101112131415161718192021222324252627super.setOnScrollListener(new OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if(newState == SCROLL_STATE_IDLE &amp;&amp; mIsAutoLoadMore &amp;&amp; mLoadMoreListener != null) &#123; if(mLastVisiblePosition + 1 == getAdapter().getItemCount()) &#123; mLoadMoreListener.onLoadMore(); &#125; &#125; if(mOnScrollListener != null) &#123; mOnScrollListener.onScrollStateChanged(recyclerView, newState); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); if(mIsAutoLoadMore &amp;&amp; mLoadMoreListener != null) &#123; mLastVisiblePosition = getLastVisiblePosition(); &#125; if(mOnScrollListener != null) &#123; mOnScrollListener.onScrolled(recyclerView, dx, dy); &#125; &#125;&#125;); 文章相关的完整代码和Demo：https://github.com/huyongli/AndroidDemo","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://ittiger.cn/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"RecyclerView子View宽度不充满父容器","slug":"RecyclerView子View宽度不充满父容器","date":"2016-07-23T13:45:10.000Z","updated":"2017-02-28T03:04:29.662Z","comments":true,"path":"RecyclerView子View宽度不充满父容器.html","link":"","permalink":"http://ittiger.cn/RecyclerView子View宽度不充满父容器.html","excerpt":"今天用RecyclerView写了简单的例子，使用的是LinearLyaoutManager，子View采用的TextView，准备写个简单的List展示，我的RecyclerView和TextView的宽度布局都采用的是match_parent，结果显示出来之后发现子View的宽度压根就没有充满屏幕。之前也用过RecyclerView，但是没有遇到过这个问题，很不解啊~~~网上查阅之后说是在Adapter的onCreateViewHolder方法中构造View的时候不能用如下方式：1View.inflate(mContext, R.layout.item_layout, null); 必须要换成下面的构造方式把parent带进去：1LayoutInflater.from(mContext).inflate(R.layout.item_layout, parent, false); 而我的Adapter中刚好就使用的是第一种方式，于是立马换成下面的第二种方式实现，运行看效果，果然充满了屏幕~~~这个问题还真是奇葩啊~","text":"今天用RecyclerView写了简单的例子，使用的是LinearLyaoutManager，子View采用的TextView，准备写个简单的List展示，我的RecyclerView和TextView的宽度布局都采用的是match_parent，结果显示出来之后发现子View的宽度压根就没有充满屏幕。之前也用过RecyclerView，但是没有遇到过这个问题，很不解啊~~~网上查阅之后说是在Adapter的onCreateViewHolder方法中构造View的时候不能用如下方式：1View.inflate(mContext, R.layout.item_layout, null); 必须要换成下面的构造方式把parent带进去：1LayoutInflater.from(mContext).inflate(R.layout.item_layout, parent, false); 而我的Adapter中刚好就使用的是第一种方式，于是立马换成下面的第二种方式实现，运行看效果，果然充满了屏幕~~~这个问题还真是奇葩啊~","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://ittiger.cn/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"RecyclerView下拉刷新上拉加载","slug":"RecyclerView下拉刷新上拉加载","date":"2016-06-29T13:37:10.000Z","updated":"2016-08-04T07:50:08.082Z","comments":true,"path":"RecyclerView下拉刷新上拉加载.html","link":"","permalink":"http://ittiger.cn/RecyclerView下拉刷新上拉加载.html","excerpt":"背景作为ListView和GridView的替代者， RecyclerView以它的灵活性著称，而且有着更好更完善的缓存处理机制。但是在使用RecyclerVew的过程中有个很明显的问题：RecyclerView没有为开发者提供addHeadView和addFooterView两个接口，这就为RecyclerView的下拉刷新和上拉加载实现增加了难度，本文就为大家介绍RecyclerView的下拉刷新和上拉加载的实现方式。","text":"背景作为ListView和GridView的替代者， RecyclerView以它的灵活性著称，而且有着更好更完善的缓存处理机制。但是在使用RecyclerVew的过程中有个很明显的问题：RecyclerView没有为开发者提供addHeadView和addFooterView两个接口，这就为RecyclerView的下拉刷新和上拉加载实现增加了难度，本文就为大家介绍RecyclerView的下拉刷新和上拉加载的实现方式。 下拉刷新其实RecyclerView的下拉刷新使用SwipeRefreshLayout组件实现还是非常简单的。 SwipeRefreshLayout也是Android SDK中为我们提供的一个布局容器类，它作为容器可以为它的子元素提供下拉刷新接口，而且使用方式也非常简单，我就直接上代码了123456789101112&lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/swipeRefreshLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 这就是RecyclerView结合SwipeRefreshLayout实现下拉刷新的布局方式，非常简单吧，写完布局文件之后，当然还要处理刷新的逻辑123456mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; //在此处实现刷新获取数据，然后更新RecyclerView的数据源即可 &#125;&#125;); 写完这两段代码之后，RecyclerView的下拉刷新就实现完成了，是不是很简单。不过还有个小小的问题需要注意下，那就是在刷新获取数据处理逻辑结束之后需要调用1mSwipeRefreshLayout.setRefreshing(false); 这个接口就是告诉SwipRefreshLayout刷新动作已经结束，刷新进度条可以不用再显示了，否则的话视图顶部的刷新进度条会一直存在，当然如果你手动调用1mSwipeRefreshLayout.setRefreshing(true); 这个接口的话，刷新进度条就会显示出来。 上拉加载由于RecyclerView中没有提供addFooterView接口，所以我们没有办法像ListView中那样直接添加一个FooterView作为上拉加载的视图。但是RecyclerView.Adapter中也提供了public int getItemViewType(int position)接口，我们可以为RecyclerView.Adapter指定两种ViewType，一个作为普通的ItemViewType用来显示普通数据视图，一个作为FooterViewType用来显示上拉加载视图，这样的话我们就需要在展示数据的基础上为RecyclerView.Adapter额外增加一条数据用来显示添加的FooterView，这个特定Adapter的实现逻辑如下： 定义两个ViewType分表用来区分普通是数据视图和上拉加载视图 12private static final int VIEW_TYPE_FOOTER = 0;private static final int VIEW_TYPE_ITEM = 1; 重写getItemCount()方法，在原有数据的基础上增加一条数据用来显示FooterView 12345@Overridepublic int getItemCount() &#123; return mList.size() + 1;//在原有数据的基础增加一个数据用来显示FooterView&#125; 重写getItemViewType(int position)方法，用来判断当前加载显示何种视图 12345678@Overridepublic int getItemViewType(int position) &#123; if(position + 1 == getItemCount()) &#123;//最后一条数据显示FooterView return VIEW_TYPE_FOOTER; &#125; return VIEW_TYPE_ITEM;&#125; 在onCreateViewHolder方法中根据viewType初始化对应的视图 12345678910@Overridepublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if(viewType == VIEW_TYPE_FOOTER) &#123; return onCreateFooterViewHolder(parent, viewType); &#125; else if(viewType == VIEW_TYPE_ITEM) &#123; return onCreateItemViewHolder(parent, viewType); &#125; return null;&#125; 在onBindViewHolder方法中根据viewType绑定显示对应的视图数据 1234567891011121314@Overridepublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; switch (getItemViewType(position)) &#123; case VIEW_TYPE_ITEM: onBindItemViewHolder(holder, position); break; case VIEW_TYPE_FOOTER: onBindFooterViewHolder(holder, position, mLoadStatus); break; default: break; &#125;&#125; 整个Adapter完整的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class DemoAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; private LoadStatus mLoadStatus = LoadStatus.CLICK_LOAD_MORE;//上拉加载的状态 private static final int VIEW_TYPE_FOOTER = 0; private static final int VIEW_TYPE_ITEM = 1; private List&lt;String&gt; mList; private Context mContext; public DemoAdapter(Context context, List&lt;String&gt; list) &#123; mContext = context; mList = list; &#125; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; if(viewType == VIEW_TYPE_FOOTER) &#123; return onCreateFooterViewHolder(parent, viewType); &#125; else if(viewType == VIEW_TYPE_ITEM) &#123; return onCreateItemViewHolder(parent, viewType); &#125; return null; &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; switch (getItemViewType(position)) &#123; case VIEW_TYPE_ITEM: onBindItemViewHolder(holder, position); break; case VIEW_TYPE_FOOTER: onBindFooterViewHolder(holder, position, mLoadStatus); break; default: break; &#125; &#125; public RecyclerView.ViewHolder onCreateFooterViewHolder(ViewGroup parent, int viewType) &#123; View view = View.inflate(mContext, R.layout.footer_layout, null); return new FooterViewHolder(view); &#125; public RecyclerView.ViewHolder onCreateItemViewHolder(ViewGroup parent, int viewType) &#123; View view = View.inflate(mContext, R.layout.item_layout, null); return new ItemViewHolder(view); &#125; public void onBindFooterViewHolder(RecyclerView.ViewHolder holder, int position, LoadStatus loadStatus) &#123; FooterViewHolder viewHolder = (FooterViewHolder) holder; switch (loadStatus) &#123; case CLICK_LOAD_MORE: viewHolder.mLoadingLayout.setVisibility(View.GONE); viewHolder.mClickLoad.setVisibility(View.VISIBLE); break; case LOADING_MORE: viewHolder.mLoadingLayout.setVisibility(View.VISIBLE); viewHolder.mClickLoad.setVisibility(View.GONE); break; &#125; &#125; public void onBindItemViewHolder(RecyclerView.ViewHolder holder, int position) &#123; ItemViewHolder viewHolder = (ItemViewHolder) holder; viewHolder.mTextView.setText(getItem(position)); &#125; @Override public int getItemCount() &#123; return mList.size() + 1; &#125; public String getItem(int position) &#123; return mList.get(position); &#125; public void addAll(List&lt;String&gt; list) &#123; this.mList.addAll(list); notifyDataSetChanged(); &#125; @Override public int getItemViewType(int position) &#123; if(position + 1 == getItemCount()) &#123;//最后一条为FooterView return VIEW_TYPE_FOOTER; &#125; return VIEW_TYPE_ITEM; &#125; public void reSetData(List&lt;String&gt; list) &#123; this.mList = list; notifyDataSetChanged(); &#125; public void setLoadStatus(LoadStatus loadStatus) &#123; this.mLoadStatus = loadStatus; &#125;&#125;public class ItemViewHolder extends RecyclerView.ViewHolder &#123; public TextView mTextView; public ItemViewHolder(View itemView) &#123; super(itemView); mTextView = (TextView) itemView.findViewById(R.id.textView); &#125;&#125;public class FooterViewHolder extends RecyclerView.ViewHolder &#123; public LinearLayout mLoadingLayout; public TextView mClickLoad; public FooterViewHolder(View itemView) &#123; super(itemView); mLoadingLayout = (LinearLayout) itemView.findViewById(R.id.loading); mClickLoad = (TextView) itemView.findViewById(R.id.click_load_txt); mClickLoad.setOnClickListener(new View.OnClickListener() &#123;//添加点击加载更多监听 @Override public void onClick(View v) &#123; loadMore(); &#125; &#125;); &#125;&#125;public enum LoadStatus &#123; CLICK_LOAD_MORE,//点击加载更多 LOADING_MORE//正在加载更多&#125; FooterView的布局如下：1234567891011121314151617181920212223242526272829303132&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:gravity=\"center_horizontal\" android:orientation=\"horizontal\"&gt; &lt;LinearLayout android:id=\"@+id/loading\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;ProgressBar android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:gravity=\"center_vertical\" android:text=\"正在加载...\"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/click_load_txt\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingTop=\"5dp\" android:paddingBottom=\"5dp\" android:text=\"点击加载更多\" android:visibility=\"gone\"/&gt;&lt;/RelativeLayout&gt; 写完Adapter的FooterView视图适配之后，我们还有一个重要的步骤需要做，在哪里实现加载更多的逻辑处理 其实RecyclerView也为我们提供了mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() )接口，这样我们就看一看通过这个接口来判断什么时候调用加载更多的实现接口，关键代码如下：12345678910111213141516171819mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + 1 == mAdapter.getItemCount()) &#123; loadMore(); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); mLastVisibleItemPosition = mLayoutManager.findLastVisibleItemPosition(); &#125;&#125;); 整个Demo的Activity的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MainActivity extends AppCompatActivity &#123; private RecyclerView mRecyclerView; private SwipeRefreshLayout mSwipeRefreshLayout; private DemoAdapter mAdapter; private int mLastVisibleItemPosition = 0; private LinearLayoutManager mLayoutManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView); mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipeRefreshLayout);mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mAdapter = new DemoAdapter(this, getData(\"init\")); mRecyclerView.setAdapter(mAdapter); mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); final List&lt;String&gt; list = getData(\"refresh\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mAdapter.reSetData(list); mSwipeRefreshLayout.setRefreshing(false); &#125; &#125;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; &#125;); mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() &#123; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + 1 == mAdapter.getItemCount()) &#123; loadMore(); &#125; &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; super.onScrolled(recyclerView, dx, dy); mLastVisibleItemPosition = mLayoutManager.findLastVisibleItemPosition(); &#125; &#125;); &#125; public void loadMore() &#123; mAdapter.setLoadStatus(LoadStatus.LOADING_MORE); new Thread() &#123; @Override public void run() &#123; try &#123; Thread.sleep(3000); final List&lt;String&gt; list = getData(\"load more\"); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; mAdapter.addAll(list); mAdapter.setLoadStatus(LoadStatus.CLICK_LOAD_MORE); &#125; &#125;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; public List&lt;String&gt; getData(String flag) &#123; int idx = 1; if(mAdapter != null) &#123; idx = mAdapter.getItemCount(); &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(10); for(int i = 0; i &lt; 10; i++) &#123; list.add(flag + \":\" + (idx + i)); &#125; return list; &#125;&#125; 以上就是我针对RecyclerView的下拉刷新上拉加载的实现方式。","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://ittiger.cn/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"AndroidStudio使用技巧","slug":"AndroidStudio使用技巧","date":"2016-06-24T12:14:18.000Z","updated":"2016-08-04T07:50:08.075Z","comments":true,"path":"AndroidStudio使用技巧.html","link":"","permalink":"http://ittiger.cn/AndroidStudio使用技巧.html","excerpt":"AndroidStudio使用技巧本文主要是记录从我使用AndroidStudio以来遇到的一些问题和一些技巧。 初次使用AndroidStudio，第一次创建Android工程编译时会比较慢，这中间涉及到三个过程： 可能会去下载最新的SDK，所以在创建工程之前可以先将SDK更新完成 AndroidStudio工程会使用gradle构建，因此会联网下载gradle，这个过程比较慢要耐心等待 下载工程中的一些依赖包，比如junit 有时候使用AndroidStudio进行rebuild和clean时，会报错如下：Failed to complete gradle execution cause by...，一般此错误可以通过设置gradle的VM参数解决： -Xmx256m(设置方式为：File &gt; Setting &gt; Gradle &gt; Gradle Vm Option)，如果此方法无效，可以选择直接升级AS的版本到最新版本再试，还有其他可能的原因是工程JDK版本与AS设置的JDK版本不同 设置AndroidStudio的不同主题背景： File &gt; Setting &gt; Appearance&amp;Behavior &gt; Appearance 下的Theme可以选择你要使用的主题","text":"AndroidStudio使用技巧本文主要是记录从我使用AndroidStudio以来遇到的一些问题和一些技巧。 初次使用AndroidStudio，第一次创建Android工程编译时会比较慢，这中间涉及到三个过程： 可能会去下载最新的SDK，所以在创建工程之前可以先将SDK更新完成 AndroidStudio工程会使用gradle构建，因此会联网下载gradle，这个过程比较慢要耐心等待 下载工程中的一些依赖包，比如junit 有时候使用AndroidStudio进行rebuild和clean时，会报错如下：Failed to complete gradle execution cause by...，一般此错误可以通过设置gradle的VM参数解决： -Xmx256m(设置方式为：File &gt; Setting &gt; Gradle &gt; Gradle Vm Option)，如果此方法无效，可以选择直接升级AS的版本到最新版本再试，还有其他可能的原因是工程JDK版本与AS设置的JDK版本不同 设置AndroidStudio的不同主题背景： File &gt; Setting &gt; Appearance&amp;Behavior &gt; Appearance 下的Theme可以选择你要使用的主题 设置编辑区的字体和字体大小:File &gt; Setting &gt; Editor &gt; Color&amp;Fonts &gt; Font,在右边需要先将主题另存之后，再去编辑字体和大小 自定义AS的Logcat里不同级别的日志文字的颜色:File &gt; Setting &gt; Editor &gt; Color&amp;Fonts &gt; Android Logcat,同样需要先另存当前主题之后才能自定义给个级别的日志文字颜色 鼠标移动到某个变量和类上面显示提示信息的设置：File &gt; Setting &gt; Editor &gt; 点击下面的General,在右边选中Show quick doc on mouse move Delay 设置代码行号一直显示而不是重启后又不显示了：File &gt; Setting &gt; Editor &gt; General &gt; Appearance,在右边选中Show Line numbers 快速按Shift键两次，调出文件全局搜索对话框(根据文件名搜索)，可以搜索Java文件和资源文件 Ctrl+H 全局文本搜索快捷键，可以搜索全部文本内容，包括资源文件 Ctrl+T：打开某个方法的实现类，打开某个id的资源文件 工程中设置使用本地安装的gradle进行构建，而不是联网下载gradle最新版本： 打开android-studio/plugins/android/lib/templates/gradle/wrapper/gradle/wrapper/gradle-wrapper.properties，修改distributionUrl=file\\:/home/zzq/.gradle/distribution/gradle-2.2.1-all.zip AndroidStudio启动时默认直接就打开了上次打开的工程，没有像第一次启动那样可以选择，此问题可以这样解决：File &gt; Setting &gt; Appearance &amp; Behavior &gt; System Settings下将Reopen last project on startup的选择取消掉，设置为非选中状态即可 支持驼峰命令选择File &gt; Setting &gt; Editor &gt; General &gt; Smart Keys，在右边选择Use &quot;CamelHumps&quot; words，此时如果仍然希望当鼠标在单词上双击之后选中整个单词，需要如下设置：File &gt; Setting &gt; Editor &gt; General，在右边取消选中 Honor &quot;CamelHumps&quot; words settings when selecting on double click 给代码的变量名添加前缀，如非静态成员变量以’m’开头，请如下设置：File &gt; Setting &gt; Editor &gt; Code Style &gt; Java，在右边选择Code Generation，然后给要配置的相关字的添加前缀 File &gt; Setting &gt; Appearance&amp;Behavior &gt;SystemSetting &gt; HttpProxy下设置代理不起作用时，可以在工程目录下的gradle.properties文件中添加代理设置即可： systemProp.http.proxyHost=ip地址 systemProp.http.proxyPort=端口 systemProp.https.proxyHost=ip地址 systemProp.https.proxyPort=端口 AS创建Module时，在资源目录res下只生成了mipmap等资源文件夹，此文件夹主要是用来存放应用启动图标的，其他的图片资源文件还是应该放在drawable等文件夹中。为了在创建Module时同时也生成对应的drawable文件夹，只需要做如下配置： 进入Android Studio的安装目录 依次进入plugins/android/lib/templates/gradle-projects/NewAndroidModule 用边界器打开recipe.xml.ftl文件，在&lt;mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable&quot; /&gt;下方依次加入下面三行配置： mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-hdpi&quot; mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-xhdpi&quot; mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-xxhdpi&quot; 通过类似的方式还可以在colors.xml文件中生成常用颜色 在build.gralde中生成自定义配置 在.gitignore文件中生成自定义忽略文件配置 配置代码模板， Android Studio中提供了很多方便的活动模板(Live Templates)，例如：输入sout后按enter键，Android Studio会自动帮我们写入System.out.println();其实sout就是AS自带的一个活动模板： 先打开：File &gt; Setting &gt; Editor &gt; Live Templates 点击最右侧的加号并选择Template Group 在弹出的对话框中输入一个活动模板分组的名称，如:custom 在左侧选中上一步创建的custom分组，点击右边的加号 选择Live Template，在Abbreviation中对输入模板简写方式，如：sout 在Description中输入这个活动模板的描述 在Template Text中输入模板代码，如：System.out.println(); 点击下方的Define按钮，选中Java表示这个模板用于Java代码 点击右侧的Edit variables 选择Expression下拉框中的className并勾选Skip if... 这个操作的作用是AS会自动将我们在上一步中用&#39;$&#39;符包裹的className自动替换为当前类不含包含的类名 点击Apply和ok让设置生效 至此，我们自定义的custom模板组中的psh活动模板就自定义完成 Android Studio添加本地jar包依赖，在Module的build.gradle文件中进行如下方式配置 compile files(&#39;libs/TigerDB.jar&#39;)添加某个单一jar包的依赖 compile fileTree(dir: &#39;libs&#39;,include: [&#39;*.jar&#39;]) 将libs目录下的jar包全部添加为依赖 持续更新…","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://ittiger.cn/tags/AndroidStudio/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"UC浏览器首页滑动动画实现","slug":"UC浏览器首页滑动动画实现","date":"2016-05-26T12:58:03.000Z","updated":"2016-08-04T07:50:08.117Z","comments":true,"path":"UC浏览器首页滑动动画实现.html","link":"","permalink":"http://ittiger.cn/UC浏览器首页滑动动画实现.html","excerpt":"实现效果","text":"实现效果 UC浏览器首页效果我们先来看下UC浏览器首页的滑动动画和我最终实现的动画效果 使用方式123456789101112131415161718&lt;cn.ittiger.ucpage.view.UCIndexView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:ucindexview=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/ucindexview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" ucindexview:pageHeadViewHeight=\"@dimen/dp_40\" ucindexview:isPageHeadViewFixed=\"false\" ucindexview:isContentHeadViewEnable=\"true\" ucindexview:isPullRestoreEnable=\"false\" ucindexview:contentHeadViewHeight=\"@dimen/dp_40\" ucindexview:pageNavigationViewHeight=\"@dimen/dp_200\" ucindexview:pageHeadViewLayoutId=\"@layout/page_head_view_layout\" ucindexview:pageNavigationViewLayoutId=\"@layout/page_navigation_view_layout\" ucindexview:contentHeadViewLayoutId=\"@layout/content_head_view_layout\" ucindexview:contentViewLayoutId=\"@layout/content_view_layout\"&gt; &lt;/cn.ittiger.ucpage.view.UCIndexView&gt; 使用方式只需要如此布局即可，没有其他的任何代码操作，非常简单。几个重要属性如下： isPageHeadViewFixed：设置PageHeadView是否固定显示(效果如上图2) isContentHeadViewEnable：设置ContentHeadView是否启用(效果如上图3) isPullRestoreEnable：设置是否可以通过下拉手势恢复到初始状态，UC首页下拉不能恢复初始状态 contentHeadViewHeight：设置contentHeadView视图的高度 pageNavigationViewHeight：设置PageNavigationView视图的高度 pageHeadViewLayoutId：设置PagetHeadView视图的内容布局，如图中的文字UC头条布局 pageNavigationViewLayoutId：设置PageNavigationView视图的内容布局，如图中的文字网址导航布局 contentHeadViewLayoutId：设置ContentHeadViev视图的内容布局，如图中的文字新闻头部导航布局 contentViewLayoutId：设置ContentView视图的内容布局，如图中的文字新闻内容区布局 github地址实现及Demo地址：https://github.com/huyongli/UCIndexAnimation 实现过程下面来讲讲我的实现过程： 首先来分析下UC首页这个动画中涉及到的元素和要点 向上滑动过程顶部的UC头条会慢慢的显示出来，我把这部分视图称为：PageHeadView(页面头部视图)，很明显其初始化时是在屏幕外部的 向上滑动过程中UC漫站上面会有个新闻Tab菜单头部慢慢的显示出来，我把这部分视图称为：ContentHeadView(新闻头部视图)，初始时是被ContentView遮盖，而后慢慢滑出，显然它的滑动速度是比ContentView快的 向上滑动过程中天气、搜索、网站导航会稍微往上滑动一段距离最终隐藏，我把这部分视图称为：PageNavigationView(页面导航视图)，随着不断的滑动，会慢慢的被其余三个视图共同遮盖掉 UC漫站整个新闻内容视图慢慢的向上滑动直至跟UC头条相接，我把这部分称为：ContentView(新闻内容视图) 根据动画效果来看，上面所说的四个不同的视图部分都是同时停止滑动，但是他们滑动的距离明显是不相同的 PageHeadView滑动的距离为其自身高度， ContentHeadView的滑动距离为其自身高度与ContentView滑动的距离之和，而其相对ContentView视图的滑动距离为其自身高度 ContentView滑动距离为其自身初始距离顶部的边距减去 PageHeadView和ContentHeadView两者的高度 PageNavigationView的滑动距离很小 上面的分析把UC首页整体划分成四个不同的View部分，另外其首页中只有ContentView、PageNavigationView两个视图会处理滑动事件实现技术点和细节根据上面的分析我们知道有三个视图是从被遮盖到显示或者是从显示到遮盖，剩下的ContentView一直是遮盖其他的视图。根据视图遮盖很容易联想到FrameLayout布局，多个FrameLayout布局叠加在一起就类似PS中的图层叠加，滑动可以看成是不同层级的FrameLayout的marginTop不断变化的过程。 实现类结构图我的实现中先要说明两点： 我把上滑称为展示状态或者叫Show状态 下滑称为恢复初始化状态或者叫Hide状态下图是我的实现类结构图： 主要类实现解析 UCIndexView：模仿UC首页的最终实现，使用时在布局文件中使用此类即可 PageHeadView、PageNavigationView、ContentView、ContentHeadView：这四个类的作用见我上面的分析 MoveView：页面四个视图的基类，主要包含滑动过程中的一些基本属性和方法 mNeedMoveHeight：视图需要滑动的距离(ContentHeadView的此属性设置为相对ContentView的滑动距离)，此属性主要用来计算各自视图在滑动过程中的步长 mShowStopMarginTop：视图进行Show操作时，当视图的marginTop值等于该值时，结束Show操作。此值用来确定上滑过程中，视图滑动结束时的位置。 mHideStopMarginTop：视图进行Hide操作时，当视图的marginTop值等于该值时，结束Hide操作。此值用来确定下滑过程中，视图滑动结束时的位置。通常此值为视图初始化成功后的marginTop值。 getMarginTop()：获取视图当前的marginTop值 updateMarginTop(flaot step)：根据当前的滑动步长更新视图的marginTop值 isHideFinish()：判断当前视图的Hide操作是否完成 isShowFinish()：判断当前视图的Show操作是否完成 getShowMoveStep(float step)：获取视图Show过程中的实际可滑动步长，有可能计算得到的滑动步长超过了视图的可滑动距离 getHideMoveStep(float step)：获取视图Hide过程中的实际可滑动步长，有可能计算得到的滑动步长超过了视图的可滑动距离 TouchMoveView：用来处理手指触摸事件从而滑动的视图基类滑动事件处理直接上代码：12345678910111213141516171819202122232425262728293031@Overridepublic void onTouchMoveEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mLastTouchY = event.getRawY(); break; case MotionEvent.ACTION_MOVE: //手指滑动过程中的滑动步长 mDelY = event.getRawY() - mLastTouchY; viewMove(mDelY, mIsPullRestoreEnable); mLastTouchY = event.getRawY(); break; case MotionEvent.ACTION_UP: int offset = 0; if(mDelY &gt; 0) &#123;//hide，下拉 if(!mIsPullRestoreEnable) &#123;//当前不允许下拉恢复 return; &#125; offset = mContentView.getHideOffset(); &#125; else &#123;//show， 上拉 offset = mContentView.getShowOffset(); &#125; if(offset &lt;= mPageHeadView.getNeedMoveHeight() / 2) &#123;//没有滑过二分之一高度 slip(-mDelY, mIsPullRestoreEnable); &#125; else &#123; slip(mDelY, mIsPullRestoreEnable); &#125; break; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 对所有视图进行滑动操作 * @param delY 当前的滑动步长 * @param isPullRestoreEnable 是否允许下拉恢复 */private void viewMove(float delY, boolean isPullRestoreEnable) &#123; float step = Math.abs(delY); //根据滑动距离的比例计算PageHeadView的滑动步长 float pageHeadViewStep = step * mPageHeadView.getNeedMoveHeight() / mContentView.getNeedMoveHeight(); //手指滑动距离作为ContentView的滑动步长 float contentViewStep = step; //ContentHeadView初始不固定显示时，其实际滑动步长为ContentView的滑动步长加上其相对ContentView的滑动步长 float contentHeadViewStep = mIsContentHeadViewEnable ? step + step * mContentHeadView.getNeedMoveHeight() / mContentView.getNeedMoveHeight() : 0; float pageNavigationViewStep = step * mPageNavigationView.getNeedMoveHeight() / mContentView.getNeedMoveHeight(); if(delY &gt; 0) &#123;//下滑 if(!isPullRestoreEnable) &#123;//当前不允许下拉恢复 return; &#125; if(!isHideFinish()) &#123;//恢复状态是否已完成 if(mIsPageHeadViewFixed == false) &#123; mPageHeadView.onHideAnimation(pageHeadViewStep); &#125; mContentView.onHideAnimation(contentViewStep); if(mIsContentHeadViewEnable) &#123; mContentHeadView.onHideAnimation(contentHeadViewStep); &#125; mPageNavigationView.onHideAnimation(pageNavigationViewStep); &#125; &#125; else &#123;//上滑 if(!isShowFinish()) &#123;//展示状态是否已完成 if(mIsPageHeadViewFixed == false) &#123;//PageHeadView没有被固定时才进行滑动 mPageHeadView.onShowAnimation(pageHeadViewStep); &#125; mContentView.onShowAnimation(contentViewStep); if(mIsContentHeadViewEnable) &#123;//ContentHeadView启用时才进行滑动 mContentHeadView.onShowAnimation(contentHeadViewStep); &#125; mPageNavigationView.onShowAnimation(pageNavigationViewStep); &#125; &#125;&#125;``` ```java/** * 手指松开屏幕后，视图自动滑动 * 每隔 mAutoSlipTimeStep 长时间滑动 mAutoSlipStep 距离 * @param delY 当前的滑动距离 * @param isPullRestoreEnable 是否允许下拉恢复 */private void slip(float delY, final boolean isPullRestoreEnable) &#123; if(delY &gt; 0) &#123;//当前滑动为向下滑动，即处于恢复状态 if(isHideFinish()) &#123;//已经恢复结束 return; &#125; postDelayed(new Runnable() &#123; @Override public void run() &#123; viewMove(mAutoSlipStep, isPullRestoreEnable); slip(mAutoSlipStep, isPullRestoreEnable);//准备下一次滑动 &#125; &#125;, mAutoSlipTimeStep); &#125; else &#123;//当前滑动为向上滑动，即处于展示状态 if(isShowFinish()) &#123;//已经展示结束 return; &#125; postDelayed(new Runnable() &#123; @Override public void run() &#123; viewMove(-mAutoSlipStep, isPullRestoreEnable); slip(-mAutoSlipStep, isPullRestoreEnable);//准备下一次滑动 &#125; &#125;, mAutoSlipTimeStep); &#125;&#125; 上面的代码中我把手指每次的滑动距离当做ContentView的滑动步长，再根据ContentView的滑动步长计算其他视图的当前滑动步长，计算具体方式可以看代码中的注释。 其实上面代码里的实现步骤还是比较清晰简单的，主要是如下几个步骤： 在MotionEvent.MOVE中先得到当前手指滑动的距离，此距离作为ContentView的此次滑动步长 根据ContentView的滑动步长计算其他三个视图的滑动步长 根据当前是上滑还是下滑，判断是否滑动结束，没有结束则按照计算得到的步长继续对View进行滑动处理 当手指松开后，在MotionEvent.UP中判断ContentView的滑动距离是否达到了PageHeadView高度的一半，从而决定是继续同方向滑动至结束还是恢复到原状态 手指松开后，最终调用slip方法开始自动循环滑动处理，直至滑动结束","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"RecyclerView绘制原理","slug":"RecyclerView绘制原理","date":"2016-05-20T12:38:28.000Z","updated":"2016-08-04T07:50:08.112Z","comments":true,"path":"RecyclerView绘制原理.html","link":"","permalink":"http://ittiger.cn/RecyclerView绘制原理.html","excerpt":"RecyclerView基本使用12345678910//首先设置RecyclerView的布局管理模式mRecyclerView.setLayoutManager(new LinearLayoutManager(this));mAdapter = new MyAdapter(getData());//设置Item项的UI装饰器mRecyclerView.addItemDecoration(new RecyclerItemDecoration(LinearLayoutManager.VERTICAL));//设置Item项的不同操作的动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());//设置数据开始装配mRecyclerView.setAdapter(mAdapter);RecyclerView原理分析","text":"RecyclerView基本使用12345678910//首先设置RecyclerView的布局管理模式mRecyclerView.setLayoutManager(new LinearLayoutManager(this));mAdapter = new MyAdapter(getData());//设置Item项的UI装饰器mRecyclerView.addItemDecoration(new RecyclerItemDecoration(LinearLayoutManager.VERTICAL));//设置Item项的不同操作的动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());//设置数据开始装配mRecyclerView.setAdapter(mAdapter);RecyclerView原理分析 Adapter数据适配RecyclerView.Adapter类中有一个很重要的属性：123//Adapter中被观察对象Observale&lt;AdapterDataObserver&gt;private final AdapterDataObservable mObservable = new AdapterDataObservable(); RecyclerView中也有一个很重要的属性12//数据观察者, AdapterDataObserver实例private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver(); 当使用recyclerView.setAdapter(data)设置数据时，会调用以下方法使得RecyclerView成为Adapter的观察者(间接)：1234567891011private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious, boolean removeAndRecycleViews) &#123; ...... if (adapter != null) &#123; //通过此处添加观察者，此时RecyclerView就会对Adapter中的数据进行观察监听 adapter.registerAdapterDataObserver(mObserver); ...... &#125; ......&#125; 通常当我们改变Adapter中的数据源时，一般都会通过调用Adapter.notifyDataSetChanged()方法来刷新列表，我们来看看这个方法的实现，看看Adapter是如何通过这个方法来刷新列表的：123public final void notifyDataSetChanged() &#123; mObservable.notifyChanged();&#125; 我们接着看AdapterDataObservable.notifyChanged()方法实现：123456//mObservers是Observable中的属性，是一个ArrayList&lt;T&gt;public void notifyChanged() &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125;&#125; 我们再来看RecyclerViewDataObserver.onChanged()方法：12345678@Overridepublic void onChanged() &#123; ...... //Adapter目前没有待更新的数据 if (!mAdapterHelper.hasPendingUpdates()) &#123; requestLayout(); &#125;&#125; 看到requestLayout()这个方法，我们就明白了，调用此方法后系统会重新measure, layout, draw，这样列表视图就会被更新。 RecyclerView.onMeasure()我们来看看RecyclerView的测量方法onMeasure：123456789101112131415161718192021222324@Overrideprotected void onMeasure(int widthSpec, int heightSpec) &#123; ...... if (mLayout.mAutoMeasure) &#123; final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //委托给LayoutManager来进行测量 mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); if (skipMeasure || mAdapter == null) &#123; return; &#125; if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); &#125; mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; dispatchLayoutStep2(); mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); ...... &#125; &#125; ......&#125; 上面onMeasure方法中mLayout变量就是我们上面设置的LinearLayoutManager实例，而LinearLayoutManager的构造函数中给变量mAutoMeasure值设置为true，因此测量时就会执行上面的代码，通过上面的方法我们可以看到此处测量分为两种： 当RecyclerView的宽高设置为match_parent或具体值的时候，skipMeasure=true，此时会只需要测量其自身的宽高就可以知道RecyclerView的大小，这时是onMeasure方法测量结束。当RecyclerView的宽高设置为wrap_content时，skipMeasure=false，onMeasure会继续执行下面的dispatchLayoutStep2()，其实就是测量RecyclerView的子视图的大小最终确定RecyclerView的实际大小，这种情况真正的测量操作都是在方法dispatchLayoutStep2()里执行的:12345678private void dispatchLayoutStep2() &#123; ...... mState.mItemCount = mAdapter.getItemCount(); // Step 2: Run layout mState.mInPreLayout = false; mLayout.onLayoutChildren(mRecycler, mState); ......&#125; 从这里也可以看出RecyclerView真正的测量是委托给LayoutManager在处理，我们看看LinearLayoutManager的onLayoutChildren方法：12345678910111213141516@Overridepublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; ...... if (mAnchorInfo.mLayoutFromEnd) &#123; ... fill(recycler, mLayoutState, state, false); ...... &#125; else &#123; ...... fill(recycler, mLayoutState, state, false); ...... &#125; ...... layoutForPredictiveAnimations(recycler, state, startOffset, endOffset); ......&#125; 很明显可以看到，最终执行了fill()方法：12345678910int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; ...... LayoutChunkResult layoutChunkResult = new LayoutChunkResult(); while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; layoutChunkResult.resetInternal(); layoutChunk(recycler, state, layoutState, layoutChunkResult); ...... &#125; ......&#125; 上面的while判断条件中remainingSpace可以理解为当前列表中是否还有多余的位置可用于添加绘制child，而layoutState.hasMore(state)则是判断当前绘制的child索引位置是否在Adapter数据范围内123boolean hasMore(RecyclerView.State state) &#123; return mCurrentPosition &gt;= 0 &amp;&amp; mCurrentPosition &lt; state.getItemCount();&#125; 再来看上面的layoutChunk()方法：1234567891011121314151617181920212223242526void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; View view = layoutState.next(recycler); ...... LayoutParams params = (LayoutParams) view.getLayoutParams(); if (layoutState.mScrapList == null) &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addView(view); &#125; else &#123; addView(view, 0); &#125; &#125; else &#123; if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) &#123; addDisappearingView(view); &#125; else &#123; addDisappearingView(view, 0); &#125; &#125; measureChildWithMargins(view, 0, 0); ...... // To calculate correct layout position, we subtract margins. layoutDecorated(view, left + params.leftMargin, top + params.topMargin, right - params.rightMargin, bottom - params.bottomMargin); ......&#125; 上面的方法中addView与addDisappearingView最终都是调用的RecyclerView的addView方法，也就是将子child添加到RecyclerView中。 我们再来看看View view = layoutState.next(recycler);这行代码的实现：1234567891011View next(RecyclerView.Recycler recycler) &#123; if (mScrapList != null) &#123; return nextViewFromScrapList(); &#125; final View view = recycler.getViewForPosition(mCurrentPosition); //获取某个位置需要展示的View mCurrentPosition += mItemDirection; //将当前绘制的child的索引下移一位，配合while循环 return view;&#125; 我们看看上面的获取position位置的view是如何获取的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758View getViewForPosition(int position, boolean dryRun) &#123; ...... ViewHolder holder = null; // 0) If there is a changed scrap, try to find from there if (mState.isPreLayout()) &#123; holder = getChangedScrapViewForPosition(position); fromScrap = holder != null; &#125; // 1) Find from scrap by position if (holder == null) &#123; holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun); ...... &#125; if (holder == null) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); ...... final int type = mAdapter.getItemViewType(offsetPosition); // 2) Find from scrap via stable ids, if exists if (mAdapter.hasStableIds()) &#123; holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); ...... &#125; //mViewCacheExtension的缓存是由开发者自己实现来控制ViewHolder的缓存策略 if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; // We are NOT sending the offsetPosition because LayoutManager does not // know it. final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); if (view != null) &#123; holder = getChildViewHolder(view); ...... &#125; &#125; if (holder == null) &#123; // fallback to recycler ...... holder = getRecycledViewPool().getRecycledView(type); ...... &#125; if (holder == null) &#123; holder = mAdapter.createViewHolder(RecyclerView.this, type); ...... &#125; &#125; ...... boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123; // do not update unless we absolutely have to. holder.mPreLayoutPosition = position; &#125; else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; ...... holder.mOwnerRecyclerView = RecyclerView.this; //此处就是调用Adapter中bindViewHolder方法 mAdapter.bindViewHolder(holder, offsetPosition); ...... &#125; ...... return holder.itemView;&#125; 将指定位置的View获取得到之后添加到RecyclerView中，紧接着再来看后面执行的measureChildWithMargins方法：12345678910111213public void measureChildWithMargins(View child, int widthUsed, int heightUsed) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //通过ItemDecorate获取offset final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child); widthUsed += insets.left + insets.right; heightUsed += insets.top + insets.bottom; final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width, canScrollHorizontally()); final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom() + lp.topMargin + lp.bottomMargin + heightUsed, lp.height, canScrollVertically()); if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123; child.measure(widthSpec, heightSpec); &#125;&#125; 该方法中调用mRecyclerView.getItemDecorInsetsForChild(child);获取child的offset，然后对child重新测量绘制：1234567891011121314Rect getItemDecorInsetsForChild(View child) &#123; ...... final int decorCount = mItemDecorations.size(); for (int i = 0; i &lt; decorCount; i++) &#123; mTempRect.set(0, 0, 0, 0); mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState); insets.left += mTempRect.left; insets.top += mTempRect.top; insets.right += mTempRect.right; insets.bottom += mTempRect.bottom; &#125; lp.mInsetsDirty = false; return insets;&#125; 这个里面的mItemDecorations就是文章开头例子中我通过mRecyclerView.addItemDecoration(new RecyclerItemDecoration(LinearLayoutManager.VERTICAL));添加的Item装饰器1234public void layoutDecorated(View child, int left, int top, int right, int bottom) &#123; final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets; child.layout(left + insets.left, top + insets.top, right - insets.right, bottom - insets.bottom);&#125; 可以看到layoutDecorated方法中直接调用了View的layout方法对child视图进行layout布局。 到此RecyclerView列表中Item项视图的measure和layout实际上已经完成。 RecyclerView.onLayout看完onMeasure方法，再来看看onLayout方法：123456789101112131415161718192021222324 @Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;&#125;void dispatchLayout() &#123; ...... mState.mIsMeasuring = false; if (mState.mLayoutStep == State.STEP_START) &#123; ...... dispatchLayoutStep2(); &#125; else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; ...... dispatchLayoutStep2(); &#125; else &#123; // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); &#125; dispatchLayoutStep3();&#125; 通过dispatchLayout方法可以看到onLayout中又执行了我们前面分析过的dispatchLayoutStep2()方法，在最后又执行了一个dispatchLayoutStep3()方法，我们再来看看这个：12345678910111213141516171819202122232425262728293031323334private void dispatchLayoutStep3() &#123; ...... if (mState.mRunSimpleAnimations) &#123; for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) &#123; ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); ...... final ItemHolderInfo animationInfo = mItemAnimator .recordPostLayoutInformation(mState, holder); ...... if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123; ...... if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123; //此处会执行动画 // run disappear animation instead of change mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; else &#123; ...... if (preInfo == null) &#123; handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); &#125; else &#123; //此方法最终调用DefaultItemAnimate的相关动画 animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing); &#125; &#125; &#125; else &#123; mViewInfoStore.addToPostLayout(holder, animationInfo); &#125; &#125; // Step 4: Process view info lists and trigger animations mViewInfoStore.process(mViewInfoProcessCallback); &#125; ......&#125; 上面的方法中调用了ItemAnimation动画类的相关方法 RecyclerView.onDraw123456789 @Overridepublic void onDraw(Canvas c) &#123; super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDraw(c, this, mState); &#125;&#125; 可以看到ItemDecoration的onDraw方法是在此处调用12345678910@Overridepublic void draw(Canvas c) &#123; super.draw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) &#123; mItemDecorations.get(i).onDrawOver(c, this, mState); &#125; ......&#125; 这个地方可以看到ItemDecoration的onDrawOver方法是在此处调用 到这里，RecyclerView使用过程中比较常用的几个类(LayoutManager, ItemDecoration, ItemAnimation)的主要作用及使用场景有了个大概的了解。 在RecyclerView中是没有为我们内置Item的单击和长按事件监听接口的，一般为Item设置单击和长按监听都是是直接在Adapter初始化Item视图时，为我们的Item视图直接设置单击监听和长按监听，这种方式与Adapter的耦合度比较高，而且频繁的为view设置监听对象，感觉不太好。其实RecyclerView中为我们提供了一个类OnItemTouchListener通过这个类再结合手势GestureDetector完全可以实现一个耦合度更低复用度更高的单击和长按监听。我们再来看看OnItemTouchListener的实现方式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic boolean onTouchEvent(MotionEvent e) &#123; ...... if (dispatchOnItemTouch(e)) &#123; cancelTouch(); return true; &#125; ......&#125;private boolean dispatchOnItemTouch(MotionEvent e) &#123; final int action = e.getAction(); if (mActiveOnItemTouchListener != null) &#123; if (action == MotionEvent.ACTION_DOWN) &#123; // Stale state from a previous gesture, we're starting a new one. Clear it. mActiveOnItemTouchListener = null; &#125; else &#123; //此处即调用OnItemTouchListener的方法 mActiveOnItemTouchListener.onTouchEvent(this, e); if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123; // Clean up for the next gesture. mActiveOnItemTouchListener = null; &#125; return true; &#125; &#125; // Listeners will have already received the ACTION_DOWN via dispatchOnItemTouchIntercept // as called from onInterceptTouchEvent; skip it. if (action != MotionEvent.ACTION_DOWN) &#123; final int listenerCount = mOnItemTouchListeners.size(); for (int i = 0; i &lt; listenerCount; i++) &#123; final OnItemTouchListener listener = mOnItemTouchListeners.get(i); //此处即调用OnItemTouchListener的方法 if (listener.onInterceptTouchEvent(this, e)) &#123; mActiveOnItemTouchListener = listener; return true; &#125; &#125; &#125; return false;&#125;@Overridepublic boolean onInterceptTouchEvent(MotionEvent e) &#123; ...... if (dispatchOnItemTouchIntercept(e)) &#123; cancelTouch(); return true; &#125; ......&#125;private boolean dispatchOnItemTouchIntercept(MotionEvent e) &#123; final int action = e.getAction(); if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_DOWN) &#123; mActiveOnItemTouchListener = null; &#125; final int listenerCount = mOnItemTouchListeners.size(); for (int i = 0; i &lt; listenerCount; i++) &#123; final OnItemTouchListener listener = mOnItemTouchListeners.get(i); if (listener.onInterceptTouchEvent(this, e) &amp;&amp; action != MotionEvent.ACTION_CANCEL) &#123; mActiveOnItemTouchListener = listener; return true; &#125; &#125; return false;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://ittiger.cn/tags/RecyclerView/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"基于OkHttp的封装库TigerOkHttp的使用","slug":"基于OkHttp的封装库TigerOkHttp的使用","date":"2016-01-06T11:58:01.000Z","updated":"2016-07-29T06:06:17.815Z","comments":true,"path":"基于OkHttp的封装库TigerOkHttp的使用.html","link":"","permalink":"http://ittiger.cn/基于OkHttp的封装库TigerOkHttp的使用.html","excerpt":"在前面熟悉了OkHttp的用法之后，为了简化用法同时适用于我的项目，我针对OkHttp进行了更进一步的封装(源码及其Demo地址在https://github.com/huyongli/TigerOkHttp) TigerOKHttp特性封装之后其支持的功能特性包括如下： 一般的get同步阻塞请求和异步请求 一般的post同步阻塞请求和异步请求 实现了文件上传功能（包含文件上传进度回调显示） 实现了大文件下载功能，只需要指定文件下载路径即可，也包含了下载进度的回调显示 实现了请求结果的自动解析，用户也可以根据需求扩展自定义结果解析类 对所有请求都支持直接将结果解析转换为JavaBean对象或集合 支持对返回结果结构的自定义，例如设置返回结果结构为：{flag：1|0，error：错误信息，result：请求结果}，结果解析的时候会按照此结构进行结果解析 支持取消某个请求","text":"在前面熟悉了OkHttp的用法之后，为了简化用法同时适用于我的项目，我针对OkHttp进行了更进一步的封装(源码及其Demo地址在https://github.com/huyongli/TigerOkHttp) TigerOKHttp特性封装之后其支持的功能特性包括如下： 一般的get同步阻塞请求和异步请求 一般的post同步阻塞请求和异步请求 实现了文件上传功能（包含文件上传进度回调显示） 实现了大文件下载功能，只需要指定文件下载路径即可，也包含了下载进度的回调显示 实现了请求结果的自动解析，用户也可以根据需求扩展自定义结果解析类 对所有请求都支持直接将结果解析转换为JavaBean对象或集合 支持对返回结果结构的自定义，例如设置返回结果结构为：{flag：1|0，error：错误信息，result：请求结果}，结果解析的时候会按照此结构进行结果解析 支持取消某个请求 如果还不知道如何使用OkHttp请参考我的上一篇文章 Android中OkHttp的使用 进行了解。 初始化配置所有的请求在使用之前，先在Application里执行TigerOkHttp.init(new TigerHttpConfig(getApplicationContext()));进行TigerOkHttp的初始化操作。 TigerHttpConfig中主要是设置请求的全局性配置： TigerHttpConfig.readTimeOut：设置全局请求的数据读取超时时间，默认为30s TigerHttpConfig.writeTimeOut：设置全局请求的数据写入超时时间，默认为15s TigerHttpConfig.connectTimeOut：设置全局请求的连接超时时间，默认为15s TigerHttpConfig.cacheSize：设置全局请求的缓存大小，默认为10M TigerHttpConfig.cacheDirectory：设置全局请求的缓存存储路径，默认为系统给应用分配的缓存路径 TigerHttpConfig.isWrapperResult：设置全局请求结果是否对结果进行了封装，默认为true TigerHttpConfig.wrapperJsonResult：设置全局请求结果的结构类型，在isWrapperResult为true时才起作用 WrapperJson主要自定义设置全局请求结果的结构类型： WrapperJson.code_name：设置请求成功与否的状态码字段，默认为：flag WrapperJson.result_name：设置请求成功后结果字段，默认为：result WrapperJson.error_name：设置请求失败后的错误信息字段(仅在请求失败时才有值)，默认为：error WrapperJson.code_error_value：设置请求失败的状态码值，当请求状态码与此值相等时代表请求失败 Get请求1234567891011121314151617181920212223242526272829303132333435363738/*-------------------- 以下为Get同步阻塞请求 -------------------------------*///根据请求URL构造请求对象，请求成功后直接返回结果为Model对象TigerJsonRequest&lt;Model&gt; request = new TigerJsonRequest&lt;Model&gt;(URL, Model.class);/* * 如果要同步请求返回Model集合的话，请求对象这样构造 * TigerJsonRequest&lt;List&lt;Model&gt;&gt; request = new TigerJsonRequest&lt;List&lt;Model&gt;&gt;(URL, Model.class); *///以下添加三个请求参数request.addParam(\"value\", \"同步get请求-返回Model\").addParam(\"isModel\", true).addParam(\"isList\", false);//同步阻塞请求，直接返回Model对象Model result = TigerOkHttp.getSync(request);//同步阻塞请求，直接返回Model集合//List&lt;Model&gt; result = TigerOkHttp.getSync(request);/*-------------------- 以下为Get异步请求 ------------------------------*///根据请求URL构造请求对象，请求成功直接返回结果为Model集合TigerJsonRequest&lt;List&lt;Model&gt;&gt; request = new TigerJsonRequest&lt;List&lt;Model&gt;&gt;(URL);//添加三个请求参数request.addParam(\"value\", \"异步get请求-返回List&lt;Model&gt;\").addParam(\"isModel\", true).addParam(\"isList\", true).setRequestCallback(new RequestCallback&lt;List&lt;Model&gt;&gt;() &#123;//设置异步请求回调 @Override public void onSuccess(List&lt;Model&gt;result) &#123; showResult(result.toString()); &#125; @Override public void onFailure(TigerHttpException e) &#123; showResult(e.getMessage()); &#125;&#125;);//开始异步请求TigerOkHttp.getAsync(request); 上面即为一般Get同步阻塞请求和异步请求的方式，对这两个请求需要说明几点： 首先根据请求URL构造一个请求对象TigerJsonRequest，如果为同步阻塞请求必须调用具有两个参数的构造函数以设置请求地址和设置请求返回的结果类型，如果是异步请求则只需要调用一个参数的构造函数设置请求地址即可(异步请求的返回结果类型会自动根据泛型判断) 在请求对象添加此请求相关的请求参数 如果是异步请求，在请求对象中添加异步请求回调接口RequestCallback 根据是否为异步请求在TigerOkHttp中选择对应的请求方法开始请求操作 如果解析后返回Model对象话，服务端返回的结果必须是JSON字符串，如果解析后返回Model集合的话，服务端返回的结果必须是JSON数组字符串 Post请求这里的Post同步、异步请求和上面的Get的同步异步请求方式基本上一样，构造请求对象TigerJsonRequest的方式是一模一样的，唯一的区别只是在最后发起请求操作上更换了请求方法 post同步阻塞请求的发起方式为：T result = TigerOkHttp.postSync(request); post异步请求的发起方式为：TigerOkHttp.postAsync(request); 自定义结果解析器当TigerJsonRequest自带的默认解析器TigerJsonParser无法满足你的功能需求时，我们只需要简单的两步即可为某次请求实现自定义解析器： 继承TigerParser&lt;T&gt;(会自动根据设置的全局结果结构进行解析判断请求是否成功、拿到请求的真正结果数据)这个解析基类然后实现public abstract T parser(BufferedSource source) throws TigerHttpException;方法 通过TigerJsonRequest类中的方法setDataParser(TigerParser dataParser)设置此次请求的结果解析器 上传文件上传文件模块我是在TigerJsonRequest基础上扩展出了一个专门针对上传文件的请求对象TigerUploadRequest，具体的上传文件实现方式如下：1234567891011121314151617181920212223242526272829303132333435//根据上传请求地址和文件路径构造文件上传请求对象TigerUploadRequest&lt;String&gt; request = new TigerUploadRequest&lt;String&gt;(url, filePath);//设置上传回调监听 request.setRequestCallback( new RequestCallback&lt;String&gt;() &#123; @Override public void onPreExecute() &#123; super.onPreExecute(); //此处可以初始化显示上传进度UI &#125; @Override public void onSuccess(String result) &#123; //文件上传成功 &#125; @Override public void onLoading(long count, long current) &#123; super.onLoading(count, current); //此处可以更新上传进度 &#125; @Override public void onFailure(TigerHttpException e) &#123; //文件上传失败 &#125; @Override public void onAfterExecute() &#123; super.onAfterExecute(); //此处可以隐藏上传进度条 &#125; &#125;); //发起上传操作 TigerOkHttp.postAsync(request); 下载文件下载文件功能需要用到另外一个请求对象TigerFileRequest123456789101112131415161718192021222324252627282930313233343536//根据下载请求地址和下载文件的保存路径构造请求对象TigerFileRequest request = new TigerFileRequest(URL, fileSavePath);//添加一个请求参数request.addParam(\"method\", \"download\")//设置下载过程中的回调接口.setRequestCallback(new RequestCallback&lt;File&gt;() &#123; @Override public void onPreExecute() &#123; super.onPreExecute(); //此处初始化显示下载进度条UI &#125; @Override public void onSuccess(File result) &#123; //下载成功，同时返回下载成功的文件 &#125; @Override public void onLoading(long count, long current) &#123; super.onLoading(count, current); //更新下载进度UI &#125; @Override public void onFailure(TigerHttpException e) &#123; //下载失败 &#125; @Override public void onAfterExecute() &#123; super.onAfterExecute(); //隐藏下载进度条UI &#125;&#125;);//发起下载请求TigerOkHttp.getAsync(request); 取消某个请求取消某个请求只需要调用TigerOkHttp.cancel(request.getTag())即可，如果没有手动设置请求对象request的tag值，请求的时候会自动为这次请求生成一个唯一的tag 以上基本上就是TigerOkHttp框架的所有功能的使用方法，欢迎各位下载使用。 由于本人能力有限，此框架可能存在某些不足的地方，如果各位发现问题，欢迎提出，我会尽快解决，另外我会不断丰富完善此框架的功能。 write by laohu 2016-1-6","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"OkHttp","slug":"OkHttp","permalink":"http://ittiger.cn/tags/OkHttp/"},{"name":"TigerOkHttp","slug":"TigerOkHttp","permalink":"http://ittiger.cn/tags/TigerOkHttp/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android中OkHttp的使用","slug":"Android中OkHttp的使用","date":"2016-01-05T05:51:25.000Z","updated":"2016-07-29T05:57:01.130Z","comments":true,"path":"Android中OkHttp的使用.html","link":"","permalink":"http://ittiger.cn/Android中OkHttp的使用.html","excerpt":"前段时间研究了下Android里面非常火爆的网络请求库OkHttp，这篇文章主要来介绍下OkHttp的常用请求的使用方式，后面一篇文章会介绍本人基于OkHttp封装的一个操作更简单、更适用于项目的网络请求库TigerOkHttp，其源码及Demo地址为：https://github.com/huyongli/TigerOkHttp 一、说明对于OkHttp的基本介绍，以及为什么要使用OkHttp而不再使用HttpURLConnection或者是HttpClient，各位自己找度娘去，我这里就不再废话了。 使用OkHttp之前，需要先下载OkHttp.jar包，大家可以在https://github.com/square/okhttp去下载OkHttp的最新jar包以及源码， 同时因为OkHttp内部依赖okio，所以大家还要自行下载okio.jar包，下载地址在这里https://github.com/square/okio","text":"前段时间研究了下Android里面非常火爆的网络请求库OkHttp，这篇文章主要来介绍下OkHttp的常用请求的使用方式，后面一篇文章会介绍本人基于OkHttp封装的一个操作更简单、更适用于项目的网络请求库TigerOkHttp，其源码及Demo地址为：https://github.com/huyongli/TigerOkHttp 一、说明对于OkHttp的基本介绍，以及为什么要使用OkHttp而不再使用HttpURLConnection或者是HttpClient，各位自己找度娘去，我这里就不再废话了。 使用OkHttp之前，需要先下载OkHttp.jar包，大家可以在https://github.com/square/okhttp去下载OkHttp的最新jar包以及源码， 同时因为OkHttp内部依赖okio，所以大家还要自行下载okio.jar包，下载地址在这里https://github.com/square/okio 二、使用教程1.Get请求123456789101112131415161718192021222324//创建OkHttpClient对象，用于稍后发起请求OkHttpClient client = new OkHttpClient();//根据请求URL创建一个Request对象Request request = new Request.Builder().url(\"https://github.com/huyongli/TigerOkHttp\").build(); //根据Request对象发起Get同步Http请求Response response = client.newCall(request).execute(); //根据Request对象发起Get异步Http请求，并添加请求回调client.newCall(request).enqueue(new Callback() &#123; @Override public void onResponse(final Response response) throws IOException &#123; //请求成功，此处对请求结果进行处理 //String result = response.body().string(); //InputStream is = response.body().byteStream(); //byte[] bytes = response.body().bytes(); &#125; @Override public void onFailure(Request request, IOException e) &#123; //请求失败 &#125;&#125;); 上面的代码示例演示了OkHttp中一个普通的Http get请求是如何实现的，对于上面的代码，作一下简单的说明 既然是get请求，当然得先构造好你要请求的URL 有了请求URL，紧接着就是需要通过这个URL构造一个请求对象Request 当然有时候可能你需要对这个Http请求添加一些自定义的请求头信息header，这时你在构造Request对象之前通过Request.Builder builder = new Request.Builder()创建的builder 对象来添加自己需要添加的请求头信息builder.addHeader(key, value) OkHttp是自带请求缓存控制策略的，如果你想改变某个请求的缓存控制策略，你也可以通过builder对象来修改缓存策略builder.cacheControl() 通过上述步骤构造好请求对象Request之后，通过OkHttpClient创建一个Call任务对象，这个对象有execute()和cancel()等方法对Call任务对象进行执行和取消 如果是同步阻塞请求的话，直接执行Call对象的execute()方法即可得到请求结果。 如果是异步请求的话，就需要执行Call对象的enqueue(new Callback(){})方法，将任务对象添加到任务请求调度队列中，同时添加请求回调接口。 请求成功之后，可以得到一个Response对象，如果想获得返回的字符串结果则可以通过response.body().string()，如果想获得返回结果的二进制数据的话可以通过response.body().bytes()，如果想获得返回的InputStream的话可以通过response.body().byteStream() 通过上面我们可以发现在Response对象中我们可以获取InputStream对象，所以从此处我们可以看出在异步请求onResponse(Response response)回调方法中我们可以通过IO方式来进行写文件，所以在此回调中我们可以进行大文件的下载处理，同时也说明此回调并不是在UI线程中执行的，所以此处如果要进行UI操作的话各位需要自行处理下。 2.Post请求上面对OkHttp的Get请求分析完之后，OkHttp的整个请求流程和处理流程就清晰，Post请求和Get请求的流程都是一样，区别只是在于Request对象构造上有区别。123456789//创建OkHttpClient对象OkHttpClient client = new OkHttpClient();//通过FormEncodingBuilder对象添加多个请求参数键值对FormEncodingBuilder builder = new FormEncodingBuilder();builder.add(\"method\", \"post\").add(\"param\", value);//通过FormEncodingBuilder对象构造Post请求体RequestBody body = builder.build();//通过请求地址和请求体构造Post请求对象RequestRequest request = new Request.Builder().url(url).post(body).build(); 上面的代码演示了如何构造普通Post请求(不包含文件上传)的请求体和请求对象，请求对象构造成功之后，后面的请求过程和处理流程就和Get请求是一样的了。 3.文件上传12345678910111213//多个图片文件列表 List&lt;File&gt; list = new ArrayList&lt;File&gt;();//多文件表单上传构造器MultipartBuilder multipartBuilder = new MultipartBuilder().type(MultipartBuilder.FORM);//添加一个文本表单参数multipartBuilder.addFormDataPart(\"method\", \"upload上传\");for(File file : list) &#123; if(file.exists()) &#123; multipartBuilder.addFormDataPart(file.getName(), file.getName(), RequestBody.create(MediaType.parse(\"image/png\"), file)); &#125;&#125;//构造文件上传时的请求对象RequestRequest request = new Request.Builder().url(url).post(multipartBuilder.build()).build(); 文件上传时的重点是通过MultipartBuilder构造器添加要上传的文件和表单参数，OkHttp中文件上传时，没有可以直接实现上传进度显示的接口，这个需要手动对OkHttp中的请求体进行扩展，这篇文章中就不写了，在下篇文章介绍TigerOkHttp时我会进行介绍。 4.文件下载文件下载功能在第一点Get请求的几点说明中已经介绍过了，无论你是通过Get请求还是Post请求，只需要从请求结果对象Response中获取到结果输入流InputStream，然后通过IO操作进行写文件即可实现文件下载功能。在通过IO操作写文件时，也可以自行实现下载进度显示的功能。 5.编码问题在OkHttp中，无论是Get请求还是Post请求所有参数的编码方式都是默认采用UTF-8的编码方式进行编码。 所以在进行Get请求或Post请求时，文本参数都不需要我们进行手动编码，但是在服务端进行参数解析时，需要做简单的处理，这里我只说明tomcat下运行的Java后台服务的处理方式： 针对Get请求，我们只需要在tomcat的server.xml文件中设置默认编码方式(URIEncoding=”UTF-8″ )为UTF-8即可，注意此编码设置只对Get请求有效。 针对Post请求，我们在解析获取参数值之前需要手动设置请求的编码方式为UTF-8，如：req.setCharacterEncoding(“UTF-8”); OkHttp封装框架–TigerOkHttp以上就是OkHttp最基本的用法，下篇文章我会介绍我自己基于OkHttp更进一步封装的网络请求库TigerOkHttp，它主要包含了如下功能特点： 一般的get同步阻塞请求和异步请求 一般的post同步阻塞请求和异步请求 实现了文件上传功能（包含文件上传进度回调显示） 实现了大文件下载功能，只需要指定文件下载路径即可，也包含了下载进度的回调显示 实现了请求结果的自动解析，用户也可以根据需求扩展自定义结果解析类 对所有请求都支持直接将结果解析转换为JavaBean对象或集合 支持对返回结果结构的自定义，例如设置返回结果结构为：{flag：1|0，error：错误信息，result：请求结果}，结果解析的时候会按照此结构进行结果解析 支持取消某个请求 write by laohu 2016-1-5","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"OkHttp","slug":"OkHttp","permalink":"http://ittiger.cn/tags/OkHttp/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android百度地图导航功能的那些坑","slug":"Android百度地图导航功能的那些坑","date":"2015-11-15T11:47:23.000Z","updated":"2016-07-29T05:50:54.202Z","comments":true,"path":"Android百度地图导航功能的那些坑.html","link":"","permalink":"http://ittiger.cn/Android百度地图导航功能的那些坑.html","excerpt":"实现步骤 首先要先在AndroidManifest.xml中注册导航服务 &lt;service android:name=&quot;com.baidu.navi.location.f&quot; android:enabled=&quot;true&quot;&gt;&lt;/service&gt; 添加相关的权限，我也不知道哪些是必须的，我直接把Demo里面的相关权限配置全部拉过来了 在导航之前要先调用BaiduNaviManager.getInstance().initEngine对导航引擎进行初始化。可以通过NaviEngineInitListener接口检查导航引擎初始化是否成功，同时通过LBSAuthManagerListener接口对API-Key进行Key校验是否成功，status结果为0代表key校验成功。 必须将Demo中assert目录下的两个文件BaiduNaviSDK_Resource_v1_0_0.png，channel拷贝到自己项目的assert目录下去，否则导航引擎无法初始化成功。 在导航引擎初始化成功后，调用导航功能前调用BaiduNaviManager.getInstance().checkEngineStatus(context)检测导航引擎是否初始化成功。 调用BaiduNaviManager.getInstance().launchNavigator开始导航。","text":"实现步骤 首先要先在AndroidManifest.xml中注册导航服务 &lt;service android:name=&quot;com.baidu.navi.location.f&quot; android:enabled=&quot;true&quot;&gt;&lt;/service&gt; 添加相关的权限，我也不知道哪些是必须的，我直接把Demo里面的相关权限配置全部拉过来了 在导航之前要先调用BaiduNaviManager.getInstance().initEngine对导航引擎进行初始化。可以通过NaviEngineInitListener接口检查导航引擎初始化是否成功，同时通过LBSAuthManagerListener接口对API-Key进行Key校验是否成功，status结果为0代表key校验成功。 必须将Demo中assert目录下的两个文件BaiduNaviSDK_Resource_v1_0_0.png，channel拷贝到自己项目的assert目录下去，否则导航引擎无法初始化成功。 在导航引擎初始化成功后，调用导航功能前调用BaiduNaviManager.getInstance().checkEngineStatus(context)检测导航引擎是否初始化成功。 调用BaiduNaviManager.getInstance().launchNavigator开始导航。 关键代码相关代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213 public static void launchNavi(final Activity activity, List points )&#123; if(points.size() &lt; 2) &#123; Toast.makeText(activity, \"数据不合法，暂时无法导航\", Toast.LENGTH_SHORT).show(); return; &#125; BaiduNaviManager.getInstance().launchNavigator(activity, points, //路线点列表 NE_RoutePlan_Mode.ROUTE_PLAN_MOD_MIN_TIME, //算路方式 false, //真实导航 BaiduNaviManager.STRATEGY_FORCE_ONLINE_PRIORITY, //在离线策略 new OnStartNavigationListener() &#123; //跳转监听 @Override public void onJumpToNavigator(Bundle configParams) &#123; Intent intent = new Intent(activity, NaviBdMapActivity.class); intent.putExtras(configParams); activity.startActivityForResult(intent,REQUESTCODE_NAVI_FINISH); &#125; @Override public void onJumpToDownloader() &#123; &#125; &#125; ); &#125; /** * 初始化导航引擎 * Author: hyl * Time: 2015-7-9下午4:56:18 * @param activity */ public static void initNaviEngine(final Activity activity) &#123; BaiduNaviManager.getInstance().initEngine(activity, Utils.getRootPath(), new SPMNaviEngineInitListener(), new LBSAuthManagerListener() &#123; @Override public void onAuthResult(int status, String msg) &#123; String str = null; if (0 == status) &#123; str = \"key校验成功!\"; &#125; else &#123; str = \"key校验失败, \" + msg; &#125; &#125; &#125; ); &#125; private static class SPMNaviEngineInitListener implements NaviEngineInitListener &#123; public void engineInitSuccess() &#123; Log.i(\"Navi\", \"导航初始化成功\"); &#125; public void engineInitStart() &#123; &#125; public void engineInitFail() &#123; Log.i(\"Navi\", \"导航初始化失败\"); &#125; &#125;; public class NaviBdMapActivity extends Activity &#123; public void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); // 创建NmapView if (Build.VERSION.SDK_INT &lt; 14) &#123; BaiduNaviManager.getInstance().destroyNMapView(); &#125; MapGLSurfaceView nMapView = BaiduNaviManager.getInstance().createNMapView(this); // 创建导航视图 View navigatorView = BNavigator.getInstance().init( NaviBdMapActivity.this, getIntent().getExtras(), nMapView); // 填充视图 setContentView(navigatorView); BNavigator.getInstance().setListener(mBNavigatorListener); BNavigator.getInstance().startNav(); // 初始化TTS. 开发者也可以使用独立TTS模块，不用使用导航SDK提供的TTS BNTTSPlayer.initPlayer(); // 设置TTS播放回调 BNavigatorTTSPlayer.setTTSPlayerListener(new IBNTTSPlayerListener() &#123; @Override public int playTTSText(String arg0, int arg1) &#123; // 开发者可以使用其他TTS的API return BNTTSPlayer.playTTSText(arg0, arg1); &#125; @Override public void phoneHangUp() &#123; // 手机挂断 &#125; @Override public void phoneCalling() &#123; // 通话中 &#125; @Override public int getTTSState() &#123; // 开发者可以使用其他TTS的API, return BNTTSPlayer.getTTSState(); &#125; &#125;); BNRoutePlaner.getInstance().setObserver( new RoutePlanObserver(this, new IJumpToDownloadListener() &#123; @Override public void onJumpToDownloadOfflineData() &#123; &#125; &#125;)); &#125; private IBNavigatorListener mBNavigatorListener = new IBNavigatorListener() &#123; @Override public void onYawingRequestSuccess() &#123; // TODO 偏航请求成功 &#125; @Override public void onYawingRequestStart() &#123; // TODO 开始偏航请求 &#125; @Override public void onPageJump(int jumpTiming, Object arg) &#123; // TODO 页面跳转回调 if (IBNavigatorListener.PAGE_JUMP_WHEN_GUIDE_END == jumpTiming) &#123; finishActivity(); &#125; else if (IBNavigatorListener.PAGE_JUMP_WHEN_ROUTE_PLAN_FAIL == jumpTiming) &#123; finishActivity(); &#125; &#125; @Override public void notifyGPSStatusData(int arg0) &#123; &#125; @Override public void notifyLoacteData(LocData arg0) &#123; &#125; @Override public void notifyNmeaData(String arg0) &#123; &#125; @Override public void notifySensorData(SensorData arg0) &#123; &#125; @Override public void notifyStartNav() &#123; BaiduNaviManager.getInstance().dismissWaitProgressDialog(); &#125; @Override public void notifyViewModeChanged(int arg0) &#123; &#125; &#125;; @Override public void onResume() &#123; BNavigator.getInstance().resume(); super.onResume(); BNMapController.getInstance().onResume(); &#125;; @Override public void onPause() &#123; BNavigator.getInstance().pause(); super.onPause(); BNMapController.getInstance().onPause(); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; BNavigator.getInstance().onConfigurationChanged(newConfig); super.onConfigurationChanged(newConfig); &#125; public void onBackPressed() &#123; BNavigator.getInstance().onBackPressed(); &#125; @Override public void onDestroy() &#123; BNavigator.destory(); BNRoutePlaner.getInstance().setObserver(null); super.onDestroy(); &#125; public void finishActivity() &#123; finish(); overridePendingTransition(R.anim.in_from_right,R.anim.out_to_left); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"百度地图","slug":"百度地图","permalink":"http://ittiger.cn/tags/百度地图/"},{"name":"导航","slug":"导航","permalink":"http://ittiger.cn/tags/导航/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"基于openfire+smack开发Android即时聊天应用[五]-简易IM客户端效果图","slug":"基于openfire-smack开发Android即时聊天应用-五-简易IM客户端效果图","date":"2015-10-30T11:24:10.000Z","updated":"2016-09-29T08:23:18.338Z","comments":true,"path":"基于openfire-smack开发Android即时聊天应用-五-简易IM客户端效果图.html","link":"","permalink":"http://ittiger.cn/基于openfire-smack开发Android即时聊天应用-五-简易IM客户端效果图.html","excerpt":"经过几天时间对Openfire+Smack的研究，写了一个简单的Android端的IM客户端，给大家看看我的客户端的效果图，支持发送文本、图片、语音三种消息，群聊功能暂时没有集成上去。整个应用做的比较粗糙。 Demo代码地址请戳：https://github.com/huyongli/TigerIM","text":"经过几天时间对Openfire+Smack的研究，写了一个简单的Android端的IM客户端，给大家看看我的客户端的效果图，支持发送文本、图片、语音三种消息，群聊功能暂时没有集成上去。整个应用做的比较粗糙。 Demo代码地址请戳：https://github.com/huyongli/TigerIM 1.登陆界面 2.好友列表 3.聊天界面的几种效果图： 聊天界面是仿着QQ的聊天界面做的。 write by laohu 2015-10-30","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Openfire","slug":"Openfire","permalink":"http://ittiger.cn/tags/Openfire/"},{"name":"smack","slug":"smack","permalink":"http://ittiger.cn/tags/smack/"},{"name":"IM","slug":"IM","permalink":"http://ittiger.cn/tags/IM/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"基于openfire+smack开发Android即时聊天应用[四]-单人聊天、群聊、发送接收文件等","slug":"基于openfire-smack开发Android即时聊天应用-四-单人聊天、群聊、发送接收文件等","date":"2015-10-30T10:24:10.000Z","updated":"2016-08-04T07:50:08.189Z","comments":true,"path":"基于openfire-smack开发Android即时聊天应用-四-单人聊天、群聊、发送接收文件等.html","link":"","permalink":"http://ittiger.cn/基于openfire-smack开发Android即时聊天应用-四-单人聊天、群聊、发送接收文件等.html","excerpt":"这篇文章主要介绍如何实现点对点单人聊天、多人的群聊、以及如何给对方发送文件，如何发送图片消息和语音消息等功能。","text":"这篇文章主要介绍如何实现点对点单人聊天、多人的群聊、以及如何给对方发送文件，如何发送图片消息和语音消息等功能。 1.单人聊天首先创建聊天对象123456789101112/** * 创建聊天窗口 * @param jid 好友的JID * @return */ public Chat createChat(String jid) &#123; if(isConnected()) &#123; ChatManager chatManager = ChatManager.getInstanceFor(connection); return chatManager.createChat(jid); &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; 创建聊天对象时，参数JID记得传聊天JID(解释请参考我的系列文章之基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等)给好友发送文本消息1chat.sendMessage(message); 2.获取聊天对象管理器1234567891011/** * 获取聊天对象管理器 * @return */ public ChatManager getChatManager() &#123; if(isConnected()) &#123; ChatManager chatManager = ChatManager.getInstanceFor(connection); return chatManager; &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; 3.接收文本消息1234567891011121314//创建聊天对象管理器监听private ChatManagerListener chatManagerListener = new ChatManagerListener() &#123; @Override public void chatCreated(Chat chat, boolean createdLocally) &#123; chat.addMessageListener(new ChatMessageListener() &#123; @Override public void processMessage(Chat chat, Message message) &#123; //接收到消息Message之后进行消息展示处理，这个地方可以处理所有人的消息 &#125; &#125;); &#125;&#125;;//设置聊天对象管理器处理监听getChatManager().addChatListener(chatManagerListener); 上述代码会在你创建聊天对象时对该聊天对象设置消息处理监听，当接收到消息之后，会自动调用processMessage方法进行处理，我们可以在该方法中对接收到的消息进行展示或其他处理，所有好友发送过来的消息都会通过该方法处理。所以该监听最好在登陆之后进行设置，同时在断开连接或是注销时移除该监听。 4.创建群聊聊天室123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 /** * 创建群聊聊天室 * @param roomName 聊天室名字 * @param nickName 创建者在聊天室中的昵称 * @param password 聊天室密码 * @return */ public MultiUserChat createChatRoom(String roomName, String nickName, String password) &#123; if(!isConnected()) &#123; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; MultiUserChat muc = null; try &#123; // 创建一个MultiUserChat muc = MultiUserChatManager.getInstanceFor(connection).getMultiUserChat(roomName + \"@conference.\" + connection.getServiceName()); // 创建聊天室 boolean isCreated = muc.createOrJoin(nickName); if(isCreated) &#123; // 获得聊天室的配置表单 Form form = muc.getConfigurationForm(); // 根据原始表单创建一个要提交的新表单。 Form submitForm = form.createAnswerForm(); // 向要提交的表单添加默认答复 List fields = form.getFields(); for(int i = 0; fields != null &amp;&amp; i &lt; fields.size(); i++) &#123; if(FormField.Type.hidden != fields.get(i).getType() &amp;&amp; fields.get(i).getVariable() != null) &#123; // 设置默认值作为答复 submitForm.setDefaultAnswer(fields.get(i).getVariable()); &#125; &#125; // 设置聊天室的新拥有者 List owners = new ArrayList(); owners.add(connection.getUser());// 用户JID submitForm.setAnswer(\"muc#roomconfig_roomowners\", owners); // 设置聊天室是持久聊天室，即将要被保存下来 submitForm.setAnswer(\"muc#roomconfig_persistentroom\", true); // 房间仅对成员开放 submitForm.setAnswer(\"muc#roomconfig_membersonly\", false); // 允许占有者邀请其他人 submitForm.setAnswer(\"muc#roomconfig_allowinvites\", true); if(password != null &amp;&amp; password.length() != 0) &#123; // 进入是否需要密码 submitForm.setAnswer(\"muc#roomconfig_passwordprotectedroom\", true); // 设置进入密码 submitForm.setAnswer(\"muc#roomconfig_roomsecret\", password); &#125; // 能够发现占有者真实 JID 的角色 // submitForm.setAnswer(\"muc#roomconfig_whois\", \"anyone\"); // 登录房间对话 submitForm.setAnswer(\"muc#roomconfig_enablelogging\", true); // 仅允许注册的昵称登录 submitForm.setAnswer(\"x-muc#roomconfig_reservednick\", true); // 允许使用者修改昵称 submitForm.setAnswer(\"x-muc#roomconfig_canchangenick\", false); // 允许用户注册房间 submitForm.setAnswer(\"x-muc#roomconfig_registration\", false); // 发送已完成的表单（有默认值）到服务器来配置聊天室 muc.sendConfigurationForm(submitForm); &#125;&#125; catch (XMPPException | SmackException e) &#123; e.printStackTrace(); return null; &#125; return muc; &#125; 上面这段创建群聊聊天室设置表单属性的那段代码引用于网上的代码段。 5.加入群聊聊天室123456789101112131415161718192021222324252627/** * 加入一个群聊聊天室 * @param roomName 聊天室名字 * @param nickName 用户在聊天室中的昵称 * @param password 聊天室密码 * @return */ public MultiUserChat joinChatRoom(String roomName, String nickName, String password) &#123; if(!isConnected()) &#123; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; try &#123; // 使用XMPPConnection创建一个MultiUserChat窗口 MultiUserChat muc = MultiUserChatManager.getInstanceFor(connection). getMultiUserChat(roomName + \"@conference.\" + connection.getServiceName()); // 聊天室服务将会决定要接受的历史记录数量 DiscussionHistory history = new DiscussionHistory(); history.setMaxChars(0); // history.setSince(new Date()); // 用户加入聊天室 muc.join(nickName, password); return muc; &#125; catch (XMPPException | SmackException e) &#123; e.printStackTrace(); return null; &#125; &#125; 在实现加入群聊聊天室的这段代码中有这么一段代码：1getMultiUserChat(roomName + \"@conference.\" + connection.getServiceName()); 在@与ServiceName中间必须加上conference这个字符串，我也不知道为什么，我最开始时不知道没有加，然后无论如何都加入失败，后来在网上查资料查了半天，有人说是要加上这个，然后我加上就成功了，暂时没搞明白为什么，先把程序跑通会用了再研究其他的原因。 6.群聊发送消息当你创建或是加入群聊聊天室后，即可获得群聊对象MultiUserChat，通过该对象即可发送群聊消息：1multiUserChat.sendMessage(msg);//发送群聊消息 7.接收群聊消息123456789//聊天室消息监听private MessageListener messageListener = new MessageListener() &#123; @Override public void processMessage(Message message) &#123; //与单聊接收处理消息类似，聊天室里所有人(包括发送人自己)发送的消息都会通过此方法进行回调处理 &#125;&#125;;//设置聊天室消息监听multiUserChat.addMessageListener(messageListener); 群聊接收消息与单聊接收消息还是很像的，只是监听对象，监听方式稍稍有点区别，整个来说，消息接收还是很简单的。 8.获取文件传输对象123456789101112/** * 获取发送文件的发送器 * @param jid 一个完整的jid(如：laohu@192.168.0.108/Smack * 后面的Smack应该客户端类型，不加这个会出错) * @return */ public OutgoingFileTransfer getSendFileTransfer(String jid) &#123; if(isConnected()) &#123; return FileTransferManager.getInstanceFor(connection).createOutgoingFileTransfer(jid); &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; 获取文件传输对象时的参数JID记得为文件传输JID：解释请参考我的系列文章之基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等 9.发送文件123456//获取文件传输对象OutgoingFileTransfer transfer = getSendFileTransfer(jid);//发送文件transfer.sendFile(File file, String description);//此处执行文件发送状态监听以上代码为发送文件file，参数description为对这次文件传输的描述 10.文件传输(包括文件发送与接收)过程监听(传输开始、完成、进度百分比)12345678910111213141516171819202122//文件传输过程中的状态监听分析if(transfer.getProgress() &lt; 1) &#123;//开始传输//传输进度，值为0~1&#125;while(!transfer.isDone()) &#123;//判断传输是否完成，传输取消、传输完成、传输发生错误都会返回true try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125;if(FileTransfer.Status.complete.equals(transfer.getStatus())) &#123; //传输完成 &#125; else if(FileTransfer.Status.cancelled.equals(transfer.getStatus())) &#123; //传输取消&#125; else if(FileTransfer.Status.error.equals(transfer.getStatus())) &#123; //传输错误&#125; else if(FileTransfer.Status.refused.equals(transfer.getStatus())) &#123; //传输拒绝&#125; 以上代码需在子线程执行，可以在文件传输(发送、接收)开始时设置进度条，传输完成时去掉进度条，同时可以通过getProgress()方法获得文件传输的具体进度百分比。 11.接收文件12345678910111213141516171819202122232425262728 /** * 添加文件接收的监听 * @param fileTransferListener */ public void addFileTransferListener(FileTransferListener fileTransferListener) &#123; if(isConnected()) &#123; FileTransferManager.getInstanceFor(connection).addFileTransferListener(fileTransferListener); return; &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125;addFileTransferListener(new FileTransferListener() &#123; @Override public void fileTransferRequest(FileTransferRequest request) &#123; // Accept it IncomingFileTransfer transfer = request.accept(); try &#123; String description = request.getDescription(); //在目录fileDir目录下新建一个名字为request.getFileName()的文件 File file = new File(fileDir ,request.getFileName()); //开始接收文件(将传输过来的文件内容输出到file中) transfer.recieveFile(file); //此处执行文件传输监听 &#125; catch (SmackException | IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;); 上面代码为设置文件接收监听 12.发送语音、图片消息我查看了半天的Smack的API，但是没有找到直接发送语音、图片消息的API，我说说我的实现思路。 其实图片、语音都是文件，我们可以把它们当做文件发送给好友。 在发送文件的同时，用描述字段进行标记传输过来的是图片还是语音。 然后在接收到该文件后通过描述字段进行区分当前接收的是图片文件还是语音文件，然后进行区分展示即可，这样就可以达到发送图片消息和语音消息。 但是我的这种实现方式还是有问题的，因为这种方式对于单聊还是可以实现的。但是如果是群聊的话，我就必须给每个人都发一个相同的文件，这样的话一条语音或图片消息，其实是要发送N次的，对于发送人来说流量就多消耗了N-1倍，所以这种方式对于实现群聊是行不通的。 对于群聊发送语音和图片消息，我的思路是这样的： 自己写一个上传文件的服务。 发送语音或图片消息时，将图片或语音通过上述上传服务上传到服务器上。 在上传完语音或图片后，再向聊天室里发送一个文本消息，发送内容为文件的类似下载地址这样的信息，同时还要告诉群成员这个文件是图片还是语音。 群成员接收到这样的特殊文本消息后去自动下载这个文件然后进行展示或是其他处理。 群聊天里发送图片或语音消息的这个实现方式我没有验证，但我觉得应该是可行的。至于单聊发送语音或图片消息的思路我是实现验证成功了的，是可行的。 write by laohu 2015-10-30","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Openfire","slug":"Openfire","permalink":"http://ittiger.cn/tags/Openfire/"},{"name":"smack","slug":"smack","permalink":"http://ittiger.cn/tags/smack/"},{"name":"IM","slug":"IM","permalink":"http://ittiger.cn/tags/IM/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等","slug":"基于openfire-smack开发Android即时聊天应用-三-账号信息、添加好友、JID理解等","date":"2015-10-30T09:24:10.000Z","updated":"2016-08-04T07:50:08.175Z","comments":true,"path":"基于openfire-smack开发Android即时聊天应用-三-账号信息、添加好友、JID理解等.html","link":"","permalink":"http://ittiger.cn/基于openfire-smack开发Android即时聊天应用-三-账号信息、添加好友、JID理解等.html","excerpt":"这一篇文章主要介绍账号的属性及几个重要属性的理解，同时介绍如何添加好友，获取好友列表信息，最后介绍我对JID这个属性字段的几种理解。","text":"这一篇文章主要介绍账号的属性及几个重要属性的理解，同时介绍如何添加好友，获取好友列表信息，最后介绍我对JID这个属性字段的几种理解。 1.账号信息获取账号的所有额外属性信息 1234567891011121314 /** * 获取账户所有属性信息 * @return */ public Set getAccountAttributes() &#123; if(isConnected()) &#123; try &#123; return AccountManager.getInstance(connection).getAccountAttributes(); &#125; catch (Exception e) &#123;throw new RuntimeException(e); &#125; &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; 上面取出的属性集合里主要包含如下几个属性值： 上述几个属性中的name属性即为用户的昵称属性，另外用户账号名、密码是不在这些属性当中的，账号名可以理解为是JID，可以通过RosterEntry.getUser这个方法获取，关于JID的理解请看下面的介绍 2.获取当前登录用户的所有好友信息12345678910/** * 获取当前登录用户的所有好友信息 * @return */ public Set getAllFriends() &#123; if(isConnected()) &#123; return Roster.getInstanceFor(connection).getEntries(); &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; 3.获取指定账号好友信息1234567891011/** * 获取指定账号的好友信息 * @param user 账号 * @return */ public RosterEntry getFriend(String user) &#123; if(isConnected()) &#123; return Roster.getInstanceFor(connection).getEntry(user); &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; 4.添加好友12345678910111213141516171819 /** * 添加好友 * @param user 用户账号 * @param nickName 用户昵称 * @param groupName 所属组名 * @return */ public boolean addFriend(String user, String nickName, String groupName) &#123; if(isConnected()) &#123; try &#123; Roster.getInstanceFor(connection).createEntry(user, nickName, new String[]&#123;groupName&#125;); return true;&#125; catch (NotLoggedInException | NoResponseException | XMPPErrorException | NotConnectedException e) &#123; return false;&#125; &#125; throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); &#125; 5.关于对JID的理解我对JID的理解主要是根据我在基于smack开发即时通信聊天应用时遇到的几种情况做的一个归纳，我碰到的JID的介绍主要有三种： 每个用户的好友列表中有一个JID，这个可以根据Openfire后台管理系统可以看出来，如下图：Smack_JID上面图中可以清晰的看到每个好友都对应有一个JID，而在我通过addFriend(String user, String nickName, String groupName)这个方法添加好友的时候，参数用户账号user最终就变成了上面的JID，是没有包含@符号和后面的服务器名的，我称这种JID为好友JID，如管理员账号的JID为：admin。这个JID通过官方提供的接口RosterEntry.getUser是可以获取到的。 好友之间聊天时有一个JID，在我创建聊天窗口对象Chat时(怎么创建请看我下一篇文章)，所传的参数也是JID，但是这个JID和上面的JID的值却又不是一样的，不然会创建失败，我们来看看官方API： 官方API中很明显的指出了参数为JID，但是我如果真的出好友列表中的JID的话创建聊天对象失败，必须这样传好友JID@ServiceName ，这是第二种JID，我称为聊天JID,比如和管理员聊天时的JID为：admin@192.168.0.108 好友之间传输文件时又有一个JID，在创建文件传输对象时也需要传递一个参数为JID，我们也来看看官方API： 官方API中也显示了在获取文件传输对象时需要传递参数为JID，但是这个JID我给的是聊天JID的时候，根本创建不了文件传输对象，后来在网上查了半天，看到别人都在后面加了个Smack，我也试了下，结果竟然成功了，坑爹啊，反正我还没搞清楚这是为什么，格式是这样的：好友JID@ServiceNam/Smack，我称这种JID为文件传输JID，比如聊天时给管理员传文件时的JID为：admin@192.168.0.108/Smack 这就是我碰到的JID的三种使用情况 write by laohu 2015-10-30","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Openfire","slug":"Openfire","permalink":"http://ittiger.cn/tags/Openfire/"},{"name":"smack","slug":"smack","permalink":"http://ittiger.cn/tags/smack/"},{"name":"IM","slug":"IM","permalink":"http://ittiger.cn/tags/IM/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"基于openfire+smack开发Android即时聊天应用[二]-用户注册、登陆、修改密码、注销等","slug":"基于openfire-smack开发Android即时聊天应用-二-用户注册、登陆、修改密码、注销等","date":"2015-10-30T08:24:10.000Z","updated":"2016-08-04T07:50:08.180Z","comments":true,"path":"基于openfire-smack开发Android即时聊天应用-二-用户注册、登陆、修改密码、注销等.html","link":"","permalink":"http://ittiger.cn/基于openfire-smack开发Android即时聊天应用-二-用户注册、登陆、修改密码、注销等.html","excerpt":"1. 开发准备在官网上下载最新的Smack开发包，我下载的是smack4.1.4版本的，导入相应的jar包即可开始开发工作","text":"1. 开发准备在官网上下载最新的Smack开发包，我下载的是smack4.1.4版本的，导入相应的jar包即可开始开发工作 2. Openfire服务连接(连接服务器)1234567891011121314151617181920212223242526/** * 连接服务器 * @return */private XMPPTCPConnection connect() &#123; try &#123; XMPPTCPConnectionConfiguration config = XMPPTCPConnectionConfiguration.builder() .setHost(SERVER_IP)//服务器IP地址 //服务器端口 .setPort(PORT) //服务器名称 .setServiceName(SERVER_NAME) //是否开启安全模式 .setSecurityMode(XMPPTCPConnectionConfiguration.SecurityMode.disabled) //是否开启压缩 .setCompressionEnabled(false) //开启调试模式 .setDebuggerEnabled(true).build(); XMPPTCPConnection connection = new XMPPTCPConnection(config); connection.connect(); return connection; &#125; catch (Exception e) &#123; return null; &#125;&#125; 3.登陆Openfire服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /** * 是否连接成功 * @return */ private boolean isConnected() &#123; if(connection == null) &#123; return false; &#125; if(!connection.isConnected()) &#123; try &#123; connection.connect(); return true; &#125; catch (SmackException | IOException | XMPPException e) &#123; return false; &#125; &#125; return true; &#125; /** * 登陆 * @param user 用户账号 * @param password 用户密码 * @return * @throws Exception */ public boolean login(String user, String password) throws Exception &#123; if(!isConnected()) &#123; return false; &#125; try &#123; connection.login(user, password); return true; &#125; catch (Exception e) &#123; throw e; &#125; &#125;``` ### 4.用户注册 该功能会在服务器上创建一个新的账号信息```java /** * 注册用户信息 * @param user 账号，是用来登陆用的，不是用户昵称 * @param password 账号密码 * @param attributes 账号其他属性，参考AccountManager.getAccountAttributes()的属性介绍 * @return */ public boolean registerUser(String user, String password, Map&lt;String, String&gt; attributes) &#123; if(!isConnected()) &#123; return false; &#125; try &#123; AccountManager.getInstance(connection).createAccount(user, password, attributes); return true; &#125; catch (NoResponseException | XMPPErrorException | NotConnectedException e) &#123; Log.e(TAG, \"注册失败\", e); return false; &#125; &#125; 5.修改账号密码1234567891011121314151617 /** * 修改密码 * @param newpassword 新密码 * @return */ public boolean changePassword(String newpassword) &#123; if(!isConnected()) &#123; return false; &#125;try &#123; AccountManager.getInstance(connection).changePassword(newpassword); return true;&#125; catch (NoResponseException | XMPPErrorException | NotConnectedException e) &#123; Log.e(TAG, \"密码修改失败\", e); return false;&#125; &#125; 6.注销(断开连接)12345678910111213141516/** * 注销 * @return */ public boolean logout() &#123; if(!isConnected()) &#123; return false; &#125; try &#123; connection.instantShutdown(); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; 7.删除账号/** * 删除当前登录的用户信息(从服务器上删除当前用户账号) * @return */ public boolean deleteUser() { if(!isConnected()) { return false; } try { AccountManager.getInstance(connection).deleteAccount();//删除该账号 return true; } catch (NoResponseException | XMPPErrorException | NotConnectedException e) { return false; } } 代码都非常简单，smack的api调用很方便。 write by laohu 2015-10-30","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Openfire","slug":"Openfire","permalink":"http://ittiger.cn/tags/Openfire/"},{"name":"smack","slug":"smack","permalink":"http://ittiger.cn/tags/smack/"},{"name":"IM","slug":"IM","permalink":"http://ittiger.cn/tags/IM/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"基于openfire+smack开发Android即时聊天应用[一]—openfire安装部署","slug":"基于openfire-smack开发Android即时聊天应用-一-—openfire安装部署","date":"2015-10-30T07:24:10.000Z","updated":"2016-08-04T07:50:08.150Z","comments":true,"path":"基于openfire-smack开发Android即时聊天应用-一-—openfire安装部署.html","link":"","permalink":"http://ittiger.cn/基于openfire-smack开发Android即时聊天应用-一-—openfire安装部署.html","excerpt":"Java领域的即时通信解决方案可以考虑基于xmpp协议的openfire+smack+spark来实现，都是开源的。最近一直在研究这个，也做了一个简单的Android即时聊天客户端，支持文本、图片、语音消息。 Demo地址请见此系列文章最后一篇","text":"Java领域的即时通信解决方案可以考虑基于xmpp协议的openfire+smack+spark来实现，都是开源的。最近一直在研究这个，也做了一个简单的Android即时聊天客户端，支持文本、图片、语音消息。 Demo地址请见此系列文章最后一篇 XMPP协议大家自行到百度google上去补脑吧。 openfire、smack、spark openfire是基于XMPP 协议的即时通信的服务器端的一个实现，如果你要实现一个简单的点对点通信或是简单的群聊，你完全可以使用该服务openfire本身提供的服务而不需要编写一行服务端的代码，非常方便。同时openfire还支持插件的扩展，如果你需要丰富增加服务端的功能，你可以基于openfire进行插件二次开发，或者直接修改openfire的源码实现。 smack是XMPP传输协议的Java实现，提供了一套API接口(类似于JDK中的HttpUrlConnection提供Http连接请求)，它是连接openfire服务、发送通信信息的桥梁。 spark是基于smack实现的一个XMPP即时通信客户端(PC端的)，spark貌似也是可以进行插件扩展的。官网：http://www.igniterealtime.org/，我目前用的都是最新版本的openfire3.10.2，smack4.1.4在smack4.1版本之前，smack本身是不支持Android平台的，不过当时有一个替代品asmack，github地址：https://github.com/flowdalic/asmack，在smack4.1之前我们可以通过asmack来配合openfire来实现Android端的即时通信应用，asmack和smack貌似api都差不多(我没看过asmack)。smack4.1之后就开始支持Android平台了，所以现在可以放弃asmack了。Windows下的Openfire安装部署去官网上下载最新的Openfire安装包，我下载的是不包含JDK的压缩包(Does not include Java JRE)，解压就可以用了，前提是你已经装了JDK了，而且JDK版本必须是1.7或以上的版本，Openfire不支持JDK6，解压之后在Openfire的根目录bin目录下执行openfire.exe即可，启动之后如下图 在启动服务配置之前，先在你的数据库中创建一个名为openfire的数据库(支持多种数据库)，点击图中的Launch Admin即会在浏览器上打开Openfire的配置界面，如下图： 上图中选择简体中文，然后继续： 上图中配置域，最好配置为你的服务器ip地址或者是域名，其他的默认不管，然后继续： 上图中选择标准数据库连接，继续： 上图中选择你的数据库类型，然后在数据库URL中填写正确的连接字符串，再填上你的数据库用户名和密码，然后继续 上图中直接默认选择初始设置，然后继续： 上图中填上管理员账户admin的邮件地址，然后填上该管理员账户的密码，然后继续： 到上图即表示你的Openfire服务安装配置完成，然后点击登录后进入到管理员登录界面： Openfire默认的管理员账户为admin，秘密即为上面你设置的密码，登录成功之后，你可以通过这个Openfire管理平台管理该服务商所有的账户信息，服务器信息等。 Linux环境下Openfire的安装部署在官网上下载最新的源码安装包(如： openfire_3_10_2.tar.gz )，我选择的也是不包含jdk的源码安装包，将该包上传至服务器某个目录下，在该目录下执行命令 tar -zxvf openfire_3_10_2.tar.gz，解压完成后切换到Openfire/bin目录下执行命令： ./openfire start 启动Openfire服务，然后在你自己的pc机浏览器上打开http://服务器ip:9090,即会进入Openfire的配置界面，前提是必须准备好一个数据库，配置过程与Windows下的配置过程一样，请参考上面的操作步骤。 OK，Openfire服务的安装配置就介绍完了，下面一篇我就开始介绍smack的用法。 write by laohu 2015-10-30 15:59:54","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Openfire","slug":"Openfire","permalink":"http://ittiger.cn/tags/Openfire/"},{"name":"smack","slug":"smack","permalink":"http://ittiger.cn/tags/smack/"},{"name":"IM","slug":"IM","permalink":"http://ittiger.cn/tags/IM/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android开发问题汇总–持续更新","slug":"Android开发问题汇总–持续更新","date":"2015-10-23T14:50:44.000Z","updated":"2016-08-30T02:53:07.669Z","comments":true,"path":"Android开发问题汇总–持续更新.html","link":"","permalink":"http://ittiger.cn/Android开发问题汇总–持续更新.html","excerpt":"Android开发中遇到的小问题汇总，会持续更新。 提供网上一个Android开放问题汇总贴：https://github.com/JohnTsaiAndroid/AndroidTips","text":"Android开发中遇到的小问题汇总，会持续更新。 提供网上一个Android开放问题汇总贴：https://github.com/JohnTsaiAndroid/AndroidTips TextView控件中给文本添加下划线的几种方式: 1.资源文件中用HTML标签把文本包起来即可 123&lt;resources&gt; &lt;string name=\"hello\"&gt;&lt;u&gt;hello&lt;/u&gt;&lt;/string&gt;&lt;/resources&gt; Java代码中可以这样处理：1234TextView textView = (TextView)findViewById(R.id.tv_test); textView.setText(Html.fromHtml(\"&lt;u&gt;\"+\"hello\"+\"&lt;/u&gt;\"));//或者这样处理textView .getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG ); //下划线 当将一个Android工程设置为Library之后，在另外一个Android工程中如果通过Configure build Path –&gt; Java Build Path –&gt; Project选项 –&gt; Add刚刚设置的library工程的话，是无法识别library工程中的资源文件的(引用资源文件编译不通过)。应该这样设置Configure build Path –&gt; Android –&gt; library选项 –&gt; Add刚刚设置的library工程。 Java中三目运算符如果和自动拆箱一起用会出现空指针异常，如下代码：123Map&lt;String, Boolean&gt; map = new HashMap&lt;String, Boolean&gt;();Boolean b = (map != null ? map.get(\"test\") : false);System.out.println(b); 出现空指针的原因是因为Java三目运算符中第二、三位操作数为基本类型和对象时，会自动将对象拆箱为基本类型数据进行运算(大家可以自己去看官方文档)，上述代码中刚好符合这种情况(第二位为对象，第三位为基本类型)，map.get(“test”)在实际执行中是这样执行的：((Boolean)map.get(“test”)).booleanValue()，将map中取得的Boolean对象自动拆箱为基本类型，而这个地方map.get(“test”)取出的值为null，自动拆箱的时候就会出现空指针了。如果这个地方一定要用三目运算符，只需要保证第二、三位操作数均为对象即可123Map&lt;String, Boolean&gt; map = new HashMap&lt;&gt;();Boolean b = (map != null ? map.get(\"test\") : Boolean.valueOf(false));System.out.println(b); Activity中两个Fragment进行切换时，例如：有FragmentA和FragmentB，进入Activity的时候，默认显示FragmentA，我点击FragmentA中的某个按钮切换到FragmentB，同时调用addToBackStack加入到返回栈，当我在FragmentB中点击返回按钮回到FragmentA时，FragmentA中的onResume方法却不执行。遇到这个问题的话可以看看在Activity中是否还保持了对FragmentB的引用，比如加入到了某个集合中或是声明成了Activity的成员变量，都会引发此问题。 Android中内部类就算实现了Serializable接口，也不能通过Intent进行序列化传参。如果传递的参数为序列化对象，该对象类不能是某个类里面的内部类。 java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState。出现问题的时机：我在进行Activity跳转时，会调用super.onBackPressed()方法手动finish掉当前的Activity（继承自android.support.v4.app.FragmentActivity），当屏幕处于竖屏状态时没有任何问题，但是当我设置为横屏在进行跳转操作时，会出现上述异常。 异常信息如下：123456789101112131415161718192021222324252627java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1343) at android.support.v4.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:486) at android.support.v4.app.FragmentActivity.onBackPressed(FragmentActivity.java:179) at com.emap.base.BaseActivity.finishActivity(BaseActivity.java:360) at com.emap.air.activity.IndexActivity$1.handleMessage(IndexActivity.java:128) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:137) at android.app.ActivityThread.main(ActivityThread.java:5119) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:511) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:834) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601) at dalvik.system.NativeStart.main(Native Method) 通过上述异常可以看出错误出现的原因并不是我自己写的代码导致的，猜测的话可能跟系统版本有关。 解决办法：将super.onBackPressed()替换成finish()方法来结束当前Activity即可。 参考文章：http://zhiweiofli.iteye.com/blog/1539467 TextView通过代码设置字体大小要使用如下方式textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimensionPixelSize(R.dimen.dp_10));必须要使用该方法设置单位类型，否则设置的字体效果会和你预期的不一样","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Tips","slug":"Tips","permalink":"http://ittiger.cn/tags/Tips/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"红米Note调用系统相机拍照后应用崩溃问题分析解决","slug":"红米Note调用系统相机拍照后应用崩溃问题分析解决","date":"2015-10-22T14:47:12.000Z","updated":"2016-07-29T01:19:11.396Z","comments":true,"path":"红米Note调用系统相机拍照后应用崩溃问题分析解决.html","link":"","permalink":"http://ittiger.cn/红米Note调用系统相机拍照后应用崩溃问题分析解决.html","excerpt":"这几天突然发现红米Note手机只要调用系统相机进行拍照时，我的应用必定会崩溃。这个问题折腾了好久才解决，现在记录下问题跟踪解决的过程和方法。(红米Note手机的系统太坑爹了%&gt;_&lt;%) ####解决办法请直接从第7条开始看，1~5条为我的问题处理过程，第6条为问题原因分析。","text":"这几天突然发现红米Note手机只要调用系统相机进行拍照时，我的应用必定会崩溃。这个问题折腾了好久才解决，现在记录下问题跟踪解决的过程和方法。(红米Note手机的系统太坑爹了%&gt;_&lt;%) ####解决办法请直接从第7条开始看，1~5条为我的问题处理过程，第6条为问题原因分析。 ####问题原因分析 问题刚出现的时候，当然是想调试，在调用系统相机拍照的前后代码出打好断点准备调试，结果发现这段代码没有任何异常(其实想想也是正常的，因为其他手机都是好的，唯独红米Note有问题，要是这段代码有问题，其他手机应该也有问题，这一步真是多余) 既然暂时找不到系统崩溃时代码的出错行，那只有去查看系统崩溃日志了(这里提一下，应用开发时一定要通过UncaughtExceptionHandler捕获系统未处理的系统，并在uncaughtException(Thread thread, Throwable ex)方法中记录异常日志，不然应用运行中崩溃了完全无法快速准确的定位错误信息)。 当我打开日志文件一看，傻眼了，这日志记录完全无法定位错误信息(日志记录不完全，也没有准确记录，没有记录出错的代码行以及相关的方法运行栈信息)。没办法，我只能想办法重新改写记录日志的方式，下面是我记录异常信息日志的方法，可以准确的定位到出错的代码行和方法，以及其运行前后的方法栈信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void uncaughtException(Thread thread, Throwable ex) &#123; String logdir = logPath ; File file = new File(logdir); boolean mkSuccess; if (!file.isDirectory()) &#123; mkSuccess = file.mkdirs(); if (!mkSuccess) &#123; mkSuccess = file.mkdirs(); &#125; &#125; StringBuffer sb = new StringBuffer(); DateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\"); Writer writer = new StringWriter(); PrintWriter printWriter = new PrintWriter(writer); ex.printStackTrace(printWriter); Throwable cause = ex.getCause(); while (cause != null) &#123; cause.printStackTrace(printWriter); cause = cause.getCause(); &#125; printWriter.close(); String result = writer.toString(); sb.append(result); try &#123; String time = formatter.format(new Date()); String logFile = logdir + File.separator + time + \".log\"; FileOutputStream fos = new FileOutputStream(logFile); fos.write(sb.toString().getBytes()); fos.close(); &#125; catch (Exception e) &#123; Log.e(TAG, \"an error occured while writing file...\", e); &#125; if (!handleException(ex) &amp;&amp; mDefaultHandler != null) &#123; mDefaultHandler.uncaughtException(thread, ex); &#125; else &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; Log.e(TAG, \"Error : \", e); &#125; &#125; android.os.Process.killProcess(android.os.Process.myPid()); System.exit(10);&#125; 重新运行了几次，发现每次出错的地方竟然还不一样(但每次出错都是空指针异常引起的)，有时候是调用系统相机的那个Activity的onCreate方法调用的时候出现空指针，有时候是调用系统相机的前面一个Activity的onCreate方法中出现空指针(假设界面A跳到界面B，在B中调用系统相机，出错的时候A和B中的onCreate方法里都有空指针异常信息)，知道出现错误的代码行数这救你好办了，赶紧打好断点准备调试，结果竟然发现不管怎么操作，代码就是不进断点。 代码不进断点，就没法找到问题根源，只能分析代码寻求解决办法了，我在出现空指针错误的地方加上非空判断，重新运行发现这几个地方虽然不出错了，但是又在其他的地方出现空指针异常了，经过分析发现所有出现空指针的地方都是我的自定义Application里面的某几个static引用型变量为空了。分析到这里，在加上前面的代码不进断点以及空指针出现onCreate方法中，猜测是不是应用直接被系统回收了。 调用系统相机的时候，应用被系统回收(Application、处于后台和前台的Activity都被销毁，静态变量全部消失)，此时拍照完成之后重新恢复创建Activity(重新创建的时候，手机与编辑器的调试状态肯定就断掉了，因此通过onCreate重新创建Activity时无法进到断点)，重新调用onCreate时，因为该方法中有用到自定义Application里的static变量(此时已被销毁)，所以会出现空指针异常。至于为什么界面A和B对应的onCreate方法中都会出现空指针，那是因为B调用系统相机完成之后会重新创建，创建失败之后按照Activity的栈顺序会接着创建界面A，而A中的onCreate方法里也用到了自定义Application里的static变量，所以也出现了空指针。 既然知道了问题原因，那就来寻求解决办法，我在onSaveInstanceState(Bundle outState)方法中保存当前Activity里操作过的所有变量信息，然后在重新创建该Activity时通过onRestoreInstanceState(Bundle savedInstanceState)方法来恢复这些数据信息(这两个方法的执行机制请参考我的另外一篇文章：Android基础篇之：Activity生命周期)，同时在onCreate中用到自定义Application里的static变量的地方进行非空判断(为空的时候进行重新初始化)，进过这一系列的代码处理之后，再次运行正常，完美解决问题。 不过在步骤7中解决问题时发现，在处理应用被回收重新创建时要注意如下几点： Activity里用户操作的所有数据全部需要保存 Activity中第一次初始化时获取到的变量也需要保存 用户登陆后所有拥有的相关权限也需要进行处理保存 数据恢复时要考虑当前Activity引用的其他Activity或Application里面的变量的再次初始化 所有自定义对象都最好能被序列化，否则无法进行状态保存 尽量少用static类型的变量 有些服务能不在Application中初始化，最好不要在Application中初始化。 在Application中定义的变量最后都在Application中进行初始化创建，不要部分在Application进行初始化，部分在其他的Activity里进行初始化 应用开发时要考虑到应用被回收的情况，以便真正被回收后能方便的解决(虽然应用被回收的几率很低，但是不排除某些坑爹的手机很容易被回收，就像红米Note一样)。 write by laohu 2015年10月22日","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"相机","slug":"相机","permalink":"http://ittiger.cn/tags/相机/"},{"name":"崩溃","slug":"崩溃","permalink":"http://ittiger.cn/tags/崩溃/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android基础之TableLayout中TextView文本无法自动换行","slug":"Android基础之TableLayout中TextView文本无法自动换行","date":"2015-10-22T14:43:39.000Z","updated":"2016-07-29T01:19:10.922Z","comments":true,"path":"Android基础之TableLayout中TextView文本无法自动换行.html","link":"","permalink":"http://ittiger.cn/Android基础之TableLayout中TextView文本无法自动换行.html","excerpt":"最近项目中用到了TableLayout布局，发现该布局下的TextView控件的内容无法达到自动换行的效果，布局代码如下：","text":"最近项目中用到了TableLayout布局，发现该布局下的TextView控件的内容无法达到自动换行的效果，布局代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:background=\"@drawable/sys_shade_bg_color\" android:orientation=\"vertical\" android:paddingLeft=\"@dimen/gap_20\" android:paddingTop=\"@dimen/gap_30\" android:paddingRight=\"@dimen/gap_20\"&gt; &lt;TableLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"40dp\"&gt; &lt;TableRow android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingBottom=\"10dp\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"right\" android:text=\"@string/about_company_address\" android:textColor=\"@color/white\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:singleLine=\"false\" android:text=\"公司地址1公司地址2公司地址3公司地址4公司地址5公司地址6\" android:textColor=\"@color/white\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingBottom=\"@dimen/gap_10\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"right\" android:text=\"@string/about_company_phone\" android:textColor=\"@color/white\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"XXX-XXXXXXX\" android:textColor=\"@color/white\" /&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt;&lt;/LinearLayout&gt; 这样布局后，理所当然的认为没问题，毕竟我的TextView中添加了singline属性为false，结果发现效果不是我 想要的 查看布局效果，发现跟我预期的不一样，公司地址的文本虽然换行了，但是有部分字被隐藏了没有显示出来，而且可以明显的看到展示公司地址文本的TextView的宽度已经超出了屏幕，很显然这就是导致部分文字没显示出来的原因。 既然子布局TextView的宽度超出了TableLayout的宽度，那就想办法让子布局的宽度根据容器的宽度进行收缩，而TableLayout刚好有个属性shrinkColumns可以设置其子布局的宽度收缩以适应容器的大小。 我设置TableLayout的属性android:shrinkColumns=”1″后，立马就达到了我想要的效果。 另外TableLayout还有个属性stretchColumns是用来设置子布局的宽度进行拉伸适应容器大小的 这两个属性的具体用法，大家自行去补脑吧。","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"TableLayout","slug":"TableLayout","permalink":"http://ittiger.cn/tags/TableLayout/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android基础之Activity生命周期","slug":"Android基础之Activity生命周期","date":"2015-10-08T11:22:06.000Z","updated":"2016-07-29T01:19:10.922Z","comments":true,"path":"Android基础之Activity生命周期.html","link":"","permalink":"http://ittiger.cn/Android基础之Activity生命周期.html","excerpt":"之前一直对Activity的生命周期不是很清楚，感觉很模糊。前两天也看了下任玉刚书里对Activity生命周期的讲解，今天特意写了个程序验证了下Activity的生命周期内各个回调的执行情况，为了避免多段时日又忘了，干脆对这次的理解总结下，俗话说好记性不如烂笔头，没事的时候可以回过头来再看看。 我们先来看一张非常经典的Activity生命周期流程图：","text":"之前一直对Activity的生命周期不是很清楚，感觉很模糊。前两天也看了下任玉刚书里对Activity生命周期的讲解，今天特意写了个程序验证了下Activity的生命周期内各个回调的执行情况，为了避免多段时日又忘了，干脆对这次的理解总结下，俗话说好记性不如烂笔头，没事的时候可以回过头来再看看。 我们先来看一张非常经典的Activity生命周期流程图： Activity的生命周期大致有如下几个成果： 启动Activity：系统会先调用onCreate，然后调用onStart，最后调用onResume，此时Activity进入前台处于运行状态。如图： 当前Activity被其他Activity覆盖，且覆盖的这个Activity是为透明：系统只会调用onPause，此时Activity处于后台可见暂停运行状态。如图： 当前Activity被其他Activity覆盖，且覆盖的这个Activity为非透明：系统处理过程与步骤4中的过程是一样的。如图： 手机锁屏或按下了Home键：系统会先调用onPause，最后调用onStop，此时Activity处于后台非可见暂停运行状态。如图： 如果在步骤2时，用户后退回到了此Activity：系统会调用onResume，此时Activity回到前台继续运行。如图： 如果在步骤3和4时，用户后退或解锁回到了此Activity：系统会调用onRestart，然后调用onStart，最后调用onResume，然后此Activity回到前台继续运行。如图： 当Activity处于被覆盖或后台不可见时(即步骤3和4)，系统内存不足时会杀死该Activity(系统杀死Activity时，步骤3与4的Activity的被杀优先级会比步骤2高)，这时如果用户后退回到该Activity，系统会重新执行onCreate，onStart，onResume进入运行状态。此过程不好验证，不提供图片了。 用户退出Activity时：系统会先执行onPause，然后执行onStop，最后执行onDestory方法结束此Activity的运行。如图： 系统内存不足杀死Activity结束运行时的生命周期函数执行情况我目前无法验证，暂时不是很清楚。 从上面的生命周期过程来看，主要涉及到了7个生命周期函数，下面是我对于每个生命周期主要作用的理解： onCreate：用于Activity的初始化，例如设置布局，初始化相关布局控件等。 onStart：设置Activity窗口可见 onResume：让Activity窗口处于系统前台 onRestart：在Activity由不可见回到可见时，需要通过此方法唤起onStart的执行 onPause：让Activity窗口退出系统前台(参照上面的过程2理解)，与onResume方法刚好是一对 onStop：让Activity窗口不可见(参照上面的过程3和过程4理解)，与onStart方法刚好是一对 onDestory：结束Activity，销毁相关资源 光说了这些理论的东西是不够，只有亲自测试验证过了记忆才够深刻，下面是我测试验证的主要代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class LifeCycle_A_Activity extends Activity &#123; private final String TAG = getClass().getSimpleName(); private Button btn1; private Button btn2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lifecycle_a_layout); btn1 = (Button) findViewById(R.id.btn_lifecycle); btn2 = (Button) findViewById(R.id.btn_lifecycle2); btn1.setText(\"跳转到LifeCycle_B_Activity(透明)\"); btn2.setText(\"跳转到LifeCycle_C_Activity(非透明)\"); btn1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; toAnotherActivity(LifeCycle_B_Activity.class); &#125; &#125;); btn2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; toAnotherActivity(LifeCycle_C_Activity.class); &#125; &#125;); Log.i(TAG, \"LifeCycle----onCreate\"); &#125; public void toAnotherActivity(Class&lt;?&gt; claxx) &#123; startActivity(new Intent(LifeCycle_A_Activity.this, claxx)); &#125; @Override protected void onStart() &#123; super.onStart(); Log.i(TAG, \"LifeCycle----onStart\"); &#125; @Override protected void onRestart() &#123; super.onRestart(); Log.i(TAG, \"LifeCycle----onRestart\"); &#125; @Override protected void onResume() &#123; super.onResume(); Log.i(TAG, \"LifeCycle----onResume\"); &#125; @Override protected void onStop() &#123; super.onStop(); Log.i(TAG, \"LifeCycle----onStop\"); &#125; @Override protected void onPause() &#123; super.onPause(); Log.i(TAG, \"LifeCycle----onPause\"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); Log.i(TAG, \"LifeCycle----onDestroy\"); &#125; @Override protected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState); outState.putInt(\"stateParam\", 1); Log.i(TAG, \"LifeCycle----onSaveInstanceState,save value is:\" + 1); &#125; @Override protected void onRestoreInstanceState(Bundle savedInstanceState) &#123; super.onRestoreInstanceState(savedInstanceState); int value = savedInstanceState.getInt(\"stateParam\"); Log.i(TAG, \"LifeCycle----onRestoreInstanceState,restore value is:\" + value); &#125; @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); Log.i(TAG, \"LifeCycle----onWindowFocusChanged, focus is:\" + hasFocus); &#125;&#125; 该Activity对应的布局文件代码如下：123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center_horizontal\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/btn_lifecycle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;Button android:id=\"@+id/btn_lifecycle2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/LinearLayout&gt; Activity跳转后覆盖的透明与非透明的Activity代码及布局文件如下： 1234567891011121314151617181920212223242526//透明的Activity，在注册Activity时需要添加theme属性//android:theme=\"@android:style/Theme.Translucent\"public class LifeCycle_B_Activity extends Activity &#123; private Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lifecycle_b_layout); btn = (Button) findViewById(R.id.btn_lifecycle); btn.setText(\"当前为LifeCycle_B_Activity(透明)\"); &#125;&#125; //非透明的Activitypublic class LifeCycle_C_Activity extends Activity &#123; private Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_lifecycle_b_layout); btn = (Button) findViewById(R.id.btn_lifecycle); btn.setText(\"当前为LifeCycle_C_Activity(非透明)\"); &#125;&#125; 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/btn_lifecycle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/LinearLayout&gt; 很明显，上面的验证代码中我多写了三个方法onWindowFocusChanged，onSaveInstanceState，onRestoreInstanceState，这三个方法都不属于Activity生命周期函数，只是这三个函数在Activity生命周期变化时，对于我们的应用开发还是紧密相关的，所以我给加进来一起看下他们的执行时机。 onWindowFocusChanged：看名字就可以知道，这个函数是Activity窗体焦点发生变化时的回调，比如Activity在前台显示，被覆盖，手机截屏，按下Home键等等，都会触发该方法。再结合我上面生命周期过程验证结果，其实更容易理解，该函数只会在Activity是否前台显示发生变化时触发，也就是在onResume或onPause调用后触发该函数。当我们想在Activity初始化时获取某个特定组件的大小时，在onCreate中是无法获取的，因为这个时候Window对象还没有创建完成，这个时候，我们可以通过onWindowFocusChanged函数来获取指定组件的大小。 `onSaveInstanceState： 当系统资源不足杀死Activity时会调用该函数。 当屏幕方向发生变化时也会调用该函数。 当Activity被覆盖或锁屏或按下Home键时都会调用该函数。该方法主要用于保存当前窗体各个视图组件View的状态信息，当然我们也可以手动保存一些临时变量以避免资源不足Activity被杀死或屏幕发生变化后无法恢复到之前状态。根据上面的生命周期过程验证发现onSaveInstanceState是在Activity由前台显示变为不显示时触发，也就是在onPause调用后触发该函数。这个也很容易理解，当Activity由前台显示变为后台显示时，只有先将当前的窗体各个视图组件状态保存起来，系统后续恢复起来才有依据才知道恢复到什么样子。 onRestoreInstanceState：该函数与onSaveInstanceState相对的，它主要用于恢复用户保存的一些临时数据以及系统之前通过onSaveInstanceState保存的各个组件的状态信息。此方法目前经过验证只在屏幕方向发生变化时才会调用。系统资源不足杀死Activity后重新恢复创建Activity这种情况无法验证，这种情况是否执行待验证。 屏幕方向发生变化时验证如下结果如下图(在手机设置中先设置为自动旋转屏幕，在AndroidMainfest.xml中注册Activity时不要设置android:screenOrientation属性)： 上面日志中清晰的记载了Activity销毁之前保存的临时变量通过onRestoreInstanceState可用获取得到。 write by laohu 2015年10月8日21:56:06","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Activity","slug":"Activity","permalink":"http://ittiger.cn/tags/Activity/"},{"name":"生命周期","slug":"生命周期","permalink":"http://ittiger.cn/tags/生命周期/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"简单实用的Android ORM框架TigerDB","slug":"简单实用的Android-ORM框架TigerDB","date":"2015-10-01T10:16:48.000Z","updated":"2016-08-04T07:50:08.194Z","comments":true,"path":"简单实用的Android-ORM框架TigerDB.html","link":"","permalink":"http://ittiger.cn/简单实用的Android-ORM框架TigerDB.html","excerpt":"TigerDB是一个简单的Android ORM框架，它能让你一句话实现数据库的增删改查，同时支持实体对象的持久化和自动映射，同时你也不必关心表结构的变化，因为它会自动检测新增字段来更新你的表结构。 该库主要包括如下几个要点： 根据实体对象自动建表、新增字段(SQLite不支持删除字段列) 支持注解配置表名、字段名、字段默认值、主键是否自增长以及哪些字段不作为数据表中的映射字段 直接映射实体对象到SQLite数据库，实现一行代码对SQLite数据库增删改查 支持在SDCard中新建数据库db 解决在onCreate，onUpgrade中执行数据库其他操作时出现的异常(java.lang.IllegalStateException: getDatabase called recursively) 支持原生SQL语句操作数据库","text":"TigerDB是一个简单的Android ORM框架，它能让你一句话实现数据库的增删改查，同时支持实体对象的持久化和自动映射，同时你也不必关心表结构的变化，因为它会自动检测新增字段来更新你的表结构。 该库主要包括如下几个要点： 根据实体对象自动建表、新增字段(SQLite不支持删除字段列) 支持注解配置表名、字段名、字段默认值、主键是否自增长以及哪些字段不作为数据表中的映射字段 直接映射实体对象到SQLite数据库，实现一行代码对SQLite数据库增删改查 支持在SDCard中新建数据库db 解决在onCreate，onUpgrade中执行数据库其他操作时出现的异常(java.lang.IllegalStateException: getDatabase called recursively) 支持原生SQL语句操作数据库 该ORM库使用过程中的主要类说明： SQLiteDBConfig：主要用于设置数据库的名字、创建路径、版本号、数据创建更新时的监听 SQLiteDB：创建完数据库之后，主要通过此类来操作数据库的增删改查 SQLiteDBFactory：该类主要用于创建SQLite数据库，同时缓存当前创建的SQLiteDB对象 CursorUtil：查询数据库时，检测游标对象Cursor是否正常，解析Cursor数据为实体对象 IDBListener：数据库创建、升级时的监听类，提供了空实现SimpleDBListener Column：该注解用来设置字段名、字段默认值 PrimaryKey：该注解用来设置主键、主键字段名、以及主键是否为自增长 Table：该注解用来设置表名，不设置的话默认类名为表名 NotDBColumn：该注解用来设置哪些实体属性不映射到数据表中 主要用法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//新建实体，可以通过注解@Table设置表名,如果不设置默认以类名User作为表名public class User &#123; //设置主键id为自增长，也可以通过注解@Column设置字段名或字段默认值 @PrimaryKey(isAutoGenerate=true) private long id; private String name; //设置age字段默认值为1 @Column(defaultValue=\"1\") private int age; //该字段不作为数据表中的字段 @NotDBColumn private String bz; //必须实现无参构造 public User() &#123; &#125; public User(String name) &#123; super(); this.name = name; &#125; public long getId() &#123; return id; &#125; public void setId(long id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"&#123;id=\" + id + \",name=\" + name + \"&#125;\"; &#125;&#125; //SQLite相关配置，包括数据库名字、创建路径、版本号、数据创建和升级时的监听SQLiteDBConfig config = new SQLiteDBConfig(this);//设置数据库创建更新时的监听，有提供空实现：SimpleDBListenerconfig.setDbListener(new IDBListener() &#123; @Override public void onUpgradeHandler(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; @Override public void onDbCreateHandler(SQLiteDatabase db) &#123; showLongToast(\"数据库创建成功\"); &#125; &#125;); //创建db，在创建数据库的时候，不需要在onDbCreateHandler手动去创建相关的数据表，在对实体对象进行数据操作的时候，会自动判断表是否存在，不存在的话会自动创建，同时如果有新增的字段也会自动更新表结构 SQLiteDB db = SQLiteDBFactory.createSQLiteDB(config); //保存单个实体对象User user = new User(\"添加单个对象\");int rtn = db.save(user) //保存集合对象List list = new ArrayList();int rtn = db.save(list) //查询User表中的所有数据List list = db.queryAll(User.class); //根据实体id(主键)查询UserUser user = db.query(User.class, \"1\"); //查询User表中的数据总数long total = db.queryTotal(User.class); //删除指定实体对象db.delete(user); //更新实体对象db.update(user); //分页查询db.queryPage(claxx, curPage, pageSize); //根据SQL查询Cursor cursor = db.query(sql, bindArgs)； 源码及Demo地址：https://github.com/huyongli/TigerDB，大家可以自行下载查看 如果大家有什么疑问和建议，欢迎提出 write by laohu 2015年9月28日","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"SQLite","slug":"SQLite","permalink":"http://ittiger.cn/tags/SQLite/"},{"name":"ORM","slug":"ORM","permalink":"http://ittiger.cn/tags/ORM/"},{"name":"TigerDB","slug":"TigerDB","permalink":"http://ittiger.cn/tags/TigerDB/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"WordPress安装插件提示无法定位WordPress内容目录（wp-content）","slug":"WordPress安装插件提示无法定位WordPress内容目录（wp-content）","date":"2015-09-30T14:05:53.000Z","updated":"2016-09-29T02:01:24.784Z","comments":true,"path":"WordPress安装插件提示无法定位WordPress内容目录（wp-content）.html","link":"","permalink":"http://ittiger.cn/WordPress安装插件提示无法定位WordPress内容目录（wp-content）.html","excerpt":"","text":"在我刚把WordPress环境搭建好后，安装插件的时候提示如下错误信息： WordPress安装插件提示无法定位WordPress内容目录（wp-content），最后找网上搜索之后，发现下面的方法可行： 在WordPress配置文件 wp-config.php最后加上如下代码： 123//-----无法定位WordPress Content目录(wp-content) 解决方案---------begin if(is_admin()) &#123;add_filter('filesystem_method', create_function('$a', 'return \"direct\";' ));define( 'FS_CHMOD_DIR', 0751 );&#125; //-----无法定位WordPress Content目录(wp-content) 解决方案---------end","categories":[{"name":"Blog","slug":"Blog","permalink":"http://ittiger.cn/categories/Blog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/tags/Linux/"},{"name":"阿里云","slug":"阿里云","permalink":"http://ittiger.cn/tags/阿里云/"},{"name":"WordPress","slug":"WordPress","permalink":"http://ittiger.cn/tags/WordPress/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"http://ittiger.cn/categories/Blog/"}]},{"title":"WordPress安装插件提示无法创建目录","slug":"WordPress安装插件提示无法创建目录","date":"2015-09-29T12:05:53.000Z","updated":"2016-09-29T02:01:34.633Z","comments":true,"path":"WordPress安装插件提示无法创建目录.html","link":"","permalink":"http://ittiger.cn/WordPress安装插件提示无法创建目录.html","excerpt":"出现这个问题有几种可能： 服务器没有安装vsftpd服务，很明显我装了 vsftpd的用户没有对plugin目录的写权限，检查之后发现我新建的用户是有这个权限的 如果没有写权限的话，需要对WordPress的目录 /var/www/html/wp-content/plugins赋予写权限的，我们来个直接的运行命令： chmod 777 /var/www/html/wp-content/plugins，主要是的第三个7起作用，对其他用户赋予读写权限 最后检查发现我的vsftpd.conf配置文件中 chroot_local_user的值设置成了No， 该配置表示我的本地Ftp用户不能切换到ftp主目录外的其他目录，而我的ftp主目录与WordPress的Plugin的目录明显不是同一个。既然该用户都不能切换目录，如何到Plugin目录进行写操作呢，所以立马更改该配置为YES，再次安装插件就成功了 另外，如果还不行的话可以检查下vsftpd.conf配置文件中 chroot_list_enable的值，如果chroot_list_enable=YES该配置表示 /etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录。","text":"出现这个问题有几种可能： 服务器没有安装vsftpd服务，很明显我装了 vsftpd的用户没有对plugin目录的写权限，检查之后发现我新建的用户是有这个权限的 如果没有写权限的话，需要对WordPress的目录 /var/www/html/wp-content/plugins赋予写权限的，我们来个直接的运行命令： chmod 777 /var/www/html/wp-content/plugins，主要是的第三个7起作用，对其他用户赋予读写权限 最后检查发现我的vsftpd.conf配置文件中 chroot_local_user的值设置成了No， 该配置表示我的本地Ftp用户不能切换到ftp主目录外的其他目录，而我的ftp主目录与WordPress的Plugin的目录明显不是同一个。既然该用户都不能切换目录，如何到Plugin目录进行写操作呢，所以立马更改该配置为YES，再次安装插件就成功了 另外，如果还不行的话可以检查下vsftpd.conf配置文件中 chroot_list_enable的值，如果chroot_list_enable=YES该配置表示 /etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录。 chroot_local_user配置与chroot_list_enable配置通过搭配能实现以下几种效果： ①当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。 ②当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。 ③当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。 ④当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录 如果WordPress上传多媒体文件(图片)时提示无法建立目录wp-content/uploads…，则可以将目录 /var/www/html/wp-contents的权限也赋予为读写权限","categories":[{"name":"Blog","slug":"Blog","permalink":"http://ittiger.cn/categories/Blog/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/tags/Linux/"},{"name":"阿里云","slug":"阿里云","permalink":"http://ittiger.cn/tags/阿里云/"},{"name":"WordPress","slug":"WordPress","permalink":"http://ittiger.cn/tags/WordPress/"}],"keywords":[{"name":"Blog","slug":"Blog","permalink":"http://ittiger.cn/categories/Blog/"}]},{"title":"阿里云服务器安装vsftpd","slug":"阿里云服务器安装vsftpd","date":"2015-09-28T14:01:48.000Z","updated":"2016-08-04T07:50:08.226Z","comments":true,"path":"阿里云服务器安装vsftpd.html","link":"","permalink":"http://ittiger.cn/阿里云服务器安装vsftpd.html","excerpt":"运行命令：yun install vsftpd 安装vsftpd 将vsftpd设置为开机启动：chkconfig vsftpd on 启动vsftpd服务： service vsftpd start 管理vsftpd相关服务： 停止：service vsftpd stop 重启：service vsftpd restart","text":"运行命令：yun install vsftpd 安装vsftpd 将vsftpd设置为开机启动：chkconfig vsftpd on 启动vsftpd服务： service vsftpd start 管理vsftpd相关服务： 停止：service vsftpd stop 重启：service vsftpd restart 为vsftpd添加用户，用户名为ftpuser，设置其主目录为/home/ftp： 运行命令：useradd -d /home/ftp -g ftp -s /sbin/nologin ftpuser 设置该用户的密码：passwd ftpuser 配置vsftpd服务，只允许刚刚新添加的用户ftpuser登陆ftp服务，其默认主配置文件在：/etc/vsftpd/vsftpd.conf userlist_enable=YES # 是否启用vsftpd.user_list文件 userlist_deny=NO # 决定vsftpd.user_list文件中的用户是否能够访问FTP服务器。若设置为YES，则vsftpd.user_list文件中的用户不允许访问FTP，若设置为NO，则只有vsftpd.user_list文件中的用户才能访问FTP 将 /etc/vsftpd/user_list文件中的所有用户全部注释掉，添加刚刚添加的用户ftpuser，如下： 123456789101112131415161718192021# vsftpd userlist # If userlist_deny=NO, only allow users in this file# If userlist_deny=YES (default), never allow users in this file, and # do not even prompt for a password. # Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers # for users that are denied.#root #bin#daemon #adm#lp #sync #shutdown #halt #mail #news #uucp #operator #games #nobody ftpuser 配置到这里，就可以远程用FTP客户端登录并上传文件，文件会保存在ftpuser的主目录，也就是/home/ftp","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/tags/Linux/"},{"name":"阿里云","slug":"阿里云","permalink":"http://ittiger.cn/tags/阿里云/"},{"name":"WordPress","slug":"WordPress","permalink":"http://ittiger.cn/tags/WordPress/"},{"name":"vsftpd","slug":"vsftpd","permalink":"http://ittiger.cn/tags/vsftpd/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/categories/Linux/"}]},{"title":"阿里云服务器安装MySQL","slug":"阿里云服务器安装MySQL","date":"2015-09-28T13:55:23.000Z","updated":"2016-08-04T07:50:08.222Z","comments":true,"path":"阿里云服务器安装MySQL.html","link":"","permalink":"http://ittiger.cn/阿里云服务器安装MySQL.html","excerpt":"运行命令：yun install mysql 安装MySQL客户端 紧接着运行命令：yun install mysql-server 安装MySQL服务 运行命令：chkconfig –levels 235 mysqld on 让MySQL服务可以自动启动 运行命令：/etc/init.d/mysqld start 立刻启动MySQL服务","text":"运行命令：yun install mysql 安装MySQL客户端 紧接着运行命令：yun install mysql-server 安装MySQL服务 运行命令：chkconfig –levels 235 mysqld on 让MySQL服务可以自动启动 运行命令：/etc/init.d/mysqld start 立刻启动MySQL服务 设置MySQL的root密码，运行命令/usr/bin/mysqladmin -u root password ‘new-password’，其中’new-password’是新设的密码，如123456 安装完成之后，MySQL的安装路径为：/usr/share/mysql/ 其主配置文件在： /etc/my.cnf 如果要MySQL支持中文，还需要进行相关字符配置，即在主配置文件/etc/my.cnf中添加如下两行配置：12character_set_server = utf8default-character-set=utf8 如果想通过自己机器上的客户端远程连接MySQL(阿里云默认是不允许远程连接的)，还需要做相关配置： 在服务器上本地登陆MySQL：mysql -u root -p … 切换到系统数据库：use mysql 将user表中的host设置为%表示任何ip都能连接mysql12update user set host=’%’ where user=’root’ and host=’localhost’;flush privileges; #刷新权限表，使配置生效 如果想关掉远程连接，按照上面的方式将host设置为localhost就可以了 update user set host=’localhost’ where user=’root’; 可以参考阿里云的官方bbs: 阿里云服务器新手入门","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/tags/Linux/"},{"name":"阿里云","slug":"阿里云","permalink":"http://ittiger.cn/tags/阿里云/"},{"name":"WordPress","slug":"WordPress","permalink":"http://ittiger.cn/tags/WordPress/"},{"name":"MySQL","slug":"MySQL","permalink":"http://ittiger.cn/tags/MySQL/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/categories/Linux/"}]},{"title":"阿里云服务器安装Apache","slug":"阿里云服务器安装Apache","date":"2015-09-27T13:51:04.000Z","updated":"2016-08-04T07:50:08.201Z","comments":true,"path":"阿里云服务器安装Apache.html","link":"","permalink":"http://ittiger.cn/阿里云服务器安装Apache.html","excerpt":"","text":"使用阿里云自带的安装命令：yun install httpd安装完成之后运行命令：chkconfig --levels 235 httpd on上面的命令可以让Apache开机自动启动。运行命令：/etc/init.d/httpd start 让Apache立刻启动 启动过程中如果出现Could not reliably determine the server&#39;s fully qualified domain name, using 10.161.94.31 for ServerName提示，则将Apache安装目录/etc/httpd/conf/下的httpd.conf文件中的#ServerName localhost:80注释去掉即可，或是添加一行ServerName localhost:80 阿里云上Apache安装路径为/etc/httpd/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/tags/Linux/"},{"name":"阿里云","slug":"阿里云","permalink":"http://ittiger.cn/tags/阿里云/"},{"name":"WordPress","slug":"WordPress","permalink":"http://ittiger.cn/tags/WordPress/"},{"name":"Apache","slug":"Apache","permalink":"http://ittiger.cn/tags/Apache/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://ittiger.cn/categories/Linux/"}]},{"title":"Android基础之点击两次返回键退出程序","slug":"Android基础之点击两次返回键退出程序","date":"2015-09-27T10:40:05.000Z","updated":"2016-07-29T01:19:10.938Z","comments":true,"path":"Android基础之点击两次返回键退出程序.html","link":"","permalink":"http://ittiger.cn/Android基础之点击两次返回键退出程序.html","excerpt":"Android应用中退出应用程序通常有两种做法，一种是使用选择对话框询问用户是否退出应用程序，另外一种是快速点击返回按钮两次然后退出应用。其中第二种实现方式较为普遍，而且我个人认为这种方式用户体验性要好点。下面，我介绍两种常用的点击两次返回退出应用的实现方式。","text":"Android应用中退出应用程序通常有两种做法，一种是使用选择对话框询问用户是否退出应用程序，另外一种是快速点击返回按钮两次然后退出应用。其中第二种实现方式较为普遍，而且我个人认为这种方式用户体验性要好点。下面，我介绍两种常用的点击两次返回退出应用的实现方式。 通过标识变量进行控制。首先定义一个布尔变量，赋初始值false。然后监听手机返回按钮，当点击返回按钮时，如果该布尔变量值为false，则把这个变量置为true；如果该变量为true，则退出程序。最后定义一个时间任务，2秒执行一次，如果布尔变量为true，则重置为false。这里定义一个循环周期为2秒的任务是为了达到快速点击两次的效果。这样，在第一次点击返回按钮时，仅仅改变布尔值变量，而不会退出，第二次点击才会退出。如果用户点击了一次，那么2秒之后布尔变量又被重置为false，只有2秒内的两次点击才会退出程序。代码如下： 123456789101112131415161718192021private static Boolean isQuit = false;private Timer timer = new Timer();@Overridepublic void onBackPressed() &#123; if (isQuit == false) &#123; isQuit = true; Toast.makeText(getBaseContext(), \"再按一次返回键退出程序\", Toast.LENGTH_SHORT).show(); TimerTask task = null; task = new TimerTask() &#123; @Override public void run() &#123; isQuit = false; &#125; &#125;; timer.schedule(task, 2000); &#125; else &#123; finish(); System.exit(0); android.os.Process.killProcess(android.os.Process.myPid()); &#125;&#125; 通过两次点击返回按钮时的时间间隔进行判断。这种实现方式主要是用第二次点击返回按钮时的时间减去第一次点击的返回按钮时的时间，看这个时间差是否大于2秒，如果大于2秒则提示需要再点击一次才能退出，如果时间差小于等于2秒，则退出应用，实现代码如下： 123456789101112private long exitTime = 0;@Overridepublic void onBackPressed() &#123; if(System.currentTimeMillis() - exitTime &gt; 2000) &#123; Toast.makeText(this, \"再按一次退出程序\", Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &#125; else &#123; finish(); System.exit(0); android.os.Process.killProcess(android.os.Process.myPid()); &#125;&#125; 我个人认为第二种实现方式更简单，更好理解，推荐使用这种实现方式。","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"退出App","slug":"退出App","permalink":"http://ittiger.cn/tags/退出App/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android调用相机无法执行onActivityResult或data为null","slug":"Android调用相机无法执行onActivityResult或data为null","date":"2015-09-26T13:44:09.000Z","updated":"2016-07-29T01:19:10.953Z","comments":true,"path":"Android调用相机无法执行onActivityResult或data为null.html","link":"","permalink":"http://ittiger.cn/Android调用相机无法执行onActivityResult或data为null.html","excerpt":"最近项目中调用系统相机时遇到了这么个问题：红米手机无法执行onActivityResult回调，部分华为手机无法获取到照片数据，最后各种分析，各种网上搜索资料折腾了好久，最后终于把问题解决，当看到问题的最终原因时，我也是醉了，简直就是坑爹坑大发了。 最开始用红米手机调用系统相机的时，当我拍照完成点击那个勾勾始终无法返回到前面的界面上，也就是无法调用onActivityResult函数取到拍照的照片，在网上搜索了一圈，没找到解决办法，都说是红米的系统问题，无法解决，项目比较紧张，刚好客户的手机全部是统一型号的华为荣耀6Plus，这个问题丢着暂时没管了。后来现场同事批量测试机器时，发现有3台手机可以拍照，但是在onActivityResult回调中获取到的照片数据为null，但是其他的同型号手机又没这个问题，这问题看着真是坑爹啊。","text":"最近项目中调用系统相机时遇到了这么个问题：红米手机无法执行onActivityResult回调，部分华为手机无法获取到照片数据，最后各种分析，各种网上搜索资料折腾了好久，最后终于把问题解决，当看到问题的最终原因时，我也是醉了，简直就是坑爹坑大发了。 最开始用红米手机调用系统相机的时，当我拍照完成点击那个勾勾始终无法返回到前面的界面上，也就是无法调用onActivityResult函数取到拍照的照片，在网上搜索了一圈，没找到解决办法，都说是红米的系统问题，无法解决，项目比较紧张，刚好客户的手机全部是统一型号的华为荣耀6Plus，这个问题丢着暂时没管了。后来现场同事批量测试机器时，发现有3台手机可以拍照，但是在onActivityResult回调中获取到的照片数据为null，但是其他的同型号手机又没这个问题，这问题看着真是坑爹啊。 远程调试代码后发现，我在调用系统相机时设置的照片存放目录无法创建成功，我调用系统相机的代码如下：12345678910111213public void takePicture() &#123; //照片存放目录 File file = new File(mPicDirectory); if(!file.exists()) &#123;//目录不存在则创建该目录及其不存在的父目录 file.mkdirs(); &#125; Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); mPicName = getPictureName();//获取照片名称 mPicPath = mPicDirectory + mPicName;//照片存储路径 //将照片保存到mPicPath位置 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(mPicPath))); startActivityForResult(intent, CODE_RESULT_TAKE_PHOTO);&#125; 我调试的时候在onActivityResult回调里通过照片路径获取Bitmap对象的时候发现获取到的Bitmap对象一直为null，所以就猜想是不是照片没保存成功，我在文件管理系统里去找这个照片的时候发现，连照片存储目录mPicDirectory都不存在，我再次跟踪代码发现file.mkdirs()始终返回的都是false。看来问题的最终原因是这个：无法创建目录和文件(华为手机系统在拍照输出的时候，如果输出文件路径不存在时竟然没有任何提示和异常，这点对于发现问题的根源有点困难)。然后我又去检查了权限、手机设置里面的权限等所有有可能涉及的问题，结果依然没有效果。既然这些都不是导致目录创建失败的原因，那会不会是目录路径本身不正确呢，我的目录路径是这样获取的： 12345678910111213141516171819202122232425262728String mPicDirectory = FileManager.getPath() + Configuration.SYS_PHOTO_PATH; //FileManager的部分代码是这样的，这个代码是以前的同事写的，没有细看过： public static String getPath()&#123; boolean sdCardExist = Environment.getExternalStorageState() .equals(android.os.Environment.MEDIA_MOUNTED); //判断sd卡是否存在 return !sdCardExist ? MOBILE_PATH : SD_PATH;&#125; //sdcard路径private static String SD_PATH = Environment.getExternalStorageDirectory().getAbsolutePath(); //应用数据路径public static final String MOBILE_PATH = Environment.getDataDirectory().getAbsolutePath(); //这里有一段静态代码块static&#123; File f = new File(\"/storage/sdcard1\"); if(f.exists())&#123; long size = getFreeSize(\"/storage/sdcard1\"); long sd0Size = getFreeSize(\"/storage/sdcard0\"); if(size &gt; sd0Size)&#123; SD_PATH = \"/storage/sdcard1\"; &#125; &#125;&#125; 当我看到上面的静态代码块的时候，我立马就知道了问题的原因，静态代码块中做了一个剩余空间判断，选取的是空间比较大的那个sdcard路径，而且代码都是写死的Environment.getExternalStorageDirectory().getAbsolutePath()系统这个代码是获取手机里的内置SDCard的路径，我的红米手机自己又额外插了一张内存卡，这个是手机的外接SDCard，用Environment.getExternalStorageDirectory()获取到只是手机自带的外置SDCard路径，不能获取自己插入的内存卡路径，我的手机通过Environment.getExternalStorageDirectory()方式获取的路径是/storage/sdcard0（我手机内置的SDCard），而通过可用空间比较之后发现该卡的可用空间少于/storage/sdcard1（我自己插入的SDCard），所以最终路径变成了/storage/sdcard1，而在Android4.4以上后，不允许三方App对外接的SDCard进行操作，因此我们队最后得到的这个目录是没有写入权限的，所以我创建照片存储目录的时候一直失败，所以拍照的时候照片数据没有地方可以输出，华为手机是直接体现在照片数据无法获取，而红米手机则是直接不允许返回到前面的调用界面。 Google在Android中限制三方App操作外接SDCard的原文如下： The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions. 后来想了想，调用相机这么简单的一个功能，红米的系统应该不可能给阉割掉，所以出了问题还是老老实实的先找自己代码的问题吧。至于那个外接SDCard的写入权限还有待寻找答案。 系统内置SDCard写入、删除、读写权限： 1234//文件创建、删除权限&lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" /&gt;//文件读写权限，只针对于手机内存的SDCard，对外接SDCard无效&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"相机","slug":"相机","permalink":"http://ittiger.cn/tags/相机/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android基础之解压zip中文乱码处理","slug":"Android基础之解压zip中文乱码处理","date":"2015-09-26T13:34:09.000Z","updated":"2016-07-29T01:19:10.938Z","comments":true,"path":"Android基础之解压zip中文乱码处理.html","link":"","permalink":"http://ittiger.cn/Android基础之解压zip中文乱码处理.html","excerpt":"####乱码原因分析一般我们使用的Windows系统外部文件默认都是GBK编码方式，Mac系统默认的好像是UTF-8(同事的电脑就是，不知道其他人的是不是)，Linux的没验证过，这里我讨论的是Windows下打包的zip文件。 Java中自带的ZipEntry解压缩的编码方式是UTF-8，而且没有可以自定义编码方式的接口，所以当我们使用UTF-8编码去解压缩GBK编码的文件的时，解压缩出来的中文部分当然是乱码，所以Mac上打包的zip用Java的自带解压缩接口解压出来是没有问题的。","text":"####乱码原因分析一般我们使用的Windows系统外部文件默认都是GBK编码方式，Mac系统默认的好像是UTF-8(同事的电脑就是，不知道其他人的是不是)，Linux的没验证过，这里我讨论的是Windows下打包的zip文件。 Java中自带的ZipEntry解压缩的编码方式是UTF-8，而且没有可以自定义编码方式的接口，所以当我们使用UTF-8编码去解压缩GBK编码的文件的时，解压缩出来的中文部分当然是乱码，所以Mac上打包的zip用Java的自带解压缩接口解压出来是没有问题的。 ####解决方式找到了问题所在，解决方式也就比较简单了，既然是编码方式不同导致的，那我们保证编码方式统一即可，压缩zip时系统编码很难改变，那我们就从解压缩的编码方式入手，自定义解压缩的编码。 Apache中是有完整的替代解决方式的，但是Apache的包相对于Android说有点偏大不适合于Android环境，我们只需要找到解压缩的那部分代码进行改造即可，我这里找到了一个改造好的解压缩替代包，测试可行。示例代码如下：1234567891011121314151617181920212223242526272829303132333435363738import com.file.zip.ZipEntry;import com.file.zip.ZipFile;/** * @param file 待解压文件 * @param dir 解压后文件的存放目录 * @throws IOException */public void unzip(File file, String dir) throws IOException &#123; ZipFile zipFile = new ZipFile(file, \"GBK\");//设置压缩文件的编码方式为GBK Enumeration&lt;ZipEntry&gt; entris = zipFile.getEntries(); ZipEntry zipEntry = null; File tmpFile = null; BufferedOutputStream bos = null; InputStream is = null; byte[] buf = new byte[1024]; int len = 0; while (entris.hasMoreElements()) &#123; zipEntry = entris.nextElement(); // 不进行文件夹的处理,些为特殊处理 tmpFile = new File(dir + zipEntry.getName()); if (zipEntry.isDirectory()) &#123;//当前文件为目录 if (!tmpFile.exists()) &#123; tmpFile.mkdir(); &#125; &#125; else &#123; if (!tmpFile.exists()) &#123; tmpFile.createNewFile(); &#125; is = zipFile.getInputStream(zipEntry); bos = new BufferedOutputStream(new FileOutputStream(tmpFile)); while ((len = is.read(buf)) &gt; 0) &#123; bos.write(buf, 0, len); &#125; bos.flush(); bos.close(); &#125; &#125;&#125; 改造后的ZipEntry.jar包的下载地址：http://download.csdn.net/detail/huyongl1989/9120755 write by laohu2015-09-26 21:34:09","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Zip解压","slug":"Zip解压","permalink":"http://ittiger.cn/tags/Zip解压/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"Android基础之shape使用","slug":"Android基础之shape使用","date":"2015-09-26T06:17:42.000Z","updated":"2016-07-29T01:19:10.922Z","comments":true,"path":"Android基础之shape使用.html","link":"","permalink":"http://ittiger.cn/Android基础之shape使用.html","excerpt":"Android中的shape标签用于描述形状，可以在布局文件layout和选择器selector中使用，它有6个子标签，具体如下：","text":"Android中的shape标签用于描述形状，可以在布局文件layout和选择器selector中使用，它有6个子标签，具体如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;!-- 设置圆角效果 --&gt; &lt;corners android:radius=\"5dp\"/&gt; &lt;!-- 设置背景渐变色 --&gt; &lt;gradient android:startColor=\"@color/red\" android:endColor=\"@color/black\" android:centerColor=\"@color/white\" android:angle=\"-90\" android:gradientRadius=\"90\"/&gt; &lt;!-- 边距间隔 --&gt; &lt;padding android:left=\"10dp\" android:top=\"10dp\" android:right=\"10dp\" android:bottom=\"10dp\"/&gt; &lt;!-- 大小 --&gt; &lt;size android:width=\"20dp\" android:height=\"20dp\"/&gt; &lt;!-- 背景填充色 --&gt; &lt;solid android:color=\"@color/red\"/&gt; &lt;!--边框线 --&gt; &lt;stroke android:color=\"@color/black\" android:width=\"2dp\"/&gt;&lt;/shape&gt; shape：根节点 有一个shape属性，可以设置不同的形状 android:shape=&quot;line&quot;：设置shape为线形（包括实线、虚线） android:shape=&quot;rectangle&quot;：设置shape为矩形 android:shape=&quot;oval&quot;：设置shape为椭圆形 android:shape=&quot;ring&quot;：设置shape为环形 corners子节点：设置圆角效果 android:radius：圆角的半径 gradient子节点：背景渐变色 android:startColor：渐变起始色 android:endColor：渐变结束色 android:centerColor:渐变过程中中间的颜色 android:angle:渐变的角度朝向(45的倍数)，默认朝向为从左至右，每增加45度，则逆时针转动45度开始渐变 android:gradientRadius:这个属性还不知道是什么意思 padding子节点：边距，该标签的几个属性就比较常用比较简单了，就不描述了 size子节点：大小，这个标签的属性也比较简单 solid子节点：背景填充色 android:color:背景颜色，设置该标签属性之后，gradient标签将不会起作用 stroke子节点：线（可以设置控件的边框，也可以设置一条实线或虚线） android:color：线的颜色 android:width：线的宽度 android:dashGap：虚线间的间距 android:dashWidth：每个虚线段的长度（当设置为虚线的时候，最好不要设置android:width属性） 一般比较常用的是边线，填充色，背景色这三个标签 如果要为某个控件设置背景边框、渐变色、填充色或者是通过View设置控件间的分割线，都可以使用shape配合selector来进行实现","categories":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/tags/Android/"},{"name":"Shape","slug":"Shape","permalink":"http://ittiger.cn/tags/Shape/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://ittiger.cn/categories/Android/"}]},{"title":"浅谈JSONP跨域请求","slug":"浅谈JSONP跨域请求","date":"2015-03-20T05:47:20.000Z","updated":"2016-07-29T01:19:11.100Z","comments":true,"path":"浅谈JSONP跨域请求.html","link":"","permalink":"http://ittiger.cn/浅谈JSONP跨域请求.html","excerpt":"第一次听说JSONP跨域请求还是去年刚入职实习的时候，也借那个机会在网上好好了解了下用法，但是对于其如何实现还是不太明白。昨天一同事问我当时对JSONP的使用情况，突然发现一年多没用，对于这个跨域请求技术又忘的差不多了，刚好不知道这个星期该写篇什么方面的文章，那就趁这个机会再把JSONP琢磨琢磨顺便把过程记录下来，免得下次不记得了又得到网上到处找资源查阅。 OK，进入正题！！！！ 先看JSONP定义 JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的&lt;script&gt; 元素是一个例外。利用 &lt;script&gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。JSONP它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。——来自百度 同源策略 同源策略是一种约定，也是浏览器本身最核心最基本的一个安全功能。所谓同源是指协议、域名、端口相同，也就是说同源策略不允许一个站点的某个文档或脚本加载请求另一个站点的文档或脚本，具体看下如下实验：","text":"第一次听说JSONP跨域请求还是去年刚入职实习的时候，也借那个机会在网上好好了解了下用法，但是对于其如何实现还是不太明白。昨天一同事问我当时对JSONP的使用情况，突然发现一年多没用，对于这个跨域请求技术又忘的差不多了，刚好不知道这个星期该写篇什么方面的文章，那就趁这个机会再把JSONP琢磨琢磨顺便把过程记录下来，免得下次不记得了又得到网上到处找资源查阅。 OK，进入正题！！！！ 先看JSONP定义 JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的&lt;script&gt; 元素是一个例外。利用 &lt;script&gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。JSONP它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。——来自百度 同源策略 同源策略是一种约定，也是浏览器本身最核心最基本的一个安全功能。所谓同源是指协议、域名、端口相同，也就是说同源策略不允许一个站点的某个文档或脚本加载请求另一个站点的文档或脚本，具体看下如下实验： 我新建一个站点作为本地站点，端口号为8080，如下：再建一个站点作为远程站点，端口号为8085，如下：我在本地站点中添加两个按钮，一个请求远程站点文档，一个请求本地站点文档，我们来看看效果如何请求代码如下：12345678910111213141516//请求远程站点文档function remoteBtnClick() &#123; $.get(\"http://localhost:8085/Remote/jslib/jquery-1.7.2.js\", function(data)&#123; console.log(data); &#125; );&#125;//请求本地站点文档function localBtnClick() &#123; $.get(\"http://localhost:8080/Local/jslib/jquery-1.7.2.js\", function(data)&#123; console.log(data); &#125; );&#125; 请求响应结果如下：正如前面说的，根据同源策略浏览器不允许本地站点直接通过Http请求读取另外一个远程站点的资源信息。 看到这，相信大家很快会想到一种情况———引入外部js类库&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&quot;&gt;&lt;/script&gt;比如这个引入百度地图JS类库的代码，很明显，这个地图JS类库和我们自己的站点明显不是在同一个域内，对于这种情况我也写一个测试程序验证一下。我在本地站点8080的页面中添加这样一行代码&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8085/Remote/jslib/remote.js&quot;&gt;&lt;/script&gt;以希望在本地页面加载的时候同时加载远程站点8085里的remote.js文件，remote.js文件中的内容如下：运行代码之后的效果图如下：很显然，通过这种方式是完全可以读取远程站点的文档信息的，也就是说像这种src属性的加载方式是不受同源策略所约束可以访问任何站点的文档信息，另外像大家用的很多的图片加载标签，也经常通过其src属性加载网络图片。 实现基本的跨域请求 看了上面的例子和JSONP的定义相信大家已经明白了JSONP跨域请求的基本原理，利用script的这种加载方式我们就可以实现跨域请求。 我在本地站点中动态构造一个script标签，然后将其src的url指向远程站点的文档，最后将这个script标签添加到页面dom中，先写个例子看这种方式能不能行得通。1234//远程站点8085上remote.js中的内容依然和上面一样，不做任何改变function remoteBtnClick() &#123; $(\"&lt;script&gt;&lt;//script&gt;\").attr(\"src\", \"http://localhost:8085/Remote/jslib/remote.js\").appendTo(\"body\")&#125; 运行之后的结果和上面直接通过&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8085/Remote/jslib/remote.js&quot;&gt;&lt;/script&gt;加载的效果是一样，这里就不继续贴图，因为原理是一样，很显然结果必然相同，而且也没必要动态写这么麻烦，直接加载岂不是更直接。 接着我们来另外一个情况，既然JSONP定义中说了JSONP拿到的是JSON数据，那我们将远程站点请求文件remote.js换成一个JSON数据文件remote.json({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})再试试。123function remoteBtnClick() &#123; $(\"&lt;script&gt;&lt;//script&gt;\").attr(\"src\", \"http://localhost:8085/Remote/remote.json\").appendTo(\"body\")&#125; 图1： 图2： 看图1中的请求响应结果，很明显，这个json数据已经从远程站点请求成功并且拿到了本地站点下。通过图2我们发现这里有个javascript的语法错误，因为我们是通过javascript标签的方式加载的，而这个标签是将文档加载完成后会立即把其当做js执行，而这个json数据很明显不是一个合法的js语句。既然这样，那我们就想办法让这个json数据变成一个合法的js语句，最简单的方法就是将这个json数据当做一个函数的参数给塞进去，例如：callbackHandler({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})，如果本地站点中有一个callbackHandler函数，那么远程站点返回的这个数据就是一个合法的js函数，很显然这个时候单纯的通过js客户端来验证这个例子是无法实现的，因为在远程站点8085中无论是json文件还是js文件中都无法直接构造callbackHandler({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})这么一段代码(语法不正确)给本地站点8080去远程调用。123function callbackHandler(json) &#123; console.log(json)&#125; 这个时候就需要远程站点的服务端进行配合，由于远程站点后端服务不知道本地客户端的回调函数名是callbackHandler，所以，我们需要在远程调用的时候告诉服务端本地的回调函数名是callbackHandler，此时的本地站点8080上的请求方式则换这样：12345$(\"&lt;script&gt;&lt;//script&gt;\").attr(\"src\", \"http://localhost:8085/Remote/JSONPServlet?callback=callbackHandler\").appendTo(\"body\")&#125;function callbackHandler(data) &#123; console.log(data);&#125; 远程站点8085上服务端代码如下： 123456789public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String callback = request.getParameter(\"callback\"); response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); out.println(callback + \"(&#123;'data':'The data from remote','time':'2014-12-20'&#125;)\"); out.flush(); out.close();&#125; 服务端通过参数解析知道本地站点客户端的回调函数名是callbackHandler，远程服务端构造一段callbackHandler({&quot;data&quot;:&quot;The data from remote&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})返回即可，这样在script标签加载完成后会直接将取得的json数据当做参数传入该回调函数中执行，这样整个跨域请求(请求服务端)就完成了。JSONP的跨域请求差不多就这样实现了，但是运行效果如下：运行结果正如我们所想，通过script方式加载远程服务返回javascript tags可以顺利实现跨域访问，这里我也继续试验下直接通过ajax方式访问远程后端服务，将remoteBtnClick()实现改为如下方式：123456$.get(\"http://localhost:8085/Remote/JSONPServlet?callback=callbackHandler\", function(data)&#123; console.log(data); &#125; );&#125; 请求结果如下：显然，请求的结果和前面的请求远程站点客户端文档信息是一样，因为同源策略而无法访问。 OK，JSONP的实现方式和相关验证基本上就爱完成了，现在也知道了JSONP的实现原理和实现方式，但是上面这种实现方式有点麻烦，既要自己添加script标签，同时还要自己定义一个回调函数，感觉略显麻烦，其实jQuery中已经直接提供类似的JSONP请求方式，我们只需要按照其定义好调用方式即可进行Http的跨域请求。现在我将remoteBtnClick()实现方式修改为如下，远程服务端代码不修改：1234567891011121314151617function remoteBtnClick() &#123; $.ajax(&#123; url: 'http://localhost:8085/Remote/JSONPServlet', dataType: \"jsonp\", jsonp: \"callback\", jsonpCallback: \"callbackHandler\", success: function (data) &#123; console.log(data); console.log(\"success\"); &#125; &#125;);&#125;//客户端回调function callbackHandler(json) &#123; console.log(json); console.log(\"callbackHandler\");&#125; 请求结果如下： 可以看到，现在直接通过ajax请求远程站点服务也成功实现了跨域请求，这个是jQuery自己已经帮我们封装好的功能。对于ajax请求中的几个参数我简单说描述下作用： dataType:’jsonp’，这个是代表当前Http请求为jsonp的请求方式； jsonp：’callback’,这个代表的是远程服务端接收客户端回调函数名的参数名，即：String callback = request.getParameter(&quot;callback&quot;)这个参数，ajax请求中jsonp参数的默认值就是callback，这个也可以自己随便更换； jsonpCallback:’callbackHandler’,这个代表远程服务调用结束后的本地回调函数名，比如上面的代码中的那个客户端回调函数名，这个jsonpCallback的参数值也是可以自己随便定义的，也可以不给这个jsonpCallback参数，其实jQuery会自动为我们生成一个函数和函数名，从上面的结果图中我们可以看到，远程服务调用成功后，既执行了SUCCESS这个回调函数，也执行我们自己定义的callbackHandler这个回调函数，所以我们完全可以使用jQuery给我们生成的回调函数，在调用结束后在SUCCESS回调中做相应的处理即可，如下是不加该参数的调用方式：12345678$.ajax(&#123; url: 'http://localhost:8085/Remote/JSONPServlet', dataType: \"jsonp\", jsonp: \"callback\", success: function (data) &#123; console.log(data); &#125; &#125;); 上面结果图中的圈中部分就是jQuery为我们自动生成的回调函数名。 OK，JSONP的实现方式及实现原理基本上介绍演示完了，至于jQuery中对于JSONP的实现封装方式等我有时间研究下了再继续吧~~ write by laohu2015年3月20日","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ittiger.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ittiger.cn/tags/JavaScript/"},{"name":"JSONP","slug":"JSONP","permalink":"http://ittiger.cn/tags/JSONP/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://ittiger.cn/categories/JavaScript/"}]},{"title":"Lucene近实时搜索应用总结","slug":"Lucene近实时搜索应用总结","date":"2014-12-11T11:12:55.000Z","updated":"2016-07-28T05:29:47.488Z","comments":true,"path":"Lucene近实时搜索应用总结.html","link":"","permalink":"http://ittiger.cn/Lucene近实时搜索应用总结.html","excerpt":"最近因工作需要，用到了Lucene，在需求中，需要对生成的索引文件不断的更新、新增、删除等操作，同时还要实时的看到索引改动后的数据，在使用过程中碰到了Lucene里几个比较常见的问题，特来总结记录下。 我使用的是Lucene4.3，本来是想使用最高的版本Lucene4.9的(不知道现在又有么有新的版本出现)，但是因为公司项目的JDK都是JDK6的，而Lucene4.9的支持的最低JDK版本是7+的，所以最后选择了这个版本。第一次碰这个东东，也是在网上搜罗各种资料，当然官网是少不了的，还有一个网址，这个里面的版本更全面，包含了Lucene所有的版本，有需要的可以去下载自己想要的版本。 OK，进入正题。 在读取索引文件内容时，索引文件的打开操作 new IndexSearcher(DirectoryReader.open(FSDirectory.open(new File(indexPath)))) 是个非常耗时耗资源的操作，所以在搜索索引数据时把IndexSearcher对象给缓存起来可以提高搜索性能，这个地方可以将索引目录对应的IndexSearcher对象做成一个单例模式进行获取。 在问题1的操作基础上，我对索引进行了更新操作，紧接着我就发现了一个问题，索引更新后我查询出来的结果和我更新后的结果对不上号。再网上查了半天没找到原因，后来在一个群里请教之后，才知道更新完索引之后，索引文件需要重新打开，否则搜索得到的还是原来索引的数据，Lucene里面的这个原理非常重要。 因为当时对Lucene了解的不是很多，所以为了每次更新后能搜索到正确的数据，我的做法是每次更新完索引就将我之前缓存的IndexSearcher对象和Reader对象给移除掉，下次搜索时重新打开索引，这样来保证搜索结果的正确性。","text":"最近因工作需要，用到了Lucene，在需求中，需要对生成的索引文件不断的更新、新增、删除等操作，同时还要实时的看到索引改动后的数据，在使用过程中碰到了Lucene里几个比较常见的问题，特来总结记录下。 我使用的是Lucene4.3，本来是想使用最高的版本Lucene4.9的(不知道现在又有么有新的版本出现)，但是因为公司项目的JDK都是JDK6的，而Lucene4.9的支持的最低JDK版本是7+的，所以最后选择了这个版本。第一次碰这个东东，也是在网上搜罗各种资料，当然官网是少不了的，还有一个网址，这个里面的版本更全面，包含了Lucene所有的版本，有需要的可以去下载自己想要的版本。 OK，进入正题。 在读取索引文件内容时，索引文件的打开操作 new IndexSearcher(DirectoryReader.open(FSDirectory.open(new File(indexPath)))) 是个非常耗时耗资源的操作，所以在搜索索引数据时把IndexSearcher对象给缓存起来可以提高搜索性能，这个地方可以将索引目录对应的IndexSearcher对象做成一个单例模式进行获取。 在问题1的操作基础上，我对索引进行了更新操作，紧接着我就发现了一个问题，索引更新后我查询出来的结果和我更新后的结果对不上号。再网上查了半天没找到原因，后来在一个群里请教之后，才知道更新完索引之后，索引文件需要重新打开，否则搜索得到的还是原来索引的数据，Lucene里面的这个原理非常重要。 因为当时对Lucene了解的不是很多，所以为了每次更新后能搜索到正确的数据，我的做法是每次更新完索引就将我之前缓存的IndexSearcher对象和Reader对象给移除掉，下次搜索时重新打开索引，这样来保证搜索结果的正确性。 索引的更新代码大致如下：123456789101112131415161718//获取索引的写对象 public static IndexWriter getIndexWriter(String indexPath) throws Exception &#123; Directory dir = FSDirectory.open(new File(indexPath)); if(IndexWriter.isLocked(dir)) &#123; IndexWriter.unlock(dir); &#125; IndexWriterConfig iwriterConfig = new IndexWriterConfig(Version.LUCENE_43, new ComplexAnalyzer()); IndexWriter indexWriter=new IndexWriter(dir, iwriterConfig); return indexWriter; &#125; //索引更新操作，索引中的更新逻辑是将旧的文档删除，再将新的文档新增进去 public static void updateLucene(String indexPath，要更新的数据参数) &#123; IndexSearcher indexSearcher = getIndexSearcher(indexPath); Document oldDoc = ....//根据IndexSearcher查询得到被更新的旧文档--1处 Document newDoc = ....//根据旧文档和要更新的具体数据得到要更新的新文档 indexWriter.updateDocument(doc);//更新操作--3处 removeReader(indexPath);//移除IndexSearcher缓存对象--2处&#125; 问题3中的这个跟新操作写完之后实际应用的时候，出了好几个问题，都是Lucene里面比较常见，容易犯错的问题。异常1：org.apache.lucene.store.AlreadyClosedException: this IndexReader is closed经过分析之后发现是因为多并发情况下时，同一个索引文件对应的Reader对象别多个线程持有，在我这个代码里存在线程1刚好执行完2处代码将Reader缓存清理掉(同时关掉了该Reader对象)，而刚好，线程2在执行代码1处的查询操作，这个时候就会出现这个异常。在我这个代码里的更新操作总共分3部，首先查询出旧的文档，紧接着构造新文档并执行更新操作，第三步是移除缓存，所以这三步应该归结为一个原子操作，所以我很自然的就想到了同步锁synchronized，在该方法上添加Class级的同步锁，由于我的代码里有多个这种更新索引的方法，所以每个方法都加一个同步锁，后来证明这种方式也不行仍然出现了该异常，具体代码的问题出在哪我现在真记不起来了，而且这种多个静态方法都加Class级的同步锁性能注定不怎么样，后续的解决办法下面问题中继续说。异常2：LockObtainFailedException经过查询资料知道这是因为在IndexWriter的构造函数在试图获取另外一个IndexWriter已经加锁的索引目录时抛出的错误，这是因为在Lucene中只能允许一个线程去进行写操作，当该线程获取到这个写对象后，会在索引目录中生成一个write.lock文件，所以在这个线程没有释放该索引目录的锁对象前，其他线程无法获取该目录的写对象，根据这个write.lock文件，我们可以很方便的判断当前索引目录有没有被写对象占用，改造后的代码如下： 12345678910111213141516171819202122232425262728private Object synchronized_w = new Object(); private IndexWriter getIndexWriter() &#123; synchronized (synchronized_w) &#123; try &#123; Directory dir = null; while (true) &#123; dir = FSDirectory.open(new File(indexPath)); if(!IndexWriter.isLocked(dir)) &#123; if(indexWriter == null) &#123; indexWriter = new IndexWriter(dir, new IndexWriterConfig(Version.LUCENE_43, LuceneManager.getAnalyzer())); &#125; break; &#125; else &#123; try &#123; dir.close(); Thread.sleep(100); Thread.yield(); &#125; catch (InterruptedException e) &#123; logger.error(\"获取索引\" + indexPath + \"写对象IndexWriter失败\", e); &#125; &#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"获取索引\" + indexPath + \"写对象IndexWriter失败\", e); &#125; &#125; return indexWriter; &#125; 获取索引写对象的代码经过如此改造之后，成功运行，没有出现问题。 继续问题4中的第一个异常，分析之后觉得问题出现的最终原因还是在第三步移除缓存时关闭Reader对象这里，所以如果Lucene能不需要手动关闭Reader对象就可以解决这个问题，带着这个问题我重新去查看了Lucene4.3的API文档，看了之后发现了两个个比较重要的API，DirectoryReader.openIfChanged(dirReader)和DirectoryReader.isCurrent()，前者是个静态方法，可以判断当前Reader对象的索引有没有被修改过，如果索引文件被更新过则重新加载该索引目录，但是这个时候的重新加载则比单纯的open(indexPath)要高效很多，它只是重新加载被更新过的文档，而单纯的open则是加载全部的文档，重新加载后我们查询的时候就可以查询到最新的数据结果了。而第二个API是个实例方法，用来判断当前Reader对象所代表的索引文件是不是最开始那个，即判断当前索引文件有没有被更新过，有更新则返回false，否则返回true，则两个API结合在一起刚好可以解决我之前的Reader关闭问题。有了这种重新加载机制，我就不需要每次更新索引之后清除缓存关掉旧的Reader对象并打开新的对象。改造的代码如下： 123456789101112131415161718public IndexSearcher getIndexSearcher() &#123; synchronized (lock_r) &#123; try &#123; if(indexSearcher == null &amp;&amp; dirReader == null) &#123; dirReader = DirectoryReader.open(FSDirectory.open(new File(indexPath))); indexSearcher = new IndexSearcher(dirReader); &#125; else if(indexSearcher != null &amp;&amp; dirReader != null &amp;&amp; !dirReader.isCurrent()) &#123; //判断有没有更新过，有更新则重新加载更新过的文档 DirectoryReader newDirReader = DirectoryReader.openIfChanged(dirReader); indexSearcher = new IndexSearcher(newDirReader); dirReader = newDirReader; &#125; &#125; catch (IOException e) &#123; logger.error(\"获取索引\" + indexPath + \"搜索对象IndexSearcher失败\", e); &#125; &#125; return indexSearcher; &#125; 这个代码里面有个问题就是旧的Reader对象没有关闭掉，如果加上这reader.close()这句话又会出现那个异常，不加的话运行没有问题，但是我总觉得不关掉不太好，感觉占着资源。然后继续查看API文档，发现了SearcherManager这个类，这个是Lucene里面提供的工具类，主要是用来了管理IndexSearcher对象的，仔细阅读了该类的说明及其源代码后觉得用这个工具类更靠谱，所以最后毫不犹豫的重新写了一个IndexSearcher对象的获取方式，代码如下： 1234567891011121314151617private IndexSearcher getIndexSearcher() throws IOException &#123; IndexSearcher indexSearcher = null; synchronized (synchronized_r) &#123; if(searcherManager == null) &#123; searcherManager = new SearcherManager(FSDirectory.open(new File(indexPath)), new SearcherFactory()); &#125; searcherManager.maybeRefresh();//这个方法同DirectoryReader.openIfChanged(dirReader)效果一样，其实底层还是调用的该方法实现的 indexSearcher = searcherManager.acquire();//借用一个IndexSearcher对象的引用，记住该对象用完之后要归还的，有借有还再借不难 &#125; return indexSearcher;&#125;private void closeIndexSearcher(IndexSearcher indexSearcher) throws IOException &#123; if(indexSearcher != null) &#123; searcherManager.release(indexSearcher);//归还从SearcherManager处借来的IndexSearcher对象 &#125; indexSearcher = null;&#125; 如此实现之后，就不需要我们自己管理这个旧的Reader对象，而是交由Lucene本身自己去进行管理，而且此种实现方式更简洁明了，也完美解决了我的问题。 实现了索引更新后的数据的读取实时性就可以实现一个简单的实时搜索功能。 最后为了保证项目中Lucene使用的稳定性，我对索引文件的更新和查询都添加了读写锁ReentrantReadWriteLock来进行控制，更新的时候添加写锁，查询的时候添加读锁，这样更加的保证了Lucene使用的安全性。 简单介绍下读写锁ReentrantReadWriteLock的机制(多线程并发的时候很有用)： 在某个线程获取到读锁时，其他线程不能获取写锁，但是可以获取读锁 在某个线程获取到写锁时，其他线程既不能获取写锁也不能获取读锁 给个示例代码：1234567891011121314private ReentrantReadWriteLock w_lock = new ReentrantReadWriteLock();//读写锁 public void updateDocument(Term term, Document doc) throws Exception &#123; try &#123; w_lock.writeLock().lock();//获得写锁 getIndexWriter(); indexWriter.updateDocument(term, doc); indexWriter.commit(); &#125; catch (IOException e) &#123; throw new Exception(e); &#125; finally &#123; closeIndexWriter(); w_lock.writeLock().unlock();释放写锁 &#125; &#125; OK，到这里我的问题基本上就写完了，有时间再去研究研究Lucene的其他的特性。 write by laohu2014年12月11日19:12:55","categories":[{"name":"Java","slug":"Java","permalink":"http://ittiger.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://ittiger.cn/tags/Java/"},{"name":"Lucene","slug":"Lucene","permalink":"http://ittiger.cn/tags/Lucene/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://ittiger.cn/categories/Java/"}]}]}